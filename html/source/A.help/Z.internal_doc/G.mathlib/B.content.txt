[topic](param)


新版软件函数使用说明
================

数组求最大值：max()
----------
**函数说明：** max函数支持数组和动态数组求最大值，数组元素类型可以是整型和浮点型，但不能是复数类型。函数的返回值是数组中值最大的元素。用法：max(A)或math.max(A)。   
**用法举例：**
```
>> a = [1,2;3,4];
>> max(a)
results:  4
```
数组求最小值：min()
---------------

**函数说明：** min函数支持数组和动态数组求最小值，数组元素类型可以是整型和浮点型，但不能是复数类型。函数的返回值是数组中值最小的元素。用法：min(A)或math.min(A)。  
**用法举例：**
```
>> a = [1,2;3,4];
>> min(a)
results:  1
```
数组求和：sum()
----------------

**函数说明：** sum函数支持数组和动态数组求和，数组元素类型可以是整型、浮点型、复数类型。函数的返回值是数组中所有元素的和。用法：sum(A)或math.sum(A)。    
**用法举例：**
```
>> a = [2,2i;4,5i];
>> sum(a)
results:  6+7i
```



数组求平均值：mean()
---------------------
**函数说明：** mean函数支持数组和动态数组求平均值，数组元素类型可以是整型、浮点型和复数类型。当数组有复数类型的元素时，返回值为复数类型，否则返回值类型为双精度浮点类型。

用法：    
求数组A所有元素的均值：`mean(A)`或`math.mean(A)`；    
数组A按列求均值：`mean(A,0)`;    
数组A按行求均值：`mean(A,1)`。  

**用法举例：**
```
>> A = [1,2;3+4i,5];
>> mean(A);
>> mean(A,0);
>> mean(A,1);
```
代码运行结果分别是：
``` 
results: 2.75+1i
results: 2+2i  3.5+0i
results:
    1.5+0i
    4+2i
```

---
数组元素查找函数：find_index( )
-------------------------------
**函数说明：** find_index（A,x）求解数组A中值为x的元素的索引值。该函数在求解索引值的过程中，若数组为多维数组，函数将其转换为一维数组，返回值为一维整型数组，数组的每个元素依次对应为值为x的元素的索引值（即一维数组的下标值）。用法：`find_index(A,x)`或`math.find_index(A,x)`。  

**用法举例：**
```
>> A = [1,2;4,1];
>> find_index(A,1)
results:
    0
    3
```

---
线性调频z变换：czt( )
--------------------------
**函数说明：** czt函数通过z变换计算特定频段信号的频谱，通常采用czt函数细化关心频段内的信号频谱。用法：`czt（signal,num,freq_bet,freq_end）`，其中函数参数的物理意义：
* signal： 　待变换的信号
* num:    　　　关心频段的细化点数
* freq_beg: 　 关心频段的起始频率
* freq_end: 　 关心频段的终止频率

**用法举例：**

```lua
>> fs = 1000;
>> f = linspace(-fs/2,fs/2,1000);
>> x = sin(2*pi*f/fs);
>> f1 = 100;
>> f2 = 150;
>> ff = czt(x,1024,f1,f2);
>> fi = fig.new_figure();
>> xl = linspace(100,150,1024);
>> fig.plot(xl,abs(ff))
```

结果图：
 [image]("image/Math_image/czt.jpg","czt 频谱细化处理图",".czt")



生成均匀分布随机数randu()
--------------------------

**函数说明：** `R = rand.randu(m,n,k)`返回 $m\times n\times k$ 维在(0,1)范围内满足均匀分布的随机数。用法：`rand.randu(m,n,k)`，参数$m,n,k$都必须是值大于0的整数，其中$n$和$k$可省略。  

**用法举例：** 

``>> A = rand.randu(3)``

代码运行结果：
```
0.718098
0.085263
0.771667
```
``>> B = rand.randu(2,3)``
代码运行结果：
```
0.670029   0.990824   0.752741
0.0496988  0.0274534  0.33829
```

生成标准正态分布随机数randn()
----------------------------------

**函数说明：** `R = rand.randn(m,n,k)`返回 $m\times n\times k$ 维满足标准正态分布（均值为0，标准差为1）的随机数。用法：`rand.randn(m,n,k)`，参数$m,n,k$都必须是值大于0的整数，其中$n$和$k$可省略。

**用法举例：** 

```
>> rand.randn(2,2)
results: 
    0.764215   -2.20585
    -0.495294  -1.48313
```

生成复数版本的标准正态分布随机数randn_cpx()
--------------------------------------------

**函数说明：** `R = rand.randn_cpx(m,n,k)`返回 $m\times n\times k$ 维的随机复数，该复数的实部和虚部均满足标准正态分布。用法：`rand.randn_cpx(m,n,k)`，参数$m,n,k$都必须是值大于0的整数，其中$n$和$k$可省略。    
**用法举例：**
```
>> rand.randn_cpx(2,2)
results:
    0.759837-1.01945i  -0.928163+0.13555i
    0.939386-0.298229i  -1.37728+0.0870167i
```


生成单个随机数rand_int()和rand_double()
-------------------------------

**函数说明：**
`rand.rand_int()`： 生成随机整型数；    
`rand.rand_double()`:  生成(0,1)区间内的随机浮点数；    

**用法举例：**
```
>> rand.rand_int()
results: 3530171493
>> rand.rand_double()
results: 0.461303
```


快速傅立叶变换fft()、fft2()和fft3()
--------------------------------

**函数说明：**
`fft(A)`用快速傅立叶变换计算序列A的离散傅立叶变换;`fft2(A)`计算二维数组A的离散傅立叶变换；`fft3(A)`计算三维数组A的离散傅立叶变换。用法：`fft(A)`或`math.fft(A)`，`fft2(A)`或`math.fft2(A)`，`fft3(A)`或`math.fft3(A)`。
    

**用法举例:**
```lua
>> N = 1000;
>> t = linspace(0,40,N);
>> fs = 1.0/(t[1]-t[0]);
>> f = linspace(-fs/2,fs/2,N);
>> y = zeros(1,N);
>> A = 1.0;
>> K = 0.2;
>> f0 = 0.1;
>> tt = math.mod(t,10);   //调频周期：10s
>> y = A*sin(2*pi*(f0+K*tt/2).*tt);
>> fig1 = fig.new_figure();
>> fig.plot(t,y);
>> fig.title('线性调频连续波信号');
>> fig.xlabel('Time[s]');
>> fig.ylabel('Amplitude[V]');
>> yy = fft(y)/N;
>> yy = fftshift(yy);
>> fig2 = fig.new_figure();
>> fig.plot(f,abs(yy));
>> fig.title('频域信号');
>> fig.xlabel('Frequency[Hz]');
>> fig.ylabel(Amplitude[V]);
```


结果图：
<center>

[image](image/Math_image/线性调频信号.JPG ,"线性调频信号")


图2 线性调频连续波信号

[image](image/Math_image/线性调频信号的频谱.JPG ,"线性调频信号频谱")


图3 线性调频连续波信号频谱

</center>
二维傅立叶变换例子：    


```
>> a = [1,2+1i,3.2;4i,3.0,5];
>> b = fft2(a);
results:
    14.2+5i  -4.73397+6.27128i  -6.46603+0.728719i
    -1.8-3i  3.26603-5.19282i  1.5
```

逆傅立叶变换ifft()、ifft2()和ifft3()
--------------------------

**函数说明：**
`ifft(A)`用快速傅立叶变换计算序列A的离散逆傅立叶变换;`ifft2(A)`计算二维数组A的离散逆傅立叶变换；`ifft3(A)`计算三维数组A的离散逆傅立叶变换。用法：`ifft(A)`或`math.ifft(A)`，`ifft2(A)`或`math.ifft2(A)`，`ifft3(A)`或`math.ifft3(A)`。  

**用法举例：**
```
>> a = [1,2+1i,3.2;4i,3.0,5];
>> ifft2(a)
results:
    2.36667+0.833333i -1.07767+0.121453i -0.788996+1.04521i
    -0.3-0.5i         0.255662-0.63453i   0.544338-0.86547i 
```

将零频分量平移到频谱中心：fftshift()及其逆变换：ifftshift()
-----------------------------------------------------------

**函数说明：**
`fftshift(A)`将零频分量平移到数组中心，重新排新数据A；
`ifftshift(A)`将进行过零频平移的数据A重新排列回原始变换输出的样子。  

**用法举例：**
```
>> a = [1,2,3,4,5];
>> b = fftshift(a)
results:
    4+0i 5+0i 1+0i 2+0i 3+0i
>> ifftshift(b)
results:
    1+0i 2+0i 3+0i 4+0i 5+0i
>> ifftshift(a)
results:
    3+0i 4+0i 5+0i 1+0i 2+0i
>> c = [1,2,3;4,5,6;7,8,9]
    1 2 3
    4 5 6
    7 8 9
>> fftshift(c)
    9+0i 7+0i 8+0i
    3+0i 1+0i 2+0i
    6+0i 4+0i 5+0i
>> ifftshift(c)
    5+0i 6+0i 4+0i
    8+0i 9+0i 7+0i
    2+0i 3+0i 1+0i
```

转置运算：transp()
----------------------

**函数说明：** 
`transp(A)`将矩阵A的行和列互换得到新的矩阵。用法：`transp(A)`或`math.tranps(A)`。  

**用法举例：**
```
>> a = [1,2,3;4,5,6]
results:
    1  2  3
    4  5  6
>> transp(a)
results:
    1  4
    2  5
    3  6
```

重排数组维度permute()
------------------------
**函数说明：**
`permute(A,[m,n,k,…])`将数组A的第m+1维和第1维互换，第n+1维和第2维互换，第k+1维与第3维互换，依次最多互换6个维度，得到新的数组。注意这里m和n都要加1的原因是c++语言的数组下标是从0开始的。permute函数是transp函数在高维数组转置上的推广。用法：`permute(A,[m,n,k,…])`或`math.permute(A,[m,n,k,…])`，转置参数向量`[m,n,k,…]`长度大于等于2。  

**用法举例：**
```
>> a = [1,2,3;4,5,6]
results:
    1  2  3
    4  5  6
>> permute(a,[1,0])
results:
    1  4
    2  5
    3  6
```

卷积运算conv()
----------------

**函数说明：**
卷积是一种数学运算，它涉及到积分或级数运算，是数字信号处理中最基础、最重要的概念。两个时间信号$f(n)$和$g(n)$的卷积定义为：

$$
f(n)* g(n) = \int_{-\infty}^\infty f(\tau)g(n-\tau)d\tau
$$


其离散的定义为：

$$
f(n)\ast g(n)=\sum_{\tau=-\infty}^\infty f(\tau)g(n-\tau)
$$



时间序列的卷积的一个通俗的例子是多项式乘法，如

$a(x) = 1+2x+x^2, b(x) = x+3x^2$，两多项式的系数分别表示为    
$a(n) = [1,2,1]$    
$b(n) = [0,1,3]$  


多项式的乘法:    

$$
\begin{aligned}
 c(x) &= a(x)\cdot b(x) \\
      &= (x^2+2x+1)\cdot (3x^2+x)\\
      &= x+5x^2+7x^3+3x^4
\end{aligned}
$$

$c[x]$的系数向量$c[n]=[0,1,5,7,3]$，而$a(n)$与$b(n)$的卷积：

$$
\begin{aligned} 
  a(n)*b(n) &= [1,2,1]*[0,1,3] = [0,1,5,7,3] \\
       &=c(n)
\end{aligned}
$$

**函数用法：**    
向量a与b的卷积：`conv(a,b)`或`math.conv(a,b)`；二维数组a与b的卷积：`conv2(a,b)`或`math.conv2(a,b)`。  

**用法举例：**
```
>> a = [1,2,1];
>> b = [0,1,3];
>> conv(a,b)
results:
    0 1 5 7 3
```

计算两个序列的相关系数xcorr()
-------------------------------
**函数说明：**
信号X和信号Y的相关系数公式：
$$
\rho = \frac{Cov(X,Y)}{\sigma_X \sigma_Y}
$$
即信号$X$和信号$Y$的协方差除以$X$的标准差和$Y$的标准差。它反映了两个信号变化时是同向还是反向，如果同向变化就为正，反向变化就为负，两信号的相关性（协同性）越强，相关系数的绝对值越大，反之越小，如果完全不相关，则相关系数的值为0。  

**函数用法：**
向量X和向量Y的相关系数：`math.xcorr(X,Y)`。  

**用法举例：**
```
>> a = [1,2,3];
>> b = [0,1,3];
>> math.xcorr(a,b);
results:
    3 7 11 3 0
```

基于高斯核函数的数据概率密度估计ksdensity()
--------------------------------------------

**函数说明：**
核密度估计（Kernel density estimation），是一种用于估计概率密度函数的非参数方法，$x_1,x_2,\ldots,x_n$为独立同分布的$n$个样本点，设其概率密度函数为$f$，核密度估计公式为：

$$
\hat{f}_h(x)=\frac{1}{n}\sum_{i=1}^{n} K_h(x-x_i)=\frac{1}{nh}\sum_{i=1}^{n} K\left(\frac{x-x_i}{h}\right)
$$

$K(.)$为核函数，$h>0$为平滑参数，称为带宽或核宽。`ksdensity()`函数采用的核为高斯核。


**函数用法：** 一维信号A的概率密度为`math.ksdensity(A)`。  

**用法举例：**
```
>> s = rand.randn(1,1000);
>> y = math.ksdensity(s);
>> f = fig.new_figure();
>> fig.plot(1:100,y);
```
结果图：
<center>

[image](image/Math_image/高斯核概率密度图.JPG, "高斯核概率密度估计")

</center>
<center>  图4 正态分布信号高斯核概率密度估计 </center>


基于高斯核函数的曲线平滑处理ker_smooth()
------------------------------------------

**函数说明：**
核、窗、掩模滤波是数字图像空间滤波的基本方法，平滑滤波是空间滤波的应用之一，曲线平滑处理相当于“一维图像”的平滑滤波。 基于高斯核函数的曲线平滑的处理过程是固定原数据曲线，将高斯核函数的峰值位置对齐到第一个数据点并相乘，其它的数据点与对应的高斯核函数的点数据相乘，最后加和并除以高斯核的和得到第一个数据的处理后的新数据。依次处理第2个数据点、第3个数据点、……、最后一个数据点。数学表达式为：


$$\hat{f}(x)=\frac{\sum_{i=1}^n K(x_i-x;h)y_i}{\sum_{i=1}^n K(x_i-x;h)}$$


**函数用法：** `math.ker_smooth(x,y,h)`，其中x为待平滑曲线数据的x坐标，y为待平滑曲线数据的y坐标，h为高斯核核宽，根据平滑效果手动设置。  

**用法举例：**
```
>> local x = linspace(1,2*pi,200);
>> local data = cos(x) + exp(1./x);
>> f1 = fig.new_figure();
>> fig.plot(x,data);
>> local y = data + rand.randu(200);
>> f2 = fig.new_figure();
>> fig.plot(x,y);
>> local h = 0.2;                                     //可调参数
>> local xs = linspace(min(x)-3*h,max(x)+3*h,100);
>> local s = math.ker_smooth(x,y,h);
>> f3 = fig.new_figure();
>> fig.plot(xs,s);

```
结果图：
<center>

[image](image/Math_image/平滑前的曲线.JPG, "原曲线")


图5 平滑处理前的曲线

[image](image/Math_image/平滑后的曲线.JPG, "平滑后的曲线")


图6 平滑处理后的曲线
</center>
