# 计算模式构建指南

## 概念
计算模式是仿真流程模式的抽象。通过定义计算模式，可以省去用户建立激励源、监视器、部分模型和后处理的工作。更为关键的在于计算模式可以针对领域特定问题定义参数集合，从而减少用户解读工程模型和后处理结果的工作量。


* 建模的层次

整个EastWave仿真建模体系分为三个层次：
+ 仿真模型(Model)
  * 负责细节的定义
  * 负责基本仿真参数的定义
  * 负责将用户变量表转换为一般元件参数
  * 仿真模型的元件参数、结果的含义一般具有数学意义和物理意义而不具有工程学含义（即领域术语）
  * 仿真模型在默认的计算模式和调度器下经过求解器运行得到原始的结果输出
  * **物理级仿真**(Physical Simulation)
  * **仿真原语**(Simulation Semantics)
+ 计算模式(Workmode)
  * 对仿真模型的修饰和提升
  * 计算模式自身的基本参数和最终输出结果是领域术语
  * 将计算模式自身的基本参数转化为仿真模型的参数，包括添加隐藏元件
  * 具有操纵多次重复计算过程的能力
  * 具有根据需要改变仿真模型中元件参数更新逻辑的能力
  * 计算模式对仿真模型计算的原始输出数据进行进一步加工，得到具有工程学意义的结果
  * 计算模式不应当修改用户变量表，用户变量表中定义的变量可以在计算模式用户参数中使用
  * **工程级仿真**(Engineering Simulation)
  * **领域原语**(Domain Semantics)
+ 调度器(Dispatcher)
  * 调度器是对计算模式任务计算过程的组织
  * 调度器一般包括默认调度器（计算一次结束）、参数扫描调度器和参数寻优调度器三种，允许编写更为复杂的调度逻辑
  * 调度器可以多层嵌套
  * 调度器不能使用用户变量表的内容，但可以修改用户变量表的内容
  * 调度器需要解决多次计算的结果综合的问题
  * **智能级仿真**(Intelligent Simulation)
  * **任务原语**(Task Semantics)

**箭头图：**
```
                     Run Solver
   Model[2] --------------------------> Simple/Multiple Results            | Task Semantics         |
     /|\             Modify User Vars                /|\
      |                                               |
      | Lifting with a Dispatcher                     | Filter/Regroup by Dispatcher
      |                                               |
      |              Run Solver                       | 
   Model[1] --------------------------> Result interpreted by Workmode     | Domain Semantics       |
     /|\             Use User Vars                   /|\ 
      |                                               |
      | Decorate with a Workmode                      | Postprocess by workmode 
      |                                               |
      |              Run Solver                       | 
   Model[0] --------------------------> Result interpreted by Math/Physics | Simulation Semantics   |
                     Use User Vars
```

## 运行原理

求解器读取一个工程文档后，按照下面的次序进行工作（注意并行时多节点的行为）：
+ 读取用户变量表，进行解析求值
+ 依次读取调度器堆栈的栈顶，根据调度器的内部逻辑对用户变量表进行修改（如查询某个指定的变量修改其数值）
+ 处理完所有的调度器的操作后进入核心计算模式
  * [A] 主节点执行计算模式初始化函数`wmbase.init0()`
  * [B] 主节点更新`sddata.ndoc`（如无则设定为0），执行计算模式`wmbase.nextp()`函数，如果返回为`true`则进入计算循环[C]，否则跳出计算循环[G]，并所有节点同步`sddata`变量表
    * [C] 每个节点执行`wmbase.update()`函数，将`wmuser`的参数转换到`wmdata`中
    * [D] 每个节点执行`wmbase.check()`函数，一般检测`wmdata`中的参数
    * [E] 每个节点执行求解计算过程
    * [F] 每个节点执行计算模式后处理`wmbase.postp()`函数
  * [G] 全部节点跳出循环（由主节点通知其他节点是否要跳出循环或是继续下一次计算）
  * [H] 主节点执行`wmbase.fini0()`函数
+ 执行当前调度器内部的后处理，判断是否要进行下一轮计算模式或者下一次的内部调度器计算计算，如果不需要则退出到外面一层调度器依次判断
+ 结束全部计算过程

计算模式部分用伪代码表述：
```
wmbase.init0();
while(wmbase.nextp())
{
    wmbase.update();
    wmbase.check();
    wmbase.process();
    wmbase.postp();
}
wmbase.fini0();
```


## 参数更新逻辑
进入求解计算过程时，有一个参数解析过程（每个非从节点都会运行），见下表：

||(阶段说明,ll)
| 阶段(phase)  | 说明                               |
|  `param`     | 更新参数                           |
|  `border`    | 更新边界（类型）                   |
|  `freq`      | 更新频率                           |
|  `model`     | 加载模型                           |
|  `bbox`      | 更新物体包围框                     |
|  `cbox`      | 更新可见元件包围框                 |
|  `fbox`      | 更新计算区域（第1次）              |
|  `pml`       | 更新吸收边界                       |
|  `meshpos`   | 更新网格（即同时第二次更新fbox）   |
|  `time`      | 更新时间参数                       |
|  `solver`    | 更新求解器参数                     |
> `wmbase.hook0(phase)`函数会调用多次，每次更新一个阶段（按表格第一列的顺序）
> 解析的次序从上至下，在`wmbase.hook0(phase)`函数中，根据`phase`的取值（字符串）来确定。
> 单位在更新频率时加载

## 可用变量的说明

在计算模式的编写过程中用到的一些变量的说明：

||(计算模式脚本变量说明,ll)
| `td`         |    文档参数、建模方法集合                                                      |
| `config`     |    配置信息                                                                    |
| `wmbase`     |    计算模式通用过程与方法集合                                                  |
| `wmuser`     |    计算模式用户参数集合                                                        |
| `wmdata`     |    计算模式用户数据集合                                                        |
| `result`     |    计算模式生成的计算结果                                                      |
| `sddata`     |    并行节点之间的共享数据                                                      |
| `dparam`     |    模型文档参数，在前处理中可用                                                |
| `eparam`     |    引擎参数，在后处理中可用                                                    |
| `svdata`     |    求解器数据集，用于跨调度器传送数据（如向上传送数据时将自动传入`sddata`中    |

## 计算模式参数定义规范
* 规格说明是对计算模式的参数集、参数约束情况以及部分运行逻辑的说明和解释（建议对复杂以及可能产生误解的一些问题予以说明），一般写在计算模式程序的最顶部。
* `wmuser`和`wmdata`传送数据时按照约定的规则可以减少重复代码的编写，并且有利于计算模式规格定义信息的突出。在`wmbase.definition()`函数中定义计算模式变量的名称和默认值，并且自动包含了默认类型信息。在`wmbase.transfer(ar)`和`wmbase.init0()`两个函数中采用简单的名称构造法，因此大部分普通计算模式不需要对这两个过程进行额外的编写工作。另一方面，计算模式的界面对话框会调用`wmbase.transfer(ar)`函数进行参数同步工作。具体的规则如下：
* 在构造`wmbase`时，使用`wmbase = wmutil.create_workmode_basic()`或者其他类似的初始化函数。
* **计算模式规格变量表**：即在`wmbase.definition()`函数中返回一个变量表，建议使用`table { ... }`的方式表达，并且对齐代码，每一行一个参数，并且附加注释（如果有必要）。
* `wmbase.transfer(ar)`的默认行为是根据**计算模式规格变量表**根据嵌套的情况构建名字，例如参数`param1.freq`，在`wmuser`中的索引名称是`'param1.freq'`，因此引用方式为`wmuser['param1.freq']`。
* `wmdata`中保存的是已经被求值的各个用户参数，根据用户参数计算出来的一些衍生参数（为了方便后续重复利用）。
* `wmbase.update(dp)`过程负责将`wmuser`中的原始用户参数转换为计算模式处理过程中的内部数据，因此为了方便表述，建议采用规整的写法，并且尽量和**计算模式规格变量表**中的变量保持对应关系；一些衍生参数的处理注意保持逻辑的清晰性，例如可以使用`switch-case`语句。

## 例子与解释
计算模式规格说明信息的参考格式：
```ewsl
/* EastWave V7 RCS 计算模式
 * 规格设计：戴炜锋
 * 设计日期：2018/09/07
 * 修改时期：----/--/--
 * 模式名称：雷达散射截面计算模式（单站）
 * 备注信息：单站RCS计算（脉冲模式）
 * 帮助文档：
 * ***************************************
 * ... （略）
 */
```


典型的计算模式规格定义如下：
```ewsl
function wmbase.definition()
{
    return table {
        freq : table {
            mode    : 0;        // 0: 单值，1: 线性步进，2: 均匀采样，3: 列表
            value   : "1.0";
            min     : "0.9";
            max     : "1.1";
            count   : "21";
            step    : "0.01";
        };

        angle : table {
            mode    : 1;        // 0: Theta扫描，1: Phi扫描
            scsmode : 0;        // 0: ISO，1: HCS，2: GCS
            theta   : "90";
            phi     : "0:5:180";
        };

        misc : table {
            accuracy      : "1.0e-3";   // 脉冲式计算的场收敛条件
            customsignal  : false;      // 自定义高斯信号
            gaussianfreq  : "1.0";      // 高斯脉冲的中心频率
            bandwidth     : "0.2";      // 高斯脉冲的带宽
            ff_distance   : "1.0e+8";   // 远场距离，一般不影响计算结果，不在界面中体现
            add_space_src : "0.25";     // 平面波距离BBOX的距离
            add_space_mon : "0.25";     // 远场监视器距离平面波盒子的距离
            add_space_cal : "0.25";     // 计算区域边界和远场监视器盒子的距离
        };
    };
}
```

`wmbase.update(dp)`函数中对原始参数求值的例子：
> `dp.eval`的用法：`dp.eval(param_name, typename)`，第一个参数表示参数的名称，第二个参数表示求值的类型，要求是强类型求值。
```ewsl
wmdata.angle = table {
    mode    : dp.eval("angle.mode",    "integer"     );
    scsmode : dp.eval("angle.scsmode", "integer"     );
    theta   : dp.eval("angle.theta",   "array_double");
    phi     : dp.eval("angle.phi",     "array_double");
};
```

## 补充说明
* `wmutil`是针对计算模式某些较为通用的需求提供的辅助工具集，通过`#import wmutil`的方式调用。
* 在`wmbase.hook0()`函数运行阶段中，如果在较早的阶段直接指定了后续某个阶段的属性变量表，则计算模式内部的机制会跳过内部更新机制而直接采用预设的数值。利用该方法可以减少重复性工作（例如提前设定`dparam.meshpos`可以避免进行非均匀网格划分）。
