# EWSL程序设计阶段 I

[anchor](".expression")
## 表达式
表达式是构建EWSL语句的基本单位。我们将一个表达式赋值给一个变量，或者打印这个表达式的值，或者将表达式作为参数传递给某个函数时，也就对这个表达式进行了[link]("?help_script_Variables.evaluation","求值")的动作。

下面是几个表达式的例子：
+ 算术表达式`x1*y1+x2*y2`
+ 逻辑表达式`()`
+ 数组引用表达式`a[1:100] .* b[2:101]`
+ 字符串构造表达式`"abc".."def"`

表达式中引用到一些运算符，分为下列几类：

```block:operator-arithmetics
||(算术运算符)
| 算符  | 意义      | 备注  |
| +     | 加法      |       |
| -     | 减法      | 二元运算符        |
| -     | 取负      | 一元运算符        |
| \*    | 乘法      |       |
| /     | 右除      |       |
| ^     | 指数      |       |
| \\    | 左除      |       |
| %     | 取模      |       |
| ++    | 自加1     |(2,1) 两侧均可放置     |
| --    | 自减1     |
```

```block:operator-relations
||(关系运算符)
| 算符  | 意义      | 备注  |
| >     | 大于      |       |
| <     | 小于      |       |
| >=    | 大于等于  |       |
| <=    | 小于等于  |       |
| ==    | 等于      |       |
| !=    | 不等      |       |
| ===   | 对象等于  | 两个变量引用的内存对象是否一致    |
  

**补充说明：**关系运算不支持复数类型。

```

```block:dd
 ||
```

```block:sd
 |
```

```block:operator-logicals
||(逻辑运算符)
| 算符              | 意义      | 备注  |
| &&                | 逻辑与    |       |
| [block-ref](dd)   | 逻辑或    |       |
| ^^                | 逻辑异或  |       |
| !                 | 逻辑非    |       |
```


```block:operator-bitwises
||(位运算符)
| 算符              | 意义      | 备注  |
| &                 | 位与      |       |
| [block-ref](sd)   | 位或      |       |
| ^                 | 位异或    |       |
| \~                | 反码      |       |
| <<                | 左移位    |       |
| >>                | 右移位    |       |
```


```block:operator-arrays
||(数组运算符)
| 算符   | 意义     | 备注  |
| .+     | 加法     |       |
| .-     | 减法     |       |
| .\*    | 乘法     |       |
| ./     | 右除     |       |
| .\\    | 左除     |       |
| .^     | 指数     |       |
| []     | 索引     |       |
```


[anchor](".operator-arithmetics")
[block-ref](operator-arithmetics)  

[anchor](".operator-relations")
[block-ref](operator-relations)  

[anchor](".operator-logicals")
[block-ref](operator-logicals)  

[anchor](".operator-bitwises")
[block-ref](operator-bitwises)  

[anchor](".operator-arrays")
[block-ref](operator-arrays)



```block:operator-others
||(其他运算符)
| 算符      | 意义      | 备注                  |
| =         | 赋值      |                       |
| +=        | 自增      |                       |
| -=        | 自减      |                       |
| \*=       | 自乘      |                       |
| /=        | 自右除    |                       |
| \\=       | 自左除    |                       |
| ^=        | 自乘方    |                       |
| &=        | 自位与    |                       |
| [block-ref](sd)= | 自位或   |                 |
| <<=       | 自左移    |                       |
| >>=       | 自右移    |                       |
| \*\*      | 函数复合  | 注意不要和(^)混淆     |
| ,         | 逗号      | 函数传参等            |
| ()        | 优先求值  |                       |
```

其他运算符还包括：
[block-ref](operator-others)

其他特殊运算符
* [link]("?help_script_Programming_I.qmark_operator",问号运算符)，用于条件表达式，如下所示：
```ewsl
?(cond,expr1,expr2)
```
**说明：**当`cond`为`true`时返回`expr1`，否则返回`expr2`。

* [link]("?help_script_Programming_I.branch",逻辑条件分支运算符)
```ewsl
judge(x,y)
{
    cond(x<y)  => print("x<y");
    cond(x==y) => print("x==y");
    cond(x>y)  => print("x>y");
    default    => print("impossible");
}
```


算符遵循优先级规则：
```block:operator-level
||(对象优先级列表)
| 优先级    | 算符          |
| 16        | ++ -- \~ !    |
| 14        | ^ .^          |
| 13        | .\* ./ .\\ \* / \\      |
| 12        | %             |
| 10        | + -           |
|  9        | &             |
|  7        | [block-ref](sd) << >> |
|  6        | :             |
|  5        | > < >= <= == != ===   |
|  4        | &&            |
|  3        | ^^            |
|  2        | [block-ref](dd) \*\*  |
|  1        | ,             |
|  0        | = += -= \*= /= \\= [block-ref](sd)= ^=    |
```

[block-ref](operator-level)

**注意：**其中括号算符作为优先求值的用途，其优先级实际上比上述列表中的所有算符都高，可以用来调整表达式的解析次序。

[anchor](".statement")
## 语句


[anchor](".control_structure")
## 控制结构
过程式编程的基本程序结构是三类控制结构：顺序结构、分支结构和循环结构。使用控制结构来实现对过程内变量和全局变量或者系统行为的操作。

[anchor](".sequence")
### 顺序结构
所谓顺序结构就是一系列普通语句构成的语句序列，依照语句出现的先后顺序运行。下面是一个顺序式结构的例子：

```ewsl
a = 10;
b = 20;
println("a+b=",a+b);
```
有些语句的顺序可以改变而不影响程序运行的效果，但是更多的时候改变语句顺序会导致程序运行结果变化，更加严重的是出现程序运行错误（如变量没有赋值之类的情况）。  

**建议：**
* 避免书写过长的程序，一段子程序（或者函数、语句块）如果显著超过一个屏幕能一次容纳的行数（大约40行-60行），会使得理解程序的效率大幅度降低。
* 子程序内容过长时，可以使用语句块将顺序结构中的部分内容提炼出来，并且通过定义语句块内的局部变量尽量减少整个子程序上下文共享的变量。
* 谨慎使用全局变量。
* 谨慎调用系统资源（比如调用一些具有复杂行为的系统API），如果调用它，尽量将其控制在一个较小的局部过程环境中。
* 输入输出行为（IO）的次序不能随意打乱。
* 在顺序结构中涉及到的条件分支的情况下，修改程序的顺序结构时要注意判断的结果是否会影响条件。

[anchor](".branch")
### 分支结构
分支结构是实现子程序功能局部跳转的重要方法。


[anchor](".if_else")
* if-else分支
`if(...){...}else{...}`语法规则如下：
```ewsl
if(condition)
{
    <then-block>
}else
{
    <else-block>
}
```

```block:then-block
`<then-block>`
```

```block:else-block
`<else-block>`
```

其中`condition`是布尔值，如果为真（`true`）则跳转到[block-ref](then-block)执行内部的语句块，否则跳转到[block-ref](else-block)区块执行。  

使用多层`if-else`嵌套时：
```ewsl
if(cond1)
{
    <branch-1>
}else if(cond2)
{
    <branch-2>
}else if(cond3)
{
    <branch-3>
}else
{
    <branch-others>
}
```

**建议：**
* 建议不要使用复杂嵌套的`if-else`结构，可能使程序员难以理解。
* 平行分支判断的时候，如果选择分支超过4条建议使用`switch-case`或者`judge-cond`分支。
* 条件语句（`condition`）引入具有复杂外部行为（如赋值、调用外部过程）时必须非常谨慎小心，特别是使用`&&`和`||`运算符的时候要注意可能的短路逻辑问题。

[anchor](".short_circuit_logic")
> **短路逻辑**   
  使用逻辑运算符的时候，为了提高计算效率，当第一个项被求值并且已经决定该逻辑运算符计算结果的时候，另一个项的求值过程会被忽略的情况。例如：`x = 0; y==1; (x >= 0 || (++y)==1`中的`y`的自加过程将被忽略掉。


[anchor](".qmark_operator")
* 问号表达式（三目运算符）
问号表达式是一个类似函数形式的表达式，用法如下：
```ewsl
x = ?(x%2==0, x/2, x*3+1)
```
例子表达的意思是：“如果`x`是偶数则将自己减半，如果是奇数则将自己乘以3再加上1”（有一个数学猜想是关于这个表达式，是否对于任何自然数都能陷入到`...,4,2,1,4,2,1,...`的循环）。  

**建议**：
* 不要在三目表达式中引入过于复杂的计算过程。

[anchor](".switch_case")
* `switch-case`分支
`switch-case`分支用于平行条件分支选择：
```ewsl
switch(var)
{
    case(const-val1): <stmt1>
    case(const-val2): <stmt2>
    ...
    default:<stmt_default>
}
```

```block:stmt1
`<stmt1>`
```

```block:stmt2
`<stmt2>`
```

```block:stmt_default
`<stmt_default>`
```

当变量`var`的取值等于`const-val1`时，运行语句[block-ref](stmt1)；当`var`取值等于`const-val2`的时候，运行语句[block-ref](stmt2)，否则调用默认行为[block-ref](stmt_default)。  

`switch-case`分支语句要求`case`关键词后的表达式必须是普通常量，所谓普通常量是指直接的布尔值（`true`和`false`两个关键词）、整数、浮点数和字符串常量三种情况。复数、数组类型、变量是不可以作为`case`关键词后的表达式的。通常情况下我们建议仅仅使用整数和字符串两种条件下使用switch-case语句。  

**注意**：`switch-case`分支语句的分支之间完全隔离，不需要使用`break`关键词跳出，这一点与C语言是完全不同的。

[anchor](".judge_cond")
* `judge-cond`分支
`judge-cond`分支用于解决那些需要复杂条件判断，但是不适合使用多层`if-else`也无法使用`switch-case`分支的情况。其语法规定如下：
```ewsl
judge(var1,var2,...) // var1, var2, ...可以省略
{
    cond(pred1) => <stmt1>
    cond(pred2) => <stmt2>
    default     => <stmt_default>
}
```

当条件`pred1`为真的时候，调用[block-ref](stmt1)语句；当条件`pred2`为真的时候，调用[block-ref](stmt2)语句；如果都不匹配，则调用默认的[block-ref](stmt_default)。  

**注意**：`judge-cond`分支语句和`switch-case`类似，也不需要使用`break`关键词跳出，这一点与C语言不通。


[anchor](".loop")
### 循环结构
循环结构是一种重复运行一段语句块的程序控制方式。EWSL支持for循环、条件循环方式定义循环结构程序。


[anchor](".for_loop")
#### `for`循环
for循环对指定语句块进行循环执行，条件不满足时退出循环。计数器式的for循环最为经典：
```ewsl
for(local i=0; i<10; ++i)
{
    for(local j=0;j<i+1;++j)
    {
        print("*");
    }
    print("\n");
}
```

打印的效果如下：
```
*
**
***
****
*****
******
*******
********
*********
**********
```

> `for`循环常用语数组、变量表的处理。


#### `for_each`基于键值对的循环
遍历变量表时，使用`for_each`会比普通的`for`循环更加方便：
```ewsl
t = table{
    x:1;
    y:2;
    z:3;
    u:4;
    v:5;
    w:6;
};

for_each(k,v in t)
{
    print(k,":",v,"\n");
}
```

`for_each`后的括号中，`k`（可以是任何有效符号名）表示键（key），而`v`表示该变量表中与键值相对应的项目值，即形成了

打印的效果如下：
```
x:1
y:2
z:3
u:4
v:5
w:6
```

**说明：**`for_each`中`k,`可以省略，遍历时只抓取元素的数值`v`。


[anchor](".conditional_loop")
#### while条件循环
使用while条件循环有两种方式，一种是前置条件模式，一种是后置条件模式`do-while`：

* 前置条件：当`cond`条件满足时循环，否则退出，且进入循环前判断一次。
```ewsl
while(cond)
{
    <loop-stmt>
}
```

* 后置条件：当`cond`条件满足时继续下一次循环，否则退出，无论是否满足条件都至少运行循环体一次。
```ewsl
do
{
    <loop-stmt>
}while(cond)
```

> while循环体中用`break`语句可以跳出循环。


[anchor](".function")
## 函数
EWSL允许用户使用和定义函数。

### 函数调用
函数调用使用小括号`()`，括号中的是函数的传入参数。例如，我们可以调用数学库中的`linspace`函数和三角函数`math.cosd`、`math.sind`，这三个函数可以在全局名字空间直接使用，而不需要带上库名`math`作为前缀：
```ewsl
ang = linspace(0,360,37); // 创建角度列表[0,10,20,...360]一共37个角度，均匀分布
pos = [];
for(i=0; i<37; ++i)
{
    pos[i] = table{x:cosd(ang[i]);y:sind(ang[i])};
	print("pos[", i, "]: ", pos[i].x, ", ", pos[i].y, "\n"); // 打印二维坐标点
}
```
上面一段程序生成了单位圆上37个等角度均分点（其中0度和360重合）的二维坐标。打印结果如下：
```
pos[0]: 1, 0
pos[1]: 0.984808, 0.173648
pos[2]: 0.939693, 0.34202
pos[3]: 0.866025, 0.5
pos[4]: 0.766044, 0.642788
pos[5]: 0.642788, 0.766044
pos[6]: 0.5, 0.866025
pos[7]: 0.34202, 0.939693
pos[8]: 0.173648, 0.984808
pos[9]: 0, 1
pos[10]: -0.173648, 0.984808
pos[11]: -0.34202, 0.939693
pos[12]: -0.5, 0.866025
pos[13]: -0.642788, 0.766044
pos[14]: -0.766044, 0.642788
pos[15]: -0.866025, 0.5
pos[16]: -0.939693, 0.34202
pos[17]: -0.984808, 0.173648
pos[18]: -1, 0
pos[19]: -0.984808, -0.173648
pos[20]: -0.939693, -0.34202
pos[21]: -0.866025, -0.5
pos[22]: -0.766044, -0.642788
pos[23]: -0.642788, -0.766044
pos[24]: -0.5, -0.866025
pos[25]: -0.34202, -0.939693
pos[26]: -0.173648, -0.984808
pos[27]: 0, -1
pos[28]: 0.173648, -0.984808
pos[29]: 0.34202, -0.939693
pos[30]: 0.5, -0.866025
pos[31]: 0.642788, -0.766044
pos[32]: 0.766044, -0.642788
pos[33]: 0.866025, -0.5
pos[34]: 0.939693, -0.34202
pos[35]: 0.984808, -0.173648
pos[36]: 1, 0
```

> 提示：可以尝试使用弧度制和弧度三角函数`sin`、`cos`编写一个类似的程序，看看结果有什么差别。

### 函数的定义
EWSL允许程序员在代码中直接定义函数。  
* 直接定义函数，使用`def`或者`function`关键词
> `def`关键词和`function`关键词是等价互换的
* 使用`@`替换`function`或者`def`关键词产生相同的效果，更加适合简短的匿名函数定义。
> `@(x){return x+1;}`与`function(x){return x+1;}`是等价的。

```ewsl
function f(x,y)
{
    return sqrt(x^2+y^2);
}
```
上述代码定义了一个计算二维坐标`(x,y)`距离原点`(0,0)`的欧式距离$r=\sqrt{x^2+y^2}$的函数。  


* 函数像值一样可以被复制给一个变量，也可以在变量直接“复制”
```ewsl
local myfunc = function(x,sigma)
{
    return exp(-(x/sigma)^2);
}
local myfunc1 = myfunc;
```
上述代码定义了一个计算标准高斯分布$f(x,\sigma)=\exp(-(\frac{x}{\sigma})^2)$的函数，并且将其当作值赋值给了变量`myfunc`；然后这个函数作为值又拷贝给了`myfunc1`。

> 函数的拷贝并没有制作一份内存上的副本，而仅仅是通过一个引用关系共享一个函数实体。在例子中`myfunc`和`myfunc1`所指的函数实际上在内存里是同一份。


**扩展阅读：**
* 关于函数式编程，请阅读[link]("?help_script_Programming_II.functional_programming","函数式编程")相关内容。
* 内置函数清阅读[link]("?help_script_Specifications",函数说明)相关内容。

[anchor](".string")
## 字符串处理
查看关于[link]("?help_script_Types.string",字符串类型)的帮助信息。

* 字符串的基本定义方法
在EWSL中直接定义字符串的方法是使用双引号`"..."`或者单引号`'...'`将字符串的内容包含起来进行表示。在这种经典定义中，需要使用一些转义字符串来定义那些特殊的符号，例如用`\t`表示制表位等，具体的包括了：

```block:escape_characters
||(转义字符,cll)
| 转义字符      |(c) 意义       |(c) 备注                   |
| \r            | 回车          |                           |
| \n            | 换行          |                           |
| \t            | 制表位        |                           |
| \f            | 换页符号      |                           |
| \b            | 退格          |                           |
| \s            | 不可见空白    |                           |
| \\\\          | 反斜杠(\\)    |                           |
| \'            | 单引号        | 双引号字符串中可以不转义  |
| \"            | 双引号        | 单引号字符串中可以不转义  |
```
[block-ref]("escape_characters")

* 多行字符串和免转义特性
> 使用经典方式定义字符串不适合书写源代码的附加文档、内嵌程序字符串，因为这些内容里包含需要过多的转义字符，并且往往需要多行才能够把内容表达完整。

使用连续三个单引号(\`\`\`)或者连续三个双引号(""")作为多行字符串的开头，同样的连续字符作为配对的结束即可表达多行免转义字符穿。免转义是绝对的，因此如果在这种多行字符串块中要使用连续单引号或者连续双引号时是不行的，如果需要在内容中书写连续单引好，则使用连续双引号作为字符串标识符（定界符）；反之，则使用连续单引号作为字符串标识符。

* 字符和子串的索引
使用`[]`算符可以获取字符串的指定位置的字符或者子串，例如：
```ewsl
a = "abcdefgh";
b = a[2:4];     // b == "cde"
c = a[end];     // c == "h"
```
字符串可以像数组一样使用子串的左值引用，即子串赋值，例如：
```ewsl
a = "abcdefgh";
a[[1,3,5]] = "123"; // change a to "a1c2e3gh"
```

* 字符串的连接
使用`..`运算符作为字符串的连接，该算符将字符串按照从左到右的次序连接起来，对于其他非字符串类型则先尝试转换为字符串后再连接起来。例如：
```ewsl
a = [];
for(local i=0; i<10; ++i)
{
    a.push("x_"..i.." = "..(i^2)..";");
}
```
上面的程序构造了10个赋值语句的字面字符串（诸如`"x_0 = 0;"`或者`x_5 = 25;`）。



[anchor](".compilation_and_interpretation")
## 程序的编译和解释




[anchor](".module")
## 模块的定义和使用



