var mu_home={file:'./data/help.htm',name : 'help',body : 'EastWave 7 文档 了解 EastWave 7 如何帮助你进行电磁波/光电系统数值仿真。其中带有 参考 的章节，详细介绍了具体模块，属于深入了解部分。 了解如何安装和配置 EastWave 7 EastWave 7 概览 通过"快速入门"体验 EastWave 7 设置计算模式和参数 建立模型入门 设置激励源 设置监视器  设置网格 启动计算 结果和后处理 通过"参考指南"深入了解 用户界面 计算模式 几何元件 材料元件 激励源元件 监视器元件 求解器设置 数据后处理 高级用户进阶 EastWave 7 脚本语言 相关主题： 文档使用指引 ',title : 'EastWave 7 文档',flags : 0,children : [{file:'./data/help_props.htm',name : 'help_props',body : 'props 界面库 在 KMaker 的基础上，根据通用程度扩展出了三个层级的高级接口，用来简化窗口的定义，并对风格进行整体控制。 第一层级高级接口 第二层级高级接口 第三层级高级接口 接口  备注  km.new_container 创建新的控件容器，内部控件按 行 解析。 km.new_book  创建可切换页面，通常配合 combo_book 或 radiobox 使用 km.new_note  创建可切换标签页，内部控件使用 new_page 构造新页面 km.new_page  创建新的页面 km.new_fieldset 创建带标签的包围框 km.combo_book  创建绑定 book 控件的下拉框 km.combo_optdata 创建绑定 optdata 的下拉框  km.combo_readonly 创建绑定 optdata 的只读下拉框 km.expression  表达式控件 km.expression2  x,y 表达式控件 km.expression3  x,y,z 表达式控件 km.box  lo,hi 表达式控件 km.textctrl  单行文本控件 km.multitext  多行文本控件 km.button  按钮控件 km.dataview  数据组控件 km.radiobox  单选框控件 km.checkbox  复选框控件 km.filectrl  文件控件 km.colorctrl  颜色控件 km.spinctrl  滑动条控件 km.hline  水平分割线 km.vline  垂直分割线 ',title : 'props 界面库',flags : 0,children : [{file:'./data/help_props_demo.htm',name : 'help_props_demo',body : 'empty page ',title : 'props 实例',flags : 0,children : []}]},{file:'./data/help_overview.htm',name : 'help_overview',body : '概览 在“概览”中用户可以快速浏览 EastWave 7 电磁/光电软件各个重要模块的基本介绍，快速了解软件的基本算法、基本结构和基本功能等。 索引 1. 关于 EastWave 7 2. 关于 参数扫描寻优 3. 关于 计算模式 4. 关于 模型编辑器 5. 关于 求解器设置 6. 关于 求解器配置 7. 关于 结果与后处理 8. 关于 脚本语言 ',title : '概览',flags : 0,children : [{file:'./data/help_overview_about_ew7.htm',name : 'help_overview_about_ew7',body : '关于 EastWave 7 本章节给出了 EastWave 7 电磁/光电软件的概览： 软件概览  呈现了一个成熟的软件架构，在“软件概览”中用户可以快速浏览 EastWave 7 电磁/光电软件 的算法、界面、模块、核心设置、后处理功能、脚本语言等各内容，了解软件的基本算法、基本结构和基本功能。 仿真优势  对EastWave电磁/光电软件的仿真性能优势做了分析。这些优势来源于软件所使用的核心算法、公司的算法技术创新 和软件基于一线工程应用的开发经验。 亮点概览  EastWave 7 光电/电磁仿真软件积累了大量的建模案例和计算模式使用案例， “亮点概览”筛选了一些软件的亮点功能案例和计算模式使用案例，供客户快速浏览。仿真优势具体包括： 电大快速计算优势 时域、角域、频域、极化域多维度仿真优势 跨系统平台高效并行优势 个性化计算模式亮点优势 基于元件创新概念的复杂重复结构亮点建模优势 材料优势：支持所有电磁光电材料 参数扫描与寻优功能优势 应用领域  EastWave 7 光电/电磁仿真软件在电磁、光电和相关课程教学中积累了大量的用户， “应用领域”罗列了电磁领域、光电领域软件应用的具体方向、软件达到的一些指标以及表现出的特色。 ',title : '关于 EastWave 7',flags : 0,children : [{file:'./data/help_overview_about_ew7_overview.htm',name : 'help_overview_about_ew7_overview',body : '欢迎使用 EastWave 7 EastWave 是中国首款商业化的跨平台（Windows 和 Linux）的三维全矢量光电/电磁波并行仿真软件，用于任意复杂结构和复杂材料的电磁波/光电系统数值仿真， 如电磁波系统（天线阵/雷达、天线罩、电磁隐身、电磁兼容、微波暗室、电磁环境、移动通讯等）和光电系统（如激光、LED、超构材料、光子晶体、光通讯器件等）。 EastWave 在电磁波/光电材料建模、电大系统或超大系统（近千倍波长体系）仿真和参数优化方面具有独特的优势， 可提供最优的设计方案和精确的数值结果，是工程设计、参数优化和科学研究的必备仿真工具。 核心算法 时域有限差分算法 EastWave 的算法核心是 时域有限差分（Finite Difference Time Domain，缩写 FDTD ） 算法，FDTD 原理详细请参考 FDTD 原理 。 FDTD 算法采用的离散网格如图。   相对于其他算法时域有限差分法的优点有： 计算量随网格线性增长，计算精度高； 任意复杂材料和复杂结构； 模拟瞬态效应； 多频/宽频段计算。 上海东峻经过10多年的算法研究，从节约计算量、高效软件并行、材料仿真研究、动态场分析、多频点/多角度仿真计算等方面最大限度地发掘算法优势， 取得一系列仿真计算的性能优势： 电大快速计算优势 ， “时域、角域、频域、极化域” 多维度仿真优势 ， 并行优势，材料优势 等。  上海东峻在多核并行资源分配、网格剖分算法、物体网格共形处理算法、网格调整算法等方面取得突破，开发了万核以上的超算并行计算能力， 在电大、超电大全波仿真计算方面独树一帜，开发了均匀网格剖分策略、非均匀网格剖分策略一、非均匀网格剖分策略二等智能网格剖分系统以及多种局域网格控制和调整技术， 在精确处理电大+电小结构的仿真问题上发挥重要作用。  物理光学算法 同时，软件中加了 物理光学（Physics Optics，缩写PO） 算法，用户可建立仿真项目工程选择 PO 法，FDTD+PO 联合方法快速计算辐射、反射和散射等电磁问题。   软件界面 EastWave 具有成熟的人机交互界面，软件每一个前处理功能、仿真计算控制功能和后处理功能都有相应的交互窗口、子窗口、控件等， 软件的核心界面包括：计算模式选择界面，用户界面（工作界面）和后处理界面。  在计算模式窗口中，工程师根据应用方向，选择对应的计算模式，如图。 计算模式是针对天线阵、天线罩、雷达散射截面等专业仿真问题，给出的一个仿真工程智能解决方案， 该方案减少了软件使用者对算法知识、专业背景知识以及对软件功能和流程理解的依赖。详情请见 个性化“计算模式”亮点优势” 。   在用户界面中，用户可以通过菜单栏、工具栏、工作空间、工程管理窗口、显示窗口、消息框口以及变量窗口完成模型建立、查看、修改，变量定义， 激励源设置，网格设置、剖分和查看，计算启动、监控等功能，如图。   后处理界面显示仿真结果和数据，后处理界面还提供图形和数据的处理功能，可以对图形进行操作、修改、保存和导出数据。 同时，用户可以根据需求在后处理界面中使用EastWave脚本语言对数据进行进一步的处理，如图。   软件模块 软件模块提供了物体建模功能、材料建模功能、激励源设置功能、监视器设置功能等。通过软件模块，用户可以模拟“天线阵”、“天线罩”等工作、测量的真实环境。 建模模块中包含XXXX、“曲面频选快速建模”、XXXX等亮点功能，如图。  材料模块几乎支持所有电磁光电材料的建模，如图。  激励源设置功能，除了“集总端口”、“波导端口”、等常规端口设置以外，还支持导入场功能，方便与其它仿真结果或其它软件的场数据交互，实现联合仿真，如图。  记录器模块提供丰富的时域/频域点记录器、截面场记录器、准近场记录器、远场记录器，记录用户需求的各种数据，如图。   核心设置 软件核心设置包括单位、背景材料、频率等常用设置，边界设置，网格设置，精度收敛设置，工作平面设置，坐标变换等。 常用设置 单位 背景材料 频率 边界设置 网格设置  EastWave 电磁仿真软件提供了均匀网格剖分策略、非均匀网格剖分策略一、非均匀网格剖分策略二等智能网格剖分系统以及多种局域网格控制和调整技术， 在精确处理电大+电小结构的仿真问题上发挥重要作用。 精度设置 工作平面设置 坐标变换设置 后处理界面功能 软件的后处理界面包含丰富的功能，主要有： 数据处理功能：数据的导入、导出、寻找最大最小值，脚本语言处理等； 图像绘制和处理功能：曲线绘图、曲面绘图、图形的复制、黏贴、保存、注释等；  智能数据功能：集数据和数据处理于一体，可增加数据的完整性，减少数据存储空间。  实时场观察器 实时场观察器用于用户在仿真过程中观察电磁场的动态演化过程，通过动态场分析理解辐射、反射、绕射等背后的物理机制， 从机理角度分析电磁现象的本质，如图。  脚本语言 软件的前处理脚本语言实现：软件可以实现脚本语言快速建模、复杂激励源设置和模式设置。软件的前处理采用XXXX语言，建立连接。  软件后处理支持脚本语言操作：实现对复杂数据，复杂参数的计算。后处理采用上海东峻开发的 EastWave 脚本语言，语言简单易学。  ',title : '软件概览',flags : 0,children : []},{file:'./data/help_overview_about_ew7_advance.htm',name : 'help_overview_about_ew7_advance',body : 'EastWave 7 仿真优势 仿真优势来源于软件所使用的核心算法、公司的算法技术创新和软件基于一线工程应用的开发经验。 仿真优势具体包括：  电大快速计算优势； 时域、角域、频域、极化域多维度仿真优势； 跨系统平台高效并行优势； 个性化计算模式亮点优势； 基于元件创新概念的复杂重复结构亮点建模优势； 材料优势：支持所有电磁光电材料； 参数扫描与寻优功能优势。 仿真性能核心优势 电大快速计算优势 电大或超大（千倍波长）体系、天线阵的单站雷达散射截面（RCS）精确计算一直都是国际难题，EastWaven通过长期研究算法，取得突破性进展， 实现了复杂材料的电大或超大（近千波长）体系和天线阵的 RCS 精确计算，不仅向航空、航天、船舶等研究所出售软件，也提供技术服务和解决方案， 目前做过的工程案例包括大型隐身舰船、隐身飞机（包括进出气口和主天线）、导弹、天线阵（结构散射和模式散射）、天线阵+天线罩、天线阵+飞机平台等系统的 RCS 特性。   基于此能力，EastWave 成为“有隐身要求的系统”（隐形飞机、舰船、雷达等）和“破解隐身”雷达的重要研发工具。更因为超一流的速度优势， EastWave 使大型和超大型体系隐身设计的多参数优化（如隐身飞机和舰船的形体参数）成为可能，为隐身的“自动化设计”提供强有力的支持。 另外，EastWave 还可通过 FDTD+PO 的混合算法，可较精确地计算“几千--万倍波长”的巨型体系 RCS 。   “时域、角域、频域、极化域”多维度仿真优势 “时域、角域、频域、极化域”等多维度、全矢量仿真一直是电磁兼容、电子对抗相关设计的急切需求，同时是各个软件面临的难题。 EastWave 通过长期研究算法，数据处理方法研究，取得突破性进展。实现快速频点扫描计算能力、多角度快速计算能力、数据复用能力等， 在大型天线阵、天线罩、天线阵+天线罩仿真计算，大型平台雷达散射截面仿真计算，以及雷达成像计算中发挥重要作用。   基于此能力，EastWave 成为“天线罩多频点，多角度透过率和 BSE ”、“相控天线阵扫频，扫角”、“飞机、舰船等体系多角度 RCS ”快速研发的得力帮手。 更因为超一流的速度优势和多维度的方针信息，EastWave 实现了雷达一维成像、二维成像的模式开发，可仿真计算大型体系的雷达成像特性。   跨系统平台高效并行优势 通过近万核并行测试，计算效率几乎线性增长，未见饱和效应。同时软件可以在 Windows 系统（个人电脑和工作站之间）和 Linuxs 系统（大型计算中心之间）进行数据交互。  可跨平台操作：在个人电脑上建模（Windows 系统），提交给大型计算中心（Linux 系统）计算，再把数据导回个人电脑分析。  个性化“计算模式”亮点优势 EastWave 电磁/光电仿真软件作为电磁仿真软件的后起之秀，它能否被业界普遍接受，取决软件能否快速被不同知识层次和不同专业背景的工程师、研究人员和学生接受。 为了减少软件使用对算法知识、专业背景知识以及对软件功能和流程理解的依赖，如图，上海东峻科技在EastWave电磁/光电仿真软件中推出“计算模式”概念。   计算模式是针对天线阵、天线罩、雷达散射截面等专业仿真问题，给出的一个仿真工程智能解决方案。该智能方案包含以下内涵： 提取核心工程“指标”和必要的模式控制参量，作为模式参数输入，模式参数设置在模式参数设置界面统一完成。  以 RCS（单站，快速扫角，电大体系）模式为例，该计算模式的工程指标有雷达频率和极化，单站 RCS 计算的角度范围，该模式的模式控制参量仅有“加速级别”一项。用户只需理解各个参量的含义，便可针对某一模型进行RCS仿真计算。 智能化打包激励源、记录器、后处理程序等核心模块的设置。  在 RCS（单站，快速扫角，电大体系）模式中，模式通过模式参量定义并生成需要的激励源、监视器和后处理程序。 EastWave 电磁/光电仿真软件的物体模块、激励源模块、监视器模块和后处理模块都可以参数化建模。这是模式功能能够成功开发的一个重要因素。 智能打包了上海东峻在某一专业方向丰富的仿真创新和经验。  RCS 的正确仿真需要大量的仿真经验积累，经过长时间的相关项目合作，上海东峻积累了丰富的物体RCS仿真经验， 这些经验储存在模式的算法隐式参量中，如时间步数、时间步长、智能网格大小等。 智能打包了上海东峻独创的加速算法、多频点计算技术等算法和技术创新。 在 RCS（单站，快速扫角，电大体系）模式中，软件加入了东峻独创的加速算法，该算法能够使计算模式一次计算一定范围内的单站 RCS ， 大大提高了 RCS（单站，快速扫角，电大体系）计算性能。 EastWave 电磁/光电仿真软件基于计算模式的仿真具有最简化的仿真步骤，分别是：选择计算模式，设置模式参数，建模和网格检查，启动计算和结果查看。 如图是 RCS（单站，快速扫角，电大体系）模式参数设置界面。    EastWave 电磁/光电仿真软件全功能版包含6个天线罩计算模式，2个天线阵计算模式，2个电磁兼容计算模式，3个 RCS 计算模式，雷达一维、二维成像计算模式， 天线阵和天线罩联合仿真计算模式等17个专业计算模式。   EastWave 电磁/光电仿真软件还给出了自定义计算模式，该模式适合于高级工程师、研究人员等软件高级用户，也适用于软件学习者和研究者。 其中，天线阵计算模式曾用来计算近万单元的阵列辐射性能，一系列天线罩计算模式在全波仿真大、中型天线罩、异形罩、频率选择表面天线罩中发挥巨大作用， RCS 计算模式可以用来计算大型舰船、飞机、复杂材料隐身结构、大型相控阵天线、飞机进气口等腔体体系的RCS。 随着研究的深入，上海东峻陆续推出一系列亮点计算模式，如雷达一维、二维成像模式、电磁兼容模式、天线阵天线罩联合仿真模式等。   光电仿真软件通过计算模式这一创新，减少了软件使用对算法知识、专业背景知识以及对软件功能和流程理解的依赖， 真正做到把软件的核心功能通过简单的操作交给不同层次的使用者。   EastWave 电磁/光电仿真软件模式的成功开发得益于上海东峻“项目服务+软件开发”的公司战略，大量的军工项目服务和科学项目服务为模式开发奠定了丰富的工程经验。 同时软件给模式开发提供了丰富的建模模块、成熟的UI界面和灵活的脚本语言功能。   软件不同版本所包含的计算模式种类不同，详情见 版本说明 。 基于“元件”创新概念的复杂重复结构亮点建模优势 现代电磁体系越来越复杂，而参数化建模、自动优化的需求有很普遍，所以，复杂结构的建模就是各个成熟软件面临的难题。 首先是“复杂单体结构”，例如一个复杂物体是由多个部分“经过旋转/平移后”拼接而成，那么如何快速建模、参数调整以及参数化控制是传统电磁软件普遍面临的难题。 更加复杂的阵列结构，例如“大型复合天线阵”、“曲面共形阵列”、“大型曲面的频选/超材料天线罩”、“暗室（多种锥形/劈形吸波材料铺设）”等复杂阵列体系也越来越多出现， 在仿真、优化中，对阵列所有单元或某些区域单元的某些结构进行修改、微调往往反复出现，如何高效地对复杂阵列的多种类型结构参数 （尺寸、晶格、形状、旋转角和平移等）进行统一（局部）修改、自动优化是传统电磁软件普遍难以解决的建模难题。 而如果阵列的背景是曲面（例如曲面共形阵或曲面频选），那么就需要“根据局域空间特征”进行“对应的特定修改”，这就更加困难了。   欧美传统电磁仿真软件基于物体和复制、坐标变换、布尔操作等功能的“树状”建模逻辑越来越难以应对复杂结构的建模和模型维护的需求。 针对此困难，东峻 EastWave 软件引入国际最新建模软件的经验，推出“元件”这一基本概念，形成“网状”建模逻辑， 使得各种复杂体系（例如图的暗室转台、共形天线、频选天线罩）的建模变得极其方便容易， 甚至可以自动完成（例如在曲面上自动铺设 FSS ），形成东峻软件建模能力的一大特色。     传统电磁软件只有“物体”的概念，它包含了多种信息，既有“结构信息”，也有“材料”和“具体的位置和方向”等信息。 而“元件”是现代建模软件经过长期演化而建立的一个抽象概念，具有极其丰富内涵： 它最基本的内涵就是某个物体的“结构（包括尺寸、形状等）信息”，软件可以通过“元件”这个概念，把“结构信息”抽离物体，并进行独立操作（改变）。 “元件”还包含了“共享参数”的概念，例如，我们可以用某个元件来建立阵列，那么阵列的所有物体（所有单元），都包含“共同的元件”，可以通过修改“元件”来统一修改所有物体的结构参数。 “元件”还包含了“嵌套重构”的概念，例如，我们可以把阵列的一部分选中，重新给它们定义一个“新元件”，那么我们就可以构建“阵中阵”。 “元件”还可以“组合”、“拆分”，构建极其复杂的个体结构（如超材料单元），再可用这些个体去构造阵列、嵌套阵列、曲面共形阵列等等。 基于元件丰富的内涵，EastWave 实现了“结构”、“材料”、“物体操作”的分离，把物体抽象为“材料”、“结构”、“物体的空间操作”以及“网格剖分属性”等 几个并列的、平等的、闭合的控制项。   实际上，传统电磁仿真软件的建模思路是“树状”（或“线状”）的，由于缺乏元件的概念，需要对建模路径上的每个物体进行操作，才能完成修改， 而元件内涵赋予了独特的 EastWave “超组合”的建模功能和建模思路，实际上是在复杂多参数空间构建了“联络网”，我们可以在众多“网络节点”上任意跳跃， 从而突破了传统的“线状”建模思维，构建“网络型”建模思路。   通过“元件”对物体建模是 Eastwave 建模的一大特色。EastWave 致力于电大、复杂体系的仿真，上海东峻基于“元件”开发的一系列建模功能， 这些功能可快速生成万单元以上共形天线阵、百万单元多种频率选择表面（超材料）构成的大型天线罩等复杂建模， 利用“多元件”建模可实现“多层嵌套阵”、“多种吸波材料的复杂结构暗室”、“天线罩+频选/超材料结构”等复杂“嵌套结构”的快建模、参数化建模等等功能。 材料优势：支持所有电磁光电材料 EastWave 内部采用具有严格物理意义的复杂物理模型，如 Drude 模型、洛伦兹模型和速率方程理论等， 不仅可以实现对金属材料、等离子体、色散材料、超构材料、铁磁性材料、非线性材料等各种“无源”（Passive）材料的仿真模拟， 同时还可以实现对增益材料、饱和吸收材料、自感透明材料、有源非线性材料等“有源”（Active）材料的建模仿真。 EastWave 建立的各种模型，严格遵守能量守恒和其他物理定律的限定，保证了非常好的数值稳定性。 EastWave 建模能力更强大的一点是：如果面对的是一种全新的材料，只要有实测的宽频色散曲线，EastWave 就可利用内部引擎进行色散自动拟合，然后自动建模， 进行稳定的 FDTD 计算。   基于此能力，东峻科技特别增强了 EastWave 对当前各种特殊新型材料的仿真模拟功能，全面支持光子晶体材料、负折射材料、隐形材料、增益材料的仿真模拟， 在隐身结构，隐身材料方面独居优势；基于此能力，EastWave 具有计算电磁兼容问题中的交调、互调效应，以及场路联合仿真中的非线性端口效应； 同时，在科学研究和相关教学方面具独特的领先优势。 参数扫描与寻优功能优势 多参量寻优”是工程界极其重要的一个问题，但是对欧美商业软件，电大体系电磁仿真的多参量寻优往往是不可能的，因为一次计算往往需要几天， 而寻优一般需反复计算几十次以上，总时间或以“月”记。EastWave 不但具有超强的电磁仿真速度优势，同时也开发了“混合寻优算法”， 即把“全局寻优”（如遗传算法）和“局域寻优”（如单纯型算法）结合，发挥不同寻优算法各自的优势（如“全局寻优”不会漏掉各个局域最优解、“局域寻优”收敛快）， 又躲避了不同寻优算法天生的缺陷（“全局寻优”后来收敛变慢，“局域寻优”容易陷入局域极小值而漏掉全局最优），往往几次就发现最优解。   基于此能力，EastWave 不仅解决了国际上“电大和超大体系”严格仿真的难题，还可以完成大体系的多参数自动寻优，软件将帮助设计人员发现最优解， 如30-500倍波长的隐形飞机或舰船、天线阵、天线阵+平台、天线布局、天线罩、天线罩+天线、暗室（电磁环境）的“多参量”优化计算等。 ',title : '仿真优势',flags : 0,children : []},{file:'./data/help_overview_about_ew7_shine.htm',name : 'help_overview_about_ew7_shine',body : 'EastWave 7 亮点 EastWave 光电/电磁仿真软件积累了大量的建模案例和计算模式使用案例，该部分筛选了一些 软件模块亮点 和 计算模式仿真案例亮点 。 其中亮点功能案例介绍了 EastWave 光电/电磁仿真软件在复杂电大+电小体系仿真中遇到的建模问题的解决方案，如大型天线阵建模、曲面频选铺设方案、 隐身结构隐身材料薄层建模，软件独有的元件建模功能。亮点仿真案例针对市场对电大、多矢量、高精度全波仿真的需求推出的仿真案例， 如百倍波长以上天线罩、天线阵、飞机/舰船隐身问题、平台电磁兼容问题的仿真。 EastWave 7 软件模块亮点 亮点功能模块案例筛选了 EastWave 光电/电磁仿真软件在复杂电大+电小体系仿真中遇到的建模问题的解决方案，包括： 阵列建模 ； 天线罩特殊建模 ； 薄层生长建模 ； 薄层网格修复 ； 频选/超材料建模 。 阵列建模 天线阵建模一直是天线阵仿真过程中耗费时间较多的过程，EastWave 针对大型周期阵列的建模、任意周期阵列（环形阵）以及不等副馈电阵列的建模给出了解决方案。 EastWave 天线阵建模方法有： 周期阵列建模  “周期阵列建模”功能可以快速生成单元按一定周期排列的线性阵列、矩形阵列或者平行六面体阵列，如图。   自定义阵列  “自定义阵列”可以灵活的生成各种形式分布的阵列。该功能允许用户直接输入单元位置坐标，或者从外部导入包含位置信息的文本文件， 或者以位置函数的形式和脚本语言的形式生成阵列，如图。    脚本语言阵列建模  EastWave 7 支持使用脚本语言进行前处理，使用脚本语言可方便建立共形阵列，如图。   天线罩特殊建模 EastWave 包含丰富的天线罩建模方式，本案例给出软件： 内置天线罩库建模方法  EastWave 根据常用天线罩外形线预内置了4种天线罩模型，分别为正切卵形，球形鼻锥，尖锥和幂次旋转体。 用户使用时只需输入模型所对应的外形线关键参数，即可快速生成天线罩模型。下面简要演示建立球形鼻锥天线罩。球形鼻锥设置对话框如图。   建立的球形鼻锥天线罩，如图。  旋转对称体天线罩建模方法  旋转对称体建模用于生成各种旋转对称的物体，通过外部导入的方式将生成的内形线和外形线做封闭连接，最后生成物体模型。 旋转对称体对话框、外形线和内形线数据如图。   旋转对称体建立的天线罩，如图。   参数多边形曲线柱天线罩建模方法  参数多边形曲线柱支持采用解析表达式的方式建立天线罩。参数多边形曲线柱设置对话框，如图。   多边形曲线柱建立的天线罩模型，如图。  薄层生长建模 EastWave 开发了基于导入模型界面的薄层物体建模技术。该技术支持导入无厚度的CAD“面”模型，直接以“面模型”的法向进行生长，并可一次生长多个材料的多个薄层， 薄层的厚度可以任意设定。建模前需要准备好天线罩外表面或内表面的 CAD 模型。该功能在多层天线罩建模、隐身涂层快速建模等建模过程中有重要应用。 多层物体设置对话框如图。   生成的多层天线罩纵切面，如图。  薄层网格修复 FDTD 使用正交网格系统，因此对曲面薄板或者倾斜薄板进行离散化时可能会出现网格破裂，如下图这种网格破裂将在计算曲面薄层介质、 曲面频选、倾斜薄板等薄层结构时导致较大误差。   为了解决这一问题，东峻开发了薄层局部网格调整技术，如下图。该技术保证常规网格精度下（1/20波长），软件对曲面薄层结构进行正确的网格划分， 保证仿真计算的准确度（该功能属于东峻保密技术，修复后的网格不做显示）。  频选/超材料建模 针对频率选择表面/超材料仿真需求，EastWave 电磁/光电软件开发了频选/超材料铺设技术。该技术将频选/超材料单元结构绑定到铺设载体（例如天线罩）上， 软件根据输入的基本铺设参数智能生成频选/超材料结构。该功能大大简化了曲面频选/超材料的建模过程。频选/超材料建模设置对话框如图。   频选天线罩建立的过程，如图。  EastWave 7 计算模式仿真案例亮点 计算模式是针对天线阵、天线罩、雷达散射截面等专业仿真问题，给出的一个仿真工程智能解决方案。软件把激励源设置、边界设置、记录器设置、 后处理等智能地打包到计算模式之中。软件还在计算模式中智能打包了上海东峻在某一专业方向丰富的仿真创新和仿真经验。 部分计算模式还智能打包了了上海东峻独创的加速算法。东峻针对市场对电大、多矢量、高精度全波仿真的需求推出了亮点仿真案例，包括： 千单元天线阵 RCS 仿真案例 ； 共形天线阵仿真案例 ； 曲面频选天线罩透波率仿真案例 ； 天线罩和天线阵联合仿真 ； 隐身材料涂层隐身结构 RCS 仿真案例 ； 大型馈电网络仿真案例 。 千单元天线阵 RCS 仿真案例 本案例使用 EastWave 的“ RCS 模式（单站，快速扫角，电大体系）”计算了多达2000单元贴片天线阵列的单站 RCS 。模型示意图如图。   介质板的介电常数2.2和介质层厚度是2.87mm，贴片和地板考虑为 PEC 。将边界设置完美匹配层，计算俯仰角从0度到50度的单站RCS。 案例还对比了阻抗匹配、失配下天线阵列的 RCS ，如图。  共形天线阵仿真案例 本案例使用“自定义模式”建模并计算锥台共形天线阵列的方向图 。锥台共形天线阵模型如图。   三维远场方向图如图。   曲面频选天线罩透波率仿真案例 本案例使用“天线罩（功率传输系数，快速扫角，相扫）”模式计算频选天线罩的功率传输系数（简称“透波率”）。 天线罩透波率定义为发射天线加罩前后在发射方向上的远场辐射能量比值。   如图，天线罩介电常数3.2，电损耗角正切0.005，天线罩厚度10mm，天线罩尺寸为346mm 346mm 200mm，天线罩外表面覆盖一层频率选择表面， 频率选择表面为带阻型频率选择表面，计算7GHz处天线罩在0～60度内的透波率。   透波率结果如图。   远场方向图如图。   天线罩和天线阵联合仿真 本案例使用“阵罩联合仿真（功率传输系数，快速扫角，相扫）”模式计算贴片天线阵和正切卵形天线罩联合仿真问题，主要计算目标为透波率。 该模式可计算相控天线阵在指定频率下，不同扫描角度的方向图及相关结果，可一次完成多个角度的扫描计算。模型图如图。   阵罩联合仿真（功率传输系数，快速扫角，相扫）设置对话框如图。   天线阵和天线罩联合仿真实时场，如图。   透波率角度响应如图。  隐身材料涂层隐身结构 RCS 仿真案例 RCS 是雷达散射截面的简称，是根据入射波强度归一化后的散射波强度大小，用来表征散射体对不同入射波情况的散射能力。 单站RCS 指的是，入射波的发射与反射波的接收是由同一位置的雷达站完成的情况下散射物体表现出的散射能力。由于目前大多数雷达是独立工作的， 所以单站 RCS 计算最为普遍。由于不同角度的入射波一般处理起来需要不同的边界条件，所以全波方法一般难计算连续角度分布的单站 RCS 问题。   EastWave 解决了这一难题，使一次计算连续角度分布的单站 RCS 结果变的异常高效和简便。同时，本案例采用的隐身材料涂层厚度仅为0.4mm，约为λ/83， 需要非常精细的网格才能计算，计算量巨大。EastWave 独创的超薄介质功能，采用等效介质层的方法克服了这一困难，能够在普通网格下计算这一模型， 大大减少了计算量。球锥标准件为 PEC（完美电导体）材料，X方向尺寸为690mm，Y方向尺寸为150mm，Z方向尺寸为150mm，如图。   隐身材料涂层采用有耗材料，贴覆在球锥标准件表面，厚度为0.4mm，如图。   计算结果，如图。   大型馈电网络仿真案例 本案例针对大型功分器难以全波计算的问题，发挥 EastWave 电大体系仿真优势，使用“自定义模式”计算1x64端口功分器的输入端口的S11和输出端口的传输系数。 本案例计算过程采用了120核心的超算进行并行计算，案例对并行计算做了简单介绍。   单节功分器如图。   64功分器如图。   计算得到的反射系数和传输系数如图。   不同端口的传输系数如图。  ',title : '亮点概览',flags : 0,children : []},{file:'./data/help_overview_about_ew7_field.htm',name : 'help_overview_about_ew7_field',body : 'EastWave 7 应用领域 电磁领域 name value n1 v1 n2 v2 v3 光电领域 在科研领域，针对目前电磁学和光学领域最新的科研进展和研究热点，东峻科技特别增强了 EastWave 对当前各种特殊新型材料的仿真模拟功能， 全面支持光子晶体材料、负折射材料、隐形材料、增益材料的仿真模拟，在科学研究和教学方面具独特的领先优势，详细请见下表。 name value n1 v1 n2 name value n1 v1 n2 v2 v3 v3 电磁波理论、光学教学辅助 EastWave 可模拟传统光电/电磁/红外/微波等领域中的光纤、光栅、光阑、透镜、全反射等几乎所有的光/电磁现象， 展示其建立过程、本征模式和共振频率等，揭示复杂系统的内在物理机制和规律。 ',title : '应用领域',flags : 0,children : []}]},{file:'./data/help_overview_about_opt.htm',name : 'help_overview_about_opt',body : '关于 参数扫描和寻优 EastWave支持局部优化（单纯型）和混合优化（全局+单纯型），结合 EastWave 电大体系计算优势和针对特定工程问题的快速算法，可实现快速参数寻优。   “多参量寻优”是工程界极其重要的一个问题，但是对欧美商业软件，电大体系电磁仿真的多参量寻优往往是不可能的。 因为一次计算往往需要几天，而寻优一般需反复计算几十次以上，总时间或以“月”记。EastWave 不但具有超强的电磁仿真速度优势， 同时也开发了“混合寻优算法”，即把“全局寻优”（如遗传算法）和“局域寻优”（如单纯型算法）结合，发挥不同寻优算法各自的优势 （如“全局寻优”不会漏掉各个局域最优解、“局域寻优”收敛快），又躲避了不同寻优算法天生的缺陷（“全局寻优”后来收敛变慢，“局域寻优”容易陷入局域极小值而漏掉全局最优），往往几次就发现最优解。 参数扫描 EastWave 参数扫描功能可对自定义变量表中的一个或多个“常规变量“进行扫描计算。  关于参数扫描详细介绍，请参看 仿真分析 参考 &gt; 参数扫描和寻优 &gt; 参数扫描 。 参数寻优 EastWave 参数寻优功能可对自定义变量表中的一个或多个“常规变量“进行优化分析，最终得到满足条件的变量值。  关于参数寻优详细介绍，请参看 仿真分析 参考 &gt; 参数扫描和寻优 &gt; 参数寻优 。 ',title : '关于 参数扫描寻优',flags : 0,children : []},{file:'./data/help_overview_about_workmode.htm',name : 'help_overview_about_workmode',body : '关于 计算模式 计算模式是针对天线阵、天线罩、雷达散射截面等专业仿真问题，给出的一个仿真工程智能解决方案。主要内涵，请参看 关于 EastWave 7 &gt; 仿真优势 &gt; 个性化“计算模式”亮点优势 。 计算模式省去了设置激励源、记录器和边界条件等步骤，计算完成后直接给出核心结果。因此计算模式仿真具有最简化流程，分别是： 选择计算模式 设置模式参数 建模和网格检查 启动计算和结果查看 计算模式的完全介绍，请参看 计算模式 参考指南 。 &nbsp;&nbsp;创新点 光电仿真软件通过计算模式这一创新，减少了软件使用对算法知识、专业背景知识以及对软件功能和流程理解的依赖，真正做到把软件的核心功能通过简单的操作交给不同层次的使用者。 ',title : '关于 计算模式',flags : 0,children : []},{file:'./data/help_overview_about_model.htm',name : 'help_overview_about_model',body : '关于 模型编辑器 模型编辑器是 EastWave 7 为用户提供的建模工具。通过该工具，用户可以创建出各种元件： 几何元件 材料元件 激励源元件 监视器元件 坐标变换元件 元件： 简单的说，元件是一种抽象概念，它可以是物体的结构信息， 也可以是物体的材料信息或物体的坐标变换信息。不同的元件之间可以 组合 、 拆分 和 复用 。通过对 结构信息 、 材料信息 和 坐标变换信息（可选） 的组合， 我们就可以得到一个真正的物理元件（通俗的可以理解为“物体”）。 物理元件： 可以理解为“物体”，它是赋予了 材料属性 的 几何元件 。同时，物理元件也可以在坐标系中进行一系列的坐标变换。 模型编辑器的详细介绍，请参看 模型编辑器 参考指南 。 ',title : '关于 模型编辑器',flags : 0,children : []},{file:'./data/help_overview_about_solver.htm',name : 'help_overview_about_solver',body : '关于 求解器设置 求解器设置是 EastWave 7 仿真计算过程中用到的设置选项。 求解器设置包括： 常规设置 ： 单位 背景材料 频率 边界设置 ：在仿真不同类型电磁波问题时可能使用不同的边界条件，包括： 开放边界 周期边界 PEC 边界 PMC 边界 布洛赫边界 网格设置 ： 常规网格 均匀网格 非均匀网格 共性网格 强制网格 物体优先级设置 变量设置 ： 系统内置常量 系统内置变量 自定义常规变量 自定义数组变量 扫描优化参数变量 其它设置 ： 输出设置 精度设置 初始化电磁场 自定义脚本 采集位置点与测量 工作平面和坐标系 ',title : '关于 求解器设置',flags : 0,children : []},{file:'./data/help_overview_about_run.htm',name : 'help_overview_about_run',body : '关于 求解器配置 求解器配置是 EastWave 7 仿真计算用到的 具有附加性质 的配置选项。例如是否生成日志文件、日志文件目录配置等。 ',title : '关于 求解器配置',flags : 0,children : []},{file:'./data/help_overview_about_result.htm',name : 'help_overview_about_result',body : '关于 结果与后处理 当仿真计算执行完毕后，就进入到结果与后处理的阶段了。  后处理功能 数据处理功能 数据的导入、导出 寻找最大、最小值 脚本语言处理 图像绘制和处理功能 曲线绘图 曲面绘图 图形的复制、黏贴、保存、注释 智能数据功能 集数据和数据处理于一体 可增加数据的完整性 减少数据存储空间 通过 EastWave 脚本语言 ，用户可以方便地进一步处理 EastWave 仿真数据，获得需要的工程参数、图表等数据再加工信息。 有关结果与后处理的详细结果，请参看 仿真分析 参考 &gt; 结果与后处理 ',title : '关于 结果与后处理',flags : 0,children : []},{file:'./data/help_overview_about_script.htm',name : 'help_overview_about_script',body : 'empty page ',title : '关于 脚本语言',flags : 0,children : []}]},{file:'./data/help_install.htm',name : 'help_install',body : '1. 安装 EastWave 7 2. 配置许可证 3. 卸载 EastWave 7 ',title : '安装部署',flags : 0,children : [{file:'./data/help_install_install.htm',name : 'help_install_install',body : '安装 EastWave 7 EastWave 7 能够被安装在Microsoft Windows 2000/XP/Vista/Windows 7/Windows 8/Windows 10/Server 32-bit or 64-bit操作系统以及Redhat、SUSE等Linux操作系统上。 步骤 1: 确保计算机支持 EastWave 7 开始安装 EastWave 7 前：  查看 系统要求 ，这些要求有助于了解计算机是否支持 EastWave 7 。 确保没有其它应用程序正在安装。 重新启动计算机可确保挂起的任何安装或更新都不会影响 EastWave 7 安装。 步骤 2: 下载 EastWave 7 接下来，通过东峻官网下载 EastWave 7 安装程序文件 ，保存到计算机磁盘。 步骤 3: 运行 EastWave 7 安装程序文件 运行已下载的引导安装程序文件以安装 EastWave 7 ，用户可更改安装位置。 &nbsp;&nbsp;注意 EastWave 7 必须在管理员账户或拥有管理权限的账户下安装； 安装程序默认将 EastWave 7 安装在系统分区下（一般为C盘），如果您的磁盘含有非系统分区，出于权限考虑，建议将软件安装在非系统分区下。 步骤 4: 配置许可证 EastWave 7 安装完成后，打开桌面生成的 EastWave 7 快捷方式，进行许可证的配置。关于许可证，请参看 配置 EastWave 7 许可证 。 步骤 5: 开始进行仿真 一切都准备就绪后，用户可以通过 快速入门 ，迅速了解使用 EastWave 7。 获取支持 安装 EastWave 7 过程，难免会碰到各种问题，用户可以先自行查看 常见问题 ， 若依然无法解决问题，请 联系我们 。 ',title : '安装 EastWave 7 ',flags : 0,children : []},{file:'./data/help_install_license.htm',name : 'help_install_license',body : 'empty page ',title : '配置许可证',flags : 0,children : []},{file:'./data/help_install_uninstall.htm',name : 'help_install_uninstall',body : '卸载 EastWave 7 若要从计算机中彻底删除 EastWave 7 的所有安装内容，请使用“应用程序和功能”进行卸载。 打开“应用和功能”。例如，在 Windows 10 中，选择“开始”，然后在搜索栏中键入“应用和功能”。 查找 EastWave 7 。 单击“卸载” 。 进入安装目录，删除残余文件。 ',title : '卸载 EastWave 7 ',flags : 0,children : []}]},{file:'./data/help_quick.htm',name : 'help_quick',body : '快速入门 EastWave 7 的完整仿真流程分为两大类： 专业计算模式仿真； 自定义模式仿真。  本章节，以 RCS 计算模式 为例，旨在让用户能够快速熟悉计算模式仿真流程，入门 EastWave 7 。   关于 自定义模式仿真 ，请参看 完整实例 &gt; 自定义模式仿真 。 快速入门流程 完成 准备工作 ； 设置计算模式及参数 ； 建立模型 ； 设置网格 ； 启动计算 ； 查看计算结果及后处理 。 ',title : '快速入门',flags : 0,children : [{file:'./data/help_quick_prepare.htm',name : 'help_quick_prepare',body : '准备工作 在进行 RCS 计算模式仿真前，用户需要确保完成了以下准备工作： 安装 EastWave 7 。 配置许可证 。 ',title : '准备工作',flags : 0,children : []},{file:'./data/help_quick_step_1.htm',name : 'help_quick_step_1',body : '步骤 1:设置计算模式及参数 若对计算模式不了解，请参看 关于 EastWave 7 计算模式 。  首先需在模式设置对话框中根据问题的需要进行简单设置，主要是内置激励源和记录器的简单设置。   由主菜单选择 文件 &gt; 新建 &gt; FDTD向导 插入 FDTD 工程，选择合适的计算模式，如图。    点击“下一步”，在“计算模式”对话框中输入必要参数，主要用来设置内置激励源和记录器，如图。    点击“下一步”，显示计算模式参数设置报告，如图。   ',title : '步骤 1:设置计算模式及参数',flags : 0,children : []},{file:'./data/help_quick_step_2.htm',name : 'help_quick_step_2',body : '步骤 2:建立模型 若对模型编辑器不了解，请参看 关于 EastWave 7 模型编辑器 。  ',title : '步骤 2:建立模型',flags : 0,children : []},{file:'./data/help_quick_step_3.htm',name : 'help_quick_step_3',body : '步骤 3:设置网格 若对网格信息不了解，请参看 网格设置 。  ',title : '步骤 3:设置网格',flags : 0,children : []},{file:'./data/help_quick_step_4.htm',name : 'help_quick_step_4',body : '步骤 4:启动计算 若对启动计算不了解，请参看 关于 EastWave 7 求解器配置 。  ',title : '步骤 4:启动计算',flags : 0,children : []},{file:'./data/help_quick_step_5.htm',name : 'help_quick_step_5',body : '步骤 5:查看计算结果及后处理 若对后处理不了解，请参看 关于 EastWave 7 结果与后处理 。  ',title : '步骤 5:查看计算结果及后处理',flags : 0,children : []}]},{file:'./data/help_tutorial.htm',name : 'help_tutorial',body : '1. 新建计算模式 2. 物体操作 3. 组合元件 ',title : '操作指南',flags : 0,children : [{file:'./data/help_tutorial_new_project.htm',name : 'help_tutorial_new_project',body : 'empty page ',title : '新建计算模式',flags : 0,children : []},{file:'./data/help_tutorial_operate_item.htm',name : 'help_tutorial_operate_item',body : 'empty page ',title : '物体操作',flags : 0,children : []},{file:'./data/help_tutorial_comb_symbol.htm',name : 'help_tutorial_comb_symbol',body : 'empty page ',title : '组合元件',flags : 0,children : []}]},{file:'./data/help_case.htm',name : 'help_case',body : '1. 自定义模式仿真 2. 教学案例 3. 演示案例 ',title : '完整实例',flags : 0,children : [{file:'./data/help_case_custom.htm',name : 'help_case_custom',body : '自定义模式仿真 自定义模式可适用于普遍的电磁仿真问题，在该模式下，用户需手动设置激励源、记录器和边界条件。   关于 专业计算模式仿真 ，请参看 快速入门 。 本节以贴片天线为案例，简要介绍自定义仿真流程： 设置计算模式和参数 建立模型 设置激励源 设置记录器 设置网格 启动计算 查看结果及后处理 设置计算模式和参数 建立模型 设置激励源 设置记录器 设置网格 启动计算 查看结果及后处理 ',title : '自定义模式仿真',flags : 0,children : []},{file:'./data/help_case_teach.htm',name : 'help_case_teach',body : '1. 自动计算透反率模式教学案例 2. RCS模式教学案例 3. 天线阵模式教学案例 4. 天线罩模式教学案例 5. 电磁兼容模式教学案例 6. 雷达目标成像模式教学案例 7. 阵罩联合仿真模式教学案例 ',title : '教学案例',flags : 0,children : [{file:'./data/help_case_teach_TransRefl.htm',name : 'help_case_teach_TransRefl',body : '1. 平板透射反射率计算 2. 吸波材料透射反射率计算 ',title : '自动计算透反率模式教学案例',flags : 0,children : [{file:'./data/help_case_teach_TransRefl_Plane.htm',name : 'help_case_teach_TransRefl_Plane',body : '自动计算透反率模式教学案例 1. 概述 2. 设置计算模式及参数 3. 建模 4. 设置网格 5. 启动计算 6. 查看计算结果  1. 概述 本案例采用 EastWave 软件中“自动计算透反率模式”演示计算介质平板在正入射情况下的透射/反射率。 “自动计算透射反射率模式” 中内置激励源和记录器，用户仅需建模和简单设置即可，完成计算后会自动进行后处理，并给出透射/反射率的频率响应曲线。 案例模型示意：  介质平板的介电常数 $ varepsilon$ 为 $4.0$， z 方向厚度为 $500$ nm ,其他尺寸和材料详见下面参数说明。 本案例计算 z 正方向入射、平板在 $500 $~$ 1500 $ THz 频率范围内的透射/反射率。“ 自动计算透射反射率模式 ” 将在入射方向设置为开放边界，非入射方向设置为周期边界。因此平板在 x 、 y 方向无穷周期延拓，等效为无限大平板。 本案例仿真计算流程： 设置计算模式及参数 建模 设置网格 启动计算 查看计算结果。 2. 设置计算模式及参数 选择计算模式 由菜单选文件进入 “ 向导 ” 界面，选择 “ 自动计算透反率模式 ”。 注意 ：“ 自动计算透反率模式 ” 默认入射方向为开放边界，非入射方向为周期边界。 设置模式参数 设置单位； 设置频率； 设置方向； 设置文件名和存储路径 进入 “ 设置文件名和存储路径 ” 对话框，选择存储路径，输入文件名。 3. 建模 定义常用变量 为了方便参数调节和优化，建议将建模中用到的参数尽量在变量表中定义： 新建材料 新建材料可以通过如下几种操作方式：   直接点击工具条 “新建材料” 图标 点击 “模型菜单” 的 “新建材料” 选项 “工程管理窗口” 的 “新建材料” 选项 材料名设置为 dielec ，介质设置为简单的无色散电介质材料，介电常数 $ varepsilon$ 使用变量表中的 eps 。材料完成后工程管理目录树如图： 新建模型 采用 “ 立方体 ” 形状，新建平板结构，可以采用如下几种操作方式： 直接点击次模型工具条 “ 立方体 ” 图标 点击 “ 模型 ” 菜单，选择 “ 立方体 ” 点击 “ 模型窗口 ” 下的 “ 模型 ” ，选择 “ 添加元件 ”，结构选择 “ 新建立方体 ” 中心位置$（0，0，0）$，宽度$（perx， pery， thickness）$，“ 材料 ” 菜单中选择前面新建的材料 dielec ， 模型完成后界面如下： 4. 设置网格 使用 FDTD 方法仿真，一般要求网格的精度至少为关心频率对应波长的 1/15 以上，同时还要求网格能尽量识别模型的几何细节。一般情况下，默认选择“智能网格”， EastWave 会自动 根据用户设置的工程频率范围划分网格，用户可以简单选择不同的网格精度即可完成划分。 用户也可以自定义网格，可以控制每个维度的计算范围和网格数，并可以修改仿真时间 步长和总时间步长。 对于有特别精细结构（比如 1/100 波长以下）的模型，网格往往需要特别处理， EastWave 提供共形网格、非均匀网格、指定网格面、指定网格区域 等高级控制手段，详细请参看 EastWave 帮助手册网格设置部分，或咨询 EastWave 工程师。 设置网格精度 网格精度可以通过如下两种方式设置修改： “ 求解器 ” 菜单下的 “ 设置网格 ” “ 模型窗口 ” 计算模式下的 “ 网格 ” 设置的对话框如下： 选择 “ 均匀网格 ” 、“ 非共形网格 ” 进行计算。 注意 ：计算透反率时，一般要求激励源和记录器距离物体表面一个波长以上（接近远场），以减小物体附近倏逝波对记录器的影响。“ 自动计算透反率模式 ” 已自动将延拓距离 （计算区域边界和物体包围框的距离）设置为中心波长的两倍，并将激励源和记录器设置在靠近计算区域边界处，以满足上述要求。 网格剖分检查 网格精度设置完后，启动计算前可预览网格划分情况，点击图标可得： 5. 启动计算 点击工具条中的 “ 运行 ” 图标，开始计算。计算开始后，消息窗口给出提示/警告/报错信息，计算任务管理窗口给出计算进度并且可右键管理任务。 双击指定的计算任务或右键打开观察器以观察电磁波入射到物体上的实时变化情况。 消息窗口 计算开始和进行过程中，右下角的消息窗口显示出计算初始化的状态。 计算进度 在界面下方消息窗口中可以观察计算任务的完成情况。 观察实时场 点击观察实时场图标，可以观察电磁波的散射过程。 6. 查看计算结果 计算完成后，在 “ 工作空间 ” 生成 “ .ewd ” 结果文件。 透射/反射率结果图如下: ',title : '平板透射反射率计算',flags : 0,children : []},{file:'./data/help_case_teach_TransRefl_Absorb.htm',name : 'help_case_teach_TransRefl_Absorb',body : 'empty page ',title : '吸波材料透射反射率计算',flags : 0,children : []}]},{file:'./data/help_case_teach_RCS.htm',name : 'help_case_teach_RCS',body : '1. 单站RCS 2. 双站RCS ',title : 'RCS模式教学案例',flags : 0,children : [{file:'./data/help_case_teach_RCS_MonostaticRCS.htm',name : 'help_case_teach_RCS_MonostaticRCS',body : '1. 单站(贴片天线阵)RCS 2. 单站(X-47b)RCS ',title : '单站RCS',flags : 0,children : [{file:'./data/help_case_teach_RCS_MonostaticRCS_Patch.htm',name : 'help_case_teach_RCS_MonostaticRCS_Patch',body : 'RCS单站模式（贴片天线阵）教学案例 1. 概述 2. 设置计算模式及参数 3. 建模 4. 设置网格 5. 启动计算 6. 查看计算结果  1. 概述 本案例通过计算贴片天线阵的散射特性来演示如何使用 “ RCS （单站）计算模式 ”。该计算模式计算物体单站 RCS 的频率响应或者角度响应。计算模式根据输入参数（频率范围或扫描角度等），自动设置激励源和记录器，完成频率或者角度扫描， 并自动完成后处理给出 RCS 的频率/角度响应曲线。计算模式示意图： 此模式的一般仿真流程：设置基本参数（发射雷达的工作频率、入射角度范围、极化等，接受雷达频率和接受角度同发射雷达）$ rightarrow$ 建立散射体模型（ RCS 目标）$ rightarrow$ 计算，计算模式根据设定角度范围自动完成单站 RCS 角度扫描，得到每个角度下的 RCS 频率响应曲线$ rightarrow$ 分析结果。 若希望得到指定频点的单站 RCS 角度响应曲线，将扫描角度中 $ theta$ 或 $ phi$ 一个设置为单值、另一个设置为范围，得到的 RCS 角度响应曲线对应频率范围的中心 频点（也可将频率范围设置成单值）。 案例仿真流程如下： 设置计算模式及参数 建模 设置网格 启动计算 查看计算结果 2. 设置计算模式及参数 选择计算模式 由菜单选文件进入 “ 向导 ” 界面，选择 “ RCS （单站）模式 ”。 设置模式参数 计算频率范围 $ 2.25 $~$ 2.85$ GHz ，间隔 $0.1$ GHz 。 发射雷达 $ theta$ 角度范围为 $ 0^ circ $~$ 180^ circ $ ，$ phi$ 角度设置为 $ 0^ circ $，极化角度设置为 $ 0^ circ $。 注意 ：入射波的传播方向与雷达方向正好相反。 查看向导报告 “ RCS 模式 ” 默认长度单位设置为 mm , 时间单位设置成自动关联，频率单位设置为 GHz 。背景材料为空气， 其他参数是默认值，点击“完成”即可开始建模。 注意 ：“时间单位”默认和长度单位自动关联，高级用户可自己设置来控制 FDTD 仿真对应的真实时间尺度。 设置文件名和存储路径 进入 “ 设置文件名和存储路径 ” 对话框，选择存储路径，输入文件名。 3. 建模 定义常用变量 为了方便参数调节和优化，建议将建模中用到的参数尽量在变量表中定义： 新建材料 新建材料可以通过如下几种操作方式：   直接点击工具条 “新建材料” 图标 点击 “模型菜单” 的 “新建材料” 选项 “工程管理窗口” 的 “新建材料” 选项 材料名设置为 material ，介质设置为简单的无色散材料中的有耗材料， 介电常数 $ varepsilon$ 使用变量表中的 eps 。电损耗角正切为 $0.0027$， 颜色和透明度可以根据自己喜好选取。更多复杂材料的设置请参看 EastFDTD 帮助手册 “材料模块”。 材料设置如图： 材料完成后工程管理目录树如下： 新建模型 本案例通过“立方体”来演示如何建立模型，可以采用如下几种操作方式： 直接点击次模型工具条 “ 立方体 ” 图标 点击 “ 模型 ” 菜单，选择 “ 立方体 ” 点击 “ 工程管理窗口 ” 下的 “ 新建结构 ” ，选择类型 “ 立方体 ” 建立贴片天线金属地板 通过 “ 创建立方体 ” 建立贴片天线的地板，命名为 Ground 。 中心坐标为$（0，0，-gndh/2）$ ，宽度为$（gnda，gndb，gndh）$。 而后通过修饰，添加材料为 pec 。 建立贴片天线介质板 通过“立方体”建立贴片天线的介质板，命名 Mat 。 中心坐标为$（0，0，dich/2）$ ，宽度为$（dica，dicb，dich）$。 而后通过修饰，添加材料为 material 。 建立贴片天线金属贴片 通过“立方体”建立贴片天线的金属贴片，命名 Patch 。 中心坐标为$（0，0，dich+pahh/2）$ ，宽度为$（paha，pahb，pahh）$。 而后通过修饰，添加材料为 pec 。 建立贴片天线的馈线 通过“立方体”建立连通贴片天线的金属贴片和金属底板之间的馈线，命名为 Kuixian 。 中心坐标为$（0，0，dh/2-gndh/2 ）$ ，宽度为$（dp，dp，dh）$。 打包天线阵元 完成单个天线建模后，建议将组成天线的所有物体打包成组，以方便生成阵列。 按住键盘 “ Ctrl ” 键，鼠标依次单击选中以上四个元件，右键点击组合。并且修改组名称 为 “ Total_Structure ”，如下图： 创建完成的单个贴片天线模型图如下： 建立天线阵列 EastWave 中可直接将物体扩展成周期阵列。新建阵列模型可以通过如下方式： “ 工程管理窗口 ”下， 右键点击“ 模型 ”，选择 “ 添加 ” 下的“ 添加阵列 ”，选择类型为 DArrayExpr ， 在 x 、 y 方向把单一天线阵列扩展成 $7$ 行 $7$ 列的天线阵。如下图所示： 点击确定得到阵列： 4. 设置网格 使用 FDTD 方法仿真，一般要求网格的精度至少为关心频率对应波长的 1/15 以上，同时还要求网格能尽量识别模型的几何细节。一般情况下，默认选择“智能网格”， EastWave 会自动 根据用户设置的工程频率范围划分网格，用户可以简单选择不同的网格精度即可完成划分。 用户也可以自定义网格，可以控制每个维度的计算范围和网格数，并可以修改仿真时间 步长和总时间步长。 对于有特别精细结构（比如 1/100 波长以下）的模型，网格往往需要特别处理， EastWave 提供共形网格、非均匀网格、指定网格面、指定网格区域 等高级控制手段，详细请参看 EastWave 帮助手册网格设置部分，或咨询 EastWave 工程师。 设置网格精度 网格精度可以通过如下两种方式设置修改： “ 求解器 ” 菜单下的 “ 设置网格 ” “ 工程管理窗口 ” 计算模式下的 “ 网格 ” 设置的对话框如下： 选择 “ 非均匀网格 ” 、开启“ 共形网格 ”进行计算。 网格剖分检查 网格精度设置完后，启动计算前可预览网格划分情况，点击图标可得： 5. 启动计算 点击工具条中的 “ 运行 ” 图标，开始计算。计算开始后，消息窗口给出提示/警告/报错信息，计算任务管理窗口给出计算进度并且可右键管理任务。 双击指定的计算任务或右键打开观察器以观察电磁波入射到物体上的实时变化情况。 消息窗口 计算开始和进行过程中，右下角的消息窗口显示出计算初始化的状态。 计算进度 在界面下方消息窗口中可以观察计算任务的完成情况。 观察实时场 点击观察实时场图标，可以观察电磁波的散射过程。 6. 查看计算结果 计算完成后，在 “ 工作空间 ” 生成 “ .ewd ” 结果文件。 透射/反射率结果图如下: ',title : '单站(贴片天线阵)RCS',flags : 0,children : []},{file:'./data/help_case_teach_RCS_MonostaticRCS_X47-b.htm',name : 'help_case_teach_RCS_MonostaticRCS_X47-b',body : 'RCS单站模式（X-47b）教学案例 1. 概述 2. 设置计算模式及参数 3. 建模 4. 设置网格 5. 启动计算 6. 查看计算结果  1. 概述 本案例通过演示计算 X47-b 飞机的 RCS 来介绍如何使用 “ RCS （单站）” 计算模式。模型示意图： 隐形无人轰炸机 X47-b 采用了无尾翼的翼型机结构，大大降低了方位面上的散射截面，本案例 计算 X47-b 在方位面的单站 RCS 角度响应。使用 “ RCS （单站）” 计算模式，模式根据扫描角度自动 设置好激励源和记录器等必要设置，自动后处理直接给出 RCS 角度响应曲线。设置好扫描角等必要参数后， 仅需导入 CAD 模型，简单划分网格即可开始计算。 案例仿真流程如下： 设置计算模式及参数 建模 设置网格 启动计算 查看计算结果 2. 设置计算模式及参数 选择计算模式 由菜单选文件进入 “ 向导 ” 界面，选择 “ RCS（单站）模式 ”。 设置模式参数 频率设置为 0.3 GHz ，发射雷达 $ theta$ 角度设置为 $ 90^ circ $ ，$ phi$ 角度设置为$ 0^ circ $~$ 180^ circ $， 极化角度设置为$ 0^ circ $。 注意 ：入射波的传播方向与雷达方向正好相反。 查看向导报告 在 “ RCS （单站，快速扫角，电大体系）” 模式中长度单位和频率单位默认为 mm 和 GHz ， 网格设置默认为均匀网格、共性网格，边界设置是开放边界。 设置文件名和存储路径 进入 “ 设置文件名和存储路径 ” 对话框，选择存储路径，输入文件名。 3. 建模 新建模型 本案例通过 “ 文件 ” 菜单的 “ 导入 ” ，将 x47-b 的模型导入。如下图： 在 “ 模型窗口 ” 下选择 “ 模板 ” 右击选择构建元件，结构选择 “ x47-b ”， 材料选择 pec ，如下图： 模型完成后，模型界面如下： 4. 设置网格 使用 FDTD 方法仿真，一般要求网格的精度至少为关心频率对应波长的 1/15 以上，同时还要求网格能尽量识别模型的几何细节。一般情况下，默认选择 “ 智能网格 ” ， EastWave 会自动 根据用户设置的工程频率范围划分网格，用户可以简单选择不同的网格精度即可完成划分。 用户也可以自定义网格，可以控制每个维度的计算范围和网格数，并可以修改仿真时间 步长和总时间步长。 对于有特别精细结构（比如 1/100 波长以下）的模型，网格往往需要特别处理， EastWave 提供共形网格、非均匀网格、指定网格面、指定网格区域 等高级控制手段，详细请参看 EastWave 帮助手册网格设置部分，或咨询 EastWave 工程师。 设置网格精度 网格精度可以通过如下两种方式设置修改： “ 求解器 ” 菜单下的 “ 设置网格 ” “ 模型 ” 窗口的 “ 模板 ” 选择 “网格” 选项 设置的对话框如下： 选择 “ 均匀网格 ” 、开启“ 共形网格 ”进行计算。 网格划分要保证能识别模型的精细结构（比如一些影响物理性质的微结构），本案例模型较为简单，采用高级网格中的 “ 均匀网格 ”， 对于金属结构，建议开启 “ 共形网格 ”，即可在同样网格精度下获得更准确的计算结果。其他更详细的网格设置说明请参阅 EastWave 帮助手册的 “ 网格剖分、查阅 ” 模块，或是参看其他相关案例。 网格剖分检查 网格精度设置完后，启动计算前可预览网格划分情况，点击图标可得： 5. 启动计算 点击工具条中的 “ 运行 ” 图标，开始计算。计算开始后，消息窗口给出提示/警告/报错信息，计算任务管理窗口给出计算进度并且可右键管理任务。 双击指定的计算任务或右键打开观察器以观察电磁波入射到物体上的实时变化情况。 消息窗口 计算开始和进行过程中，右下角的消息窗口显示出计算初始化的状态。 计算进度 在界面下方消息窗口中可以观察计算任务的完成情况。 观察实时场 点击观察实时场图标，可以观察电磁波的散射过程。 6. 查看计算结果 计算完成后，在 “ 工作空间 ” 生成 “ .ewd ” 结果文件。 透射/反射率结果图如下: ',title : '单站(X-47b)RCS',flags : 0,children : []}]},{file:'./data/help_case_teach_RCS_BistaticRCS.htm',name : 'help_case_teach_RCS_BistaticRCS',body : 'RCS双站模式（介质包裹的金属球）教学案例 1. 概述 2. 设置计算模式及参数 3. 建模 4. 设置网格 5. 启动计算 6. 查看计算结果  1. 概述 本案例通过计算 “ 介质包裹的金属球 ” 的双站 RCS 角度来演示如何使用 “ RCS （双站）计算模式”。 该模式对给定频率范围内的每个频率点，计算物体在固定入射角下双站 RCS 随接受角度的变化。 该计算模式示意图如下： 结构图如下： 案例仿真流程如下： 设置计算模式及参数 建模 设置网格 启动计算 查看计算结果 2. 设置计算模式及参数 选择计算模式 由菜单选文件进入 “ 向导 ” 界面，选择 “ RCS （双站）模式 ”。 设置模式参数 计算频率范围 $1 $~$ 2$ GHz ，间隔 $0.1$ GHz 。 发射雷达 $ theta$ 角度设置为 $ 90^ circ $ ，$ phi$ 角度设置为 $ 0^ circ $，极化角度设置为 $ 0^ circ $。 接受雷达 $ theta$ 角度设置为 $ 0^ circ $ ，$ phi$ 角度范围设置为 $ 0^ circ $~$ 180^ circ $，极化角度设置为 $ 0^ circ $。 查看向导报告 “ RCS 模式 ” 默认长度单位设置为 mm , 时间单位设置成自动关联，频率单位设置为 GHz 。背景材料为空气， 其他参数是默认值，点击“完成”即可开始建模。 注意 ：“时间单位”默认和长度单位自动关联，高级用户可自己设置来控制 FDTD 仿真对应的真实时间尺度。 设置文件名和存储路径 进入 “ 设置文件名和存储路径 ” 对话框，选择存储路径，输入文件名。 3. 建模 定义常用变量 为了方便参数调节和优化，建议将建模中用到的参数尽量在变量表中定义： 新建材料 新建材料可以通过如下几种操作方式：   直接点击工具条 “ 新建材料 ” 图标 点击 “ 模型菜单 ” 的 “ 新建材料 ” 选项 “ 工程管理窗口 ” 的 “ 新建材料 ” 选项 材料名设置为 material_0 ，介质设置为简单的无色散材料中的有耗材料， 本案例需要使用无色散材料中的有耗材料，材料介电常数 $ varepsilon$ 使用变量表中的 Reps 。 电损耗角正切为 Ieps/Reps ，颜色和透明度可以根据自己喜好选取。更多复杂材料的设置请参看 EastFDTD 帮助手册 “ 材料模块 ”。 材料完成后工程管理目录树如下： 新建模型 本案例通过“ 球体 ”来演示如何建立模型，可以采用如下几种操作方式： 直接点击次模型工具条 “ 球体 ” 图标 点击 “ 模型 ” 菜单，选择 “ 球体 ” 点击 “ 工程管理窗口 ” 下的 “ 新建结构 ” ，选择类型 “ 球体 ” 新建介质球壳 通过 “ 创建球体 ” 建立介质球壳，而后通过修饰，添加材料为 material_0 。 新建金属球体 通过 “ 立方体 ” 建立贴片天线的介质板，命名 Mat ，而后通过修饰，添加材料为 pec 。 建立完成后模型窗口如下图所示： 4. 设置网格 使用 FDTD 方法仿真，一般要求网格的精度至少为关心频率对应波长的 1/15 以上，同时还要求网格能尽量识别模型的几何细节。一般情况下，默认选择 “ 智能网格 ”， EastWave 会自动 根据用户设置的工程频率范围划分网格，用户可以简单选择不同的网格精度即可完成划分。 用户也可以自定义网格，可以控制每个维度的计算范围和网格数，并可以修改仿真时间 步长和总时间步长。 对于有特别精细结构（比如 1/100 波长以下）的模型，网格往往需要特别处理， EastWave 提供共形网格、非均匀网格、指定网格面、指定网格区域 等高级控制手段，详细请参看 EastWave 帮助手册网格设置部分，或咨询 EastWave 工程师。 设置网格精度 网格精度可以通过如下两种方式设置修改： “ 求解器 ” 菜单下的 “ 设置网格 ” “ 工程管理窗口 ” 计算模式下的 “ 网格 ” 选择 “ 均匀网格 ” 、开启 “ 共形网格 ” 进行计算，设置的对话框如下： 该计算模式根据计算区域和物体自动生成频域远场记录器。默认的 “ 智能网格 ” 设置下 计算区域边界以物体最大包围框向外延拓 lamda/2 ，若选择了“自定义网格”修改了计算区域边界， 建议不要使物体超出计算区域边界，否则可能会引起计算错误。 网格剖分检查 网格精度设置完后，启动计算前可预览网格划分情况，点击图标可得： 5. 启动计算 点击工具条中的 “ 运行 ” 图标，开始计算。计算开始后，消息窗口给出提示/警告/报错信息，计算任务管理窗口给出计算进度并且可右键管理任务。 双击指定的计算任务或右键打开观察器以观察电磁波入射到物体上的实时变化情况。 消息窗口 计算开始和进行过程中，右下角的消息窗口显示出计算初始化的状态。 计算进度 在界面下方消息窗口中可以观察计算任务的完成情况。 观察实时场 点击观察实时场图标，可以观察电磁波的散射过程。 6. 查看计算结果 计算完成后，在 “工作空间” 生成 “.ewd” 结果文件。 透射/反射率结果图如下: ',title : '双站RCS',flags : 0,children : []}]},{file:'./data/help_case_teach_AntennaArray.htm',name : 'help_case_teach_AntennaArray',body : '1. 偶极子天线阵 2. 贴片天线阵 ',title : '天线阵模式教学案例',flags : 0,children : [{file:'./data/help_case_teach_AntennaArray_DipoleArray.htm',name : 'help_case_teach_AntennaArray_DipoleArray',body : '天线阵模式（偶极子天线阵）教学案例 1. 概述 2. 设置计算模式及参数 3. 建立模型 4. 修改计算模式参数设置 5. 设置网格 6. 启动计算 7. 查看计算结果  1. 概述 本案例使用了 “ 天线阵（快速扫角）” 计算模式计算偶极子天线阵的辐射特性，该计算模式计算 相控阵天线阵列在指定频率下，不同发射角的方向图及相关结果，可一次计算完成多个角度扫描。目前， 电大精细结构以及相控阵多角度扫描是制约天线阵仿真设计的核心难点。 EastWave 针对国内外客户的特殊 需求，独创了 “ 天线阵（快速扫角）” 计算模式，在保证精度的情况下 “ 快速地 ” 计算大中型天线阵体系的不同扫描角度的 方向图，速度可比传统算法快 $10$ 倍以上，在大型和超大型（几百倍波长）天线阵上独具优势。 EastWave 软件天线阵具有： 独特的天线阵计算模式 具有快速 “ 创建阵列模型 ” 功能，尤其对上千天线阵，一分钟建模，操作快速简单 具有独特的 “ 阵列馈源 ” 设置功能，能够根据阵列周期自动将 “ 基源 ” 扩展成 “ 阵列馈源 ” 分局相控阵发射角快速自动设置 “ 阵列馈源 ” 上的相位分布，不用重复添加可一次计算多角度的方向图 本案例使用“ 天线阵（快速扫角）” 计算模式计算偶极子天线阵的辐射特性，本案例计算频率 $10$ GHz 下， $ phi$ 为 $ 0^ circ $ ，$ theta$ 为 $ 0^ circ $~$ 30^ circ $ ，间隔 $ 5^ circ $ 的天线阵的方向图。 $21$ $ times$ $3$ 偶极子天线阵由 $63$ 个偶极子天线单元组成，单个偶极子天线的工作频率为 $10$ GHz ，偶极子天线阵元 长度约等于半个波长，宽度等于 $0.5$ mm ，材料为 pec ，阵子沿Y轴方向，偶极子下面方块是金属底板，材料为 pec 。在 FDTD 仿真中，用细金属棒连通偶极子天线两金属臂，使用集总端口馈电。 案例仿真流程如下： 设置计算模式及参数 建立模型 修改计算模式参数设置 设置网格 启动计算 查看计算结果 2. 设置计算模式及参数 选择计算模式 由菜单选文件进入 “ 向导 ” 界面，选择 “ 天线阵（快速扫角）模式 ”。 设置模式参数 进入向导之后，频率为 $10$ GHz ，其他一些参数不确定，先不修改整个模式参数，以默认值为主， 等整个阵列建立完成之后再修改各个参数。 查看向导报告 “ 天线阵（快速扫角）” 模式里，默认长度单位设置为 mm ，时间单位设置为自动关联，频率单位设置为 GHz 。 背景材料为空气，其他参数是默认值，点击“完成”即可开始建模。 注意 ：“ 时间单位 ” 默认和长度单位自动关联，高级用户可自己设置来控制 FDTD 仿真对应的真实时间尺度。 设置文件名和存储路径 进入 “设置文件名和存储路径” 对话框，选择存储路径，输入文件名。 3. 建立模型 定义常用变量 为了方便参数调节和优化，建议将建模中用到的参数尽量在变量表中定义： 建立偶极子天线单元 本案例通过“圆柱体”来演示如何建立模型，可以采用如下几种操作方式： 直接点击次模型工具条 “圆柱体” 图标 点击 “新建物体” 菜单，选择 “创建柱体” 点击 “工程管理窗口” 下的 “模型” ，选择类型 “添加”，选择“添加元件” 一根直导线命名为 Ligh ，材料选择为 pec ，如下图: 按同样的方式，建模另外一根直导线，命名为 Right ，材料选择为 pec ，如下图： 通过 “ 创建圆柱体 ” 建立偶极子天线两个直导线中间两端点之间的馈线，命名 Kuixian ， 材料选择为 pec 如下图： 打包天线阵列 完成单个天线建模后，建议将组成天线的所有物体打包成组。按住键盘 “ Ctrl ” 键，鼠标单击选中 Light ， Right ， Kuixian 三个物体，右键选 “ 组合 ”，设置完成结果如图： 创建阵列模型 右击 “模型” 菜单，选择 “添加” 而后选择 “添加阵列” 弹出对话框，并进行如下设置： 创建完成的阵列模型如下： 创建金属底板 在 “模型” 窗口， 选择 “模型”，右击“添加”，选择 “添加元件” 建立偶极子天线阵列下面的金属底板，命名为 Bd ， 材料选择为 pec ，如下图: 模型完成后，如下图所示： 4. 修改计算模式参数设置 修改模式参数 模型切面查看 5. 设置网格 使用 FDTD 方法仿真，一般要求网格的精度至少为关心频率对应波长的 1/15 以上，同时还要求网格能尽量识别模型的几何细节。一般情况下，默认选择“智能网格”， EastWave 会自动 根据用户设置的工程频率范围划分网格，用户可以简单选择不同的网格精度即可完成划分。 用户也可以自定义网格，可以控制每个维度的计算范围和网格数，并可以修改仿真时间 步长和总时间步长。 对于有特别精细结构（比如 1/100 波长以下）的模型，网格往往需要特别处理， EastWave 提供共形网格、非均匀网格、指定网格面、指定网格区域 等高级控制手段，详细请参看 EastWave 帮助手册网格设置部分，或咨询 EastWave 工程师。 设置非均匀网格策略 网格精度可以通过如下两种方式设置修改： “求解器” 菜单下的 “设置网格” “模型”窗口下 “模板” 选项，双击 “网格” 选项即可设置网格 选择 “非均匀网格” 、开启“共形网格”进行计算 设置的对话框如下： 网格剖分检查 网格精度设置完后，启动计算前可预览网格划分情况，点击图标可得： 6. 启动计算 点击工具条中的 “运行” 图标，开始计算。计算开始后，消息窗口给出提示/警告/报错信息，计算任务管理窗口给出计算进度并且可右键管理任务。 双击指定的计算任务或右键打开观察器以观察电磁波入射到物体上的实时变化情况。 消息窗口 计算开始和进行过程中，右下角的消息窗口显示出计算初始化的状态。 计算进度 在界面下方消息窗口中可以观察计算任务的完成情况。 观察实时场 点击观察实时场图标，可以观察电磁波的散射过程。 7. 查看计算结果 计算完成后，在 “工作空间” 生成 “.ewd” 结果文件。 透射/反射率结果图如下: ',title : '偶极子天线阵',flags : 0,children : []},{file:'./data/help_case_teach_AntennaArray_PatchArray.htm',name : 'help_case_teach_AntennaArray_PatchArray',body : '天线阵模式（贴片天线阵）教学案例 1. 概述 2. 设置计算模式及参数 3. 建模 4. 设置网格 5. 启动计算 6. 查看计算结果  1. 概述 本案例使用 “天线阵计算模式”计算贴片天线阵的辐射特性，该计算模式可以计算相控天线阵列在不同角度下的 方向图及相关结果，可一次完成宽频范围内多个频点计算。 模型示意图： 微带贴片天线是在一个薄介质上，一面附上金属薄层作为接地板，另一面用光刻腐蚀等方法做出一定形状的金属 贴片，利用同轴或微带对贴片馈电。贴片可以是方形、矩形、圆形或其他形状。微带贴片天线结构上的特点是体积小、 重量轻、剖面低、能与飞行器共形、成本低；主要缺点是频带窄、效率低，这是因为微带贴片天线实质上接近封闭的谐振系统。 案例仿真流程如下： 设置计算模式及参数 建模 修改计算模式参数设置 设置网格 启动计算 查看计算结果 2. 设置计算模式及参数 选择计算模式 由菜单选文件进入 “向导” 界面，选择 “天线阵模式”。 设置模式参数 频率设置为 “ 2.25：0.1:2.85 ” 表示计算频率范围 2.25-2.85 GHz，间隔0.1GHz。 扫描设置中 $ theta$ 角度范围设置为 “ 0 ：15: 45 ” ，$ phi$ 角度设置为“0”，极化角度设置为“0”。 进行向导之后，一些参数不确定，先不修改整个模式参数，以默认值为主，等整个阵列建立完成之后再修改各个参数。 查看向导报告 “天线阵模式”默认长度单位设置为 mm, 时间单位设置成自动关联，频率单位设置为GHz。背景材料为空气， 其他参数是默认值，点击“完成”即可开始建模。 注意 ：“时间单位”默认和长度单位自动关联，高级用户可自己设置来控制FDTD仿真对应的真实时间尺度。 设置文件名和存储路径 进入 “设置文件名和存储路径” 对话框，选择存储路径，输入文件名。 3. 建模 定义常用变量 为了方便参数调节和优化，建议将建模中用到的参数尽量在变量表中定义： 新建材料 新建材料可以通过如下几种操作方式：   直接点击工具条 “新建材料” 图标 点击 “模型菜单” 的 “新建材料” 选项 “工程管理窗口” 的 “新建材料” 选项 材料名设置为 material ，介质设置为简单的无色散材料中的有耗材料， 介电常数 $ varepsilon$ 使用变量表中的 eps 。电损耗角正切为 0.0027， 颜色和透明度可以根据自己喜好选取。更多复杂材料的设置请参看 EastFDTD 帮助手册 “材料模块”。 材料完成后工程管理目录树如图： 材料完成后工程管理目录树如下： 新建模型 本案例通过“立方体”来演示如何建立模型，可以采用如下几种操作方式： 直接点击次模型工具条 “立方体” 图标 点击 “模型” 菜单，选择 “立方体” 点击 “工程管理窗口” 下的 “新建结构” ，选择类型 “立方体” 建立贴片天线金属地板 通过 “创建立方体” 建立贴片天线的地板，命名为 Ground。 中心坐标为（0，0，-gndh/2）,宽度为（gnda,gndb,gndh）。 而后通过修饰，添加材料为 pec 。 建立贴片天线介质板 通过“立方体”建立贴片天线的介质板，命名“Mat”。 中心坐标为（0,0，dich/2）,宽度为（dica,dicb,dich）。 而后通过修饰，添加材料为 material 。 建立贴片天线金属贴片 通过“立方体”建立贴片天线的金属贴片，命名为“Patch”。 中心坐标为（0,0，dich+pahh/2）,宽度为（paha,pahb,pahh）。 而后通过修饰，添加材料为 pec 。 建立贴片天线的馈线 通过“立方体”建立连通贴片天线的金属贴片和金属底板之间的馈线，命名为“Kuixian”。 中心坐标为（0，0，dh/2-gndh/2 ），宽度为（dp,dp,dh）。 打包天线阵元 完成单个天线建模后，建议将组成天线的所有物体打包成组，以方便生成阵列。 按住键盘 “Ctrl” 键，鼠标依次单击选中以上四个元件，右键点击组合。并且修改组名称 为 “Total_Structure”，如下图： 创建完成的单个贴片天线模型如下图： 建立天线阵列 EastWave 中可直接将物体扩展成周期阵列。新建阵列模型可以通过如下方式： “工程管理窗口”下， 右键点击“模型”，选择 “添加” 下的“添加阵列”，选择类型为“DArrayExpr”， 在x、y 方向把单一天线阵列扩展成7行7列的天线阵。如下图所示： 点击确定得到阵列： 4. 设置网格 使用 FDTD 方法仿真，一般要求网格的精度至少为关心频率对应波长的 1/15 以上，同时还要求网格能尽量识别模型的几何细节。一般情况下，默认选择“智能网格”， EastWave 会自动 根据用户设置的工程频率范围划分网格，用户可以简单选择不同的网格精度即可完成划分。 用户也可以自定义网格，可以控制每个维度的计算范围和网格数，并可以修改仿真时间 步长和总时间步长。 对于有特别精细结构（比如 1/100 波长以下）的模型，网格往往需要特别处理， EastWave 提供共形网格、非均匀网格、指定网格面、指定网格区域 等高级控制手段，详细请参看 EastWave 帮助手册网格设置部分，或咨询 EastWave 工程师。 设置网格精度 网格精度可以通过如下两种方式设置修改： “求解器” 菜单下的 “设置网格” “工程管理窗口” 计算模式下的 “网格” 设置的对话框如下： 选择 “非均匀网格” 、开启“共形网格”进行计算。 网格剖分检查 网格精度设置完后，启动计算前可预览网格划分情况，点击图标可得： 5. 启动计算 点击工具条中的 “运行” 图标，开始计算。计算开始后，消息窗口给出提示/警告/报错信息，计算任务管理窗口给出计算进度并且可右键管理任务。 双击指定的计算任务或右键打开观察器以观察电磁波入射到物体上的实时变化情况。 消息窗口 计算开始和进行过程中，右下角的消息窗口显示出计算初始化的状态。 计算进度 在界面下方消息窗口中可以观察计算任务的完成情况。 观察实时场 点击观察实时场图标，可以观察电磁波的散射过程。 6. 查看计算结果 计算完成后，在 “工作空间” 生成 “.ewd” 结果文件。 透射/反射率结果图如下: ',title : '贴片天线阵',flags : 0,children : []}]},{file:'./data/help_case_teach_AntennaRandome.htm',name : 'help_case_teach_AntennaRandome',body : '1. 瞄准线误差 2. 功率传输系数 ',title : '天线罩模式教学案例',flags : 0,children : [{file:'./data/help_case_teach_AntennaRandome_BSE.htm',name : 'help_case_teach_AntennaRandome_BSE',body : '天线罩模式（瞄准线误差）教学案例 1. 概述 2. 设置计算模式及参数 3. 建模 4. 设置网格 5. 启动计算 6. 查看计算结果  1. 概述 本案例使用“天线罩（瞄准线误差）计算模式”计算球锥天线罩的瞄准线误差（BSE），该计算模式可一次设置多次计算，得到天线罩多个扫描角度的频率响应瞄准 模型示意图： image 1: 贴片天线阵示意图 微带贴片天线是在一个薄介质上，一面附上金属薄层作为接地板，另一面用光刻腐蚀等方法做出一定形状的金属 贴片，利用同轴或微带对贴片馈电。贴片可以是方形、矩形、圆形或其他形状。微带贴片天线结构上的特点是体积小、 重量轻、剖面低、能与飞行器共形、成本低；主要缺点是频带窄、效率低，这是因为微带贴片天线实质上接近封闭的谐振系统。 案例仿真流程如下： 设置计算模式及参数 建模 修改计算模式参数设置 设置网格 启动计算 查看计算结果 2. 设置计算模式及参数 选择计算模式 由菜单选文件进入 “向导” 界面，选择 “天线阵模式”。 image 2: 选择天线阵计算模式 设置模式参数 频率设置为 “ 2.25：0.1:2.85 ” 表示计算频率范围 2.25-2.85 GHz，间隔0.1GHz。 扫描设置中 $ theta$ 角度范围设置为 “ 0 ：15: 45 ” ，$ phi$ 角度设置为“0”，极化角度设置为“0”。 进行向导之后，一些参数不确定，先不修改整个模式参数，以默认值为主，等整个阵列建立完成之后再修改各个参数。 image 3: 设置模式参数 查看向导报告 “天线阵模式”默认长度单位设置为 mm, 时间单位设置成自动关联，频率单位设置为GHz。背景材料为空气， 其他参数是默认值，点击“完成”即可开始建模。 注意 ：“时间单位”默认和长度单位自动关联，高级用户可自己设置来控制FDTD仿真对应的真实时间尺度。 image 4: 查看向导报告 设置文件名和存储路径 进入 “设置文件名和存储路径” 对话框，选择存储路径，输入文件名。 image 5: rcs（单站）原理示意图 3. 建模 定义常用变量 为了方便参数调节和优化，建议将建模中用到的参数尽量在变量表中定义： image 6: 设置模式参数 新建材料 新建材料可以通过如下几种操作方式：   直接点击工具条 “新建材料” 图标 点击 “模型菜单” 的 “新建材料” 选项 “工程管理窗口” 的 “新建材料” 选项 材料名设置为 material ，介质设置为简单的无色散材料中的有耗材料， 介电常数 $ varepsilon$ 使用变量表中的 eps 。电损耗角正切为 0.0027， 颜色和透明度可以根据自己喜好选取。更多复杂材料的设置请参看 EastFDTD 帮助手册 “材料模块”。 材料完成后工程管理目录树如图： image 7: 设置材料 材料完成后工程管理目录树如下： image 8: 设置材料 新建模型 本案例通过“立方体”来演示如何建立模型，可以采用如下几种操作方式： 直接点击次模型工具条 “立方体” 图标 点击 “模型” 菜单，选择 “立方体” 点击 “工程管理窗口” 下的 “新建结构” ，选择类型 “立方体” 建立贴片天线金属地板 通过 “创建立方体” 建立贴片天线的地板，命名为 Ground。 image 9: 贴片天线金属底板 中心坐标为（0，0，-gndh/2）,宽度为（gnda,gndb,gndh）。 而后通过修饰，添加材料为 pec 。 建立贴片天线介质板 通过“立方体”建立贴片天线的介质板，命名“Mat”。 image 10: 贴片天线介质板 中心坐标为（0,0，dich/2）,宽度为（dica,dicb,dich）。 而后通过修饰，添加材料为 material 。 建立贴片天线金属贴片 通过“立方体”建立贴片天线的金属贴片，命名为“Patch”。 image 11: 贴片天线金属贴片 中心坐标为（0,0，dich+pahh/2）,宽度为（paha,pahb,pahh）。 而后通过修饰，添加材料为 pec 。 建立贴片天线的馈线 通过“立方体”建立连通贴片天线的金属贴片和金属底板之间的馈线，命名为“Kuixian”。 image 12: 设置材料 中心坐标为（0，0，dh/2-gndh/2 ），宽度为（dp,dp,dh）。 打包天线阵元 完成单个天线建模后，建议将组成天线的所有物体打包成组，以方便生成阵列。 按住键盘 “Ctrl” 键，鼠标依次单击选中以上四个元件，右键点击组合。并且修改组名称 为 “Total_Structure”，如下图： image 13: 设置材料 创建完成的单个贴片天线模型如下图： image 14: 设置材料 建立天线阵列 EastWave 中可直接将物体扩展成周期阵列。新建阵列模型可以通过如下方式： “工程管理窗口”下， 右键点击“模型”，选择 “添加” 下的“添加阵列”，选择类型为“DArrayExpr”， 在x、y 方向把单一天线阵列扩展成7行7列的天线阵。如下图所示： image 15: 设置材料 点击确定得到阵列： image 16: 设置材料 4. 设置网格 使用 FDTD 方法仿真，一般要求网格的精度至少为关心频率对应波长的 1/15 以上，同时还要求网格能尽量识别模型的几何细节。一般情况下，默认选择“智能网格”， EastWave 会自动 根据用户设置的工程频率范围划分网格，用户可以简单选择不同的网格精度即可完成划分。 用户也可以自定义网格，可以控制每个维度的计算范围和网格数，并可以修改仿真时间 步长和总时间步长。 对于有特别精细结构（比如 1/100 波长以下）的模型，网格往往需要特别处理， EastWave 提供共形网格、非均匀网格、指定网格面、指定网格区域 等高级控制手段，详细请参看 EastWave 帮助手册网格设置部分，或咨询 EastWave 工程师。 设置网格精度 网格精度可以通过如下两种方式设置修改： “求解器” 菜单下的 “设置网格” “工程管理窗口” 计算模式下的 “网格” 设置的对话框如下： image 17: rcs（单站）原理示意图 image 18: rcs（单站）原理示意图 选择 “非均匀网格” 、开启“共形网格”进行计算。 网格剖分检查 网格精度设置完后，启动计算前可预览网格划分情况，点击图标可得： image 19: rcs（单站）原理示意图 5. 启动计算 点击工具条中的 “运行” 图标，开始计算。计算开始后，消息窗口给出提示/警告/报错信息，计算任务管理窗口给出计算进度并且可右键管理任务。 双击指定的计算任务或右键打开观察器以观察电磁波入射到物体上的实时变化情况。 消息窗口 计算开始和进行过程中，右下角的消息窗口显示出计算初始化的状态。 计算进度 在界面下方消息窗口中可以观察计算任务的完成情况。 观察实时场 点击观察实时场图标，可以观察电磁波的散射过程。 6. 查看计算结果 计算完成后，在 “工作空间” 生成 “.ewd” 结果文件。 透射/反射率结果图如下: image 20: 剖分网格图 ',title : '瞄准线误差',flags : 0,children : []},{file:'./data/help_case_teach_AntennaRandome_PowerTrans.htm',name : 'help_case_teach_AntennaRandome_PowerTrans',body : 'empty page ',title : '功率传输系数',flags : 0,children : []}]},{file:'./data/help_case_teach_EMC.htm',name : 'help_case_teach_EMC',body : 'empty page ',title : '电磁兼容模式教学案例',flags : 0,children : []},{file:'./data/help_case_teach_RadarImage.htm',name : 'help_case_teach_RadarImage',body : '1. 一维HRRP成像 2. 二维SAR成像 ',title : '雷达目标成像模式教学案例',flags : 0,children : [{file:'./data/help_case_teach_RadarImage_HRRP.htm',name : 'help_case_teach_RadarImage_HRRP',body : 'empty page ',title : '一维HRRP成像',flags : 0,children : []},{file:'./data/help_case_teach_RadarImage_SAR.htm',name : 'help_case_teach_RadarImage_SAR',body : 'empty page ',title : '二维SAR成像',flags : 0,children : []}]},{file:'./data/help_case_teach_ArrayRandome.htm',name : 'help_case_teach_ArrayRandome',body : '1. 阵罩联合仿真模式教学案例一 2. 阵罩联合仿真模式教学案例二 ',title : '阵罩联合仿真模式教学案例',flags : 0,children : [{file:'./data/help_case_teach_ArrayRandome_SampleOne.htm',name : 'help_case_teach_ArrayRandome_SampleOne',body : 'empty page ',title : '阵罩联合仿真模式教学案例一',flags : 0,children : []},{file:'./data/help_case_teach_ArrayRandome_SampleTWO.htm',name : 'help_case_teach_ArrayRandome_SampleTWO',body : 'empty page ',title : '阵罩联合仿真模式教学案例二',flags : 0,children : []}]}]},{file:'./data/help_case_show.htm',name : 'help_case_show',body : 'empty page ',title : '演示案例',flags : 0,children : []}]},{file:'./data/help_ui.htm',name : 'help_ui',body : '用户界面 参考指南 本参考指南将对 EastWave 7 的用户界面做一个全面的介绍。其中： 编辑器 ：介绍了 EastWave 7 中多种不同类型的编辑器。不同类型编辑器的详细功能在 详细功能 中都有使用指导； 详细功能 ：介绍了菜单栏、工具栏、状态栏等具体的功能以及不同窗口的主要用途。 简介 EastWave 7 用户界面也称工作界面，是 EastWave 7 软件使用者的工作环境。了解、熟悉这个工作环境有助于用户高效、准确的完成仿真解决方案的创建。下图展示 了在不打开任何编辑器时的 EastWave 7 界面： 概览 EastWave 7 提供了多种不同类型的编辑器，包括： 模型文档编辑器 文本文件编辑器 MX 交互编辑器 绘图编辑器 实时场观察器 EastWave 7 界面详细功能较为多，大体上分类为： 主菜单栏 工具栏 状态栏 其它窗口 &nbsp;&nbsp;提示 最为 核心且常用 的编辑器为 模型文档编辑器 ， 用户建立模型、仿真分析设置等关键步骤都是在该编辑器中进行的。 ',title : '用户界面',flags : 0,children : [{file:'./data/help_ui_editor.htm',name : 'help_ui_editor',body : '1. 文本文件编辑器 2. MX 交互编辑器 3. 绘图编辑器 4. 模型文档编辑器 5. 实时场观察器 ',title : '编辑器',flags : 0,children : [{file:'./data/help_ui_editor_editor_text.htm',name : 'help_ui_editor_editor_text',body : '文本文件编辑器 文本文件编辑器主要是用于查看或修改具有文本格式( *.txt, *.log, *ewp2, *.ewsl, *.cpp, *.h )的文件。 打开方式 EastWave 7 提供了两种方式打开文本文件编辑器： 新建文本文件 ：打开 文件 菜单栏，选择 新建 &gt; 新建文本文件 。  打开文本文件 ：打开 文件 菜单栏，选择 打开 ，弹出的文件对话框中，选择扩展名格式 文本文件( *.txt,*.log... ) ，最后选取文件打开。 界面直览 为了向用户提供有关文本文件编辑器界面的高级直观概览，下图显示了通过文本文件编辑器打开一个工程文件( example.ewp2 )后的界面： 其中： 窗口 文本文件编辑窗口 工作空间窗口 消息管理窗口 菜单栏 文本 文件 编辑 视图 帮助 核心部分 行号：用于显示文本行数。 语言：当前文本的语言格式，包括 C++, MX, LUA, Python, SQL等 。 语法高亮：提供语法高亮功能。 折叠：语句块折叠功能。 自动换行：文本自动换行功能。 缩进提示：开启缩进提示后，同缩进层级代码会增加虚线提示，增加代码可读性。 特殊字符显示：包括换行符以及空白符的显示。 模式切换：包括只读模式、改写模式。  &nbsp;&nbsp;提示 当 EastWave 7 的模型工程文件( *.ewsl, *.ewp2 )无法通过模型编辑器打开时，可以通过文本文件编辑器对该脚本文件进行修改。 ',title : '文本文件编辑器',flags : 0,children : []},{file:'./data/help_ui_editor_editor_mx.htm',name : 'help_ui_editor_editor_mx',body : 'MX 交互编辑器 MX 交互编辑器是一个强大的工具。对于 MX 语言 初学者来说，它简单易用，可以 实时预览代码的效果 ，非常适合学习 MX 这门语言。在日常的开发中， MX 交互编辑器可以进行快速的原型开发和试错。 打开方式 EastWave 7 提供了两种方式打开 MX 交互编辑器： 新建 MX 交互编辑器 ：打开 文件 菜单栏，选择 新建 &gt; 新建 MX 交互编辑器 。  打开 MX 脚本源文件 ：打开 文件 菜单栏，选择 打开 ，弹出的文件对话框中，选择扩展名格式 MX 脚本( *.mx ) ，最后选取文件打开。 界面直览 为了向用户提供有关 MX 交互编辑器界面的高级直观概览，下图显示了通过 MX 交互编辑器打开一个工程文件( example.mx )后的界面： 其中： 窗口 MXLab 窗口 变量窗口 工作空间窗口 消息管理窗口 菜单栏 文件 编辑 视图 帮助 核心部分 实时代码：实时代码即为开发人员输入的代码，输入完成后按回车键即可出现实时结果。 实时结果：实时结果展示了代码运行后的结果(函数的创建也有实时结果)。 进阶交互 MX 交互编辑器还可以与 独立 MX 窗口 进行交互，开发人员可以在独立 MX 窗口编写代码段，点击 执行 按钮后会在 MX 交互编辑器执行代码段。  独立 MX 窗口可以通过菜单栏 视图 &gt; 其它窗口 &gt; MX 窗口 创建。 独立 MX 窗口的界面截图： 相关主题： MX 语言 ',title : 'MX 交互编辑器',flags : 0,children : []},{file:'./data/help_ui_editor_editor_figure.htm',name : 'help_ui_editor_editor_figure',body : '绘图编辑器 EastWave 7 提供的绘图编辑器， 是一种 数据可视化 以及 数据分析 的工具， 可以满足日常科技工作中的大部分需求( 二维、三维绘图、均值求解等 )。 界面直览 为了向用户提供有关绘图编辑器界面的高级直观概览， 下图显示了通过绘图编辑器绘制了二维、三维数据后的界面： 其中： 窗口 绘图编辑窗口 模型树窗口 工作空间窗口 消息管理窗口 菜单栏 色度条 时间控制 观察面 移动 旋转 缩放 文件 编辑 视图 帮助 核心部分 title：图表的标题。 label：坐标轴的文本标注。 legend：图表的图例。 colormap：颜色数值表。 datamgr：数据集合。 界面逻辑 旋转、移动、观察面切换以及对colormap的操作，只会对当前选中的图表起作用。 图形类型 plot 二维点线图 polar 二维极坐标点线图 imagesc 二维图像 polar3d 三维球坐标图 stlmodel 三维模型图 ',title : '绘图编辑器',flags : 0,children : []},{file:'./data/help_ui_editor_editor_model.htm',name : 'help_ui_editor_editor_model',body : '模型文档编辑器 EastWave 7 中 最核心 的编辑器就是模型文档编辑器。整个仿真分析的主要阶段也是在模型文档编辑器中进行的。在模型编辑器中， 用户可以 设置重要参数(网格参数、计算模式参数等) 、 建立模型 、 配置求解器 等。 打开方式 通过菜单栏 文件 &gt; 新建 &gt; 新建模型文档 ，用户可以创建一个新的模型文档编辑器。 用户也可以通过点击菜单栏 文件 &gt; 打开 的方式，使用模型文档编辑器打开 EastWave 7 的工程文件( *.ewsl, *.ewp2 )。 界面直览 为了向用户提供有关模型文档编辑器的高级直观概览，下图显示了通过模型文档编辑器中打开一个仿真解决方案后的界面： 其中: 窗口 模型文档编辑窗口 模型树窗口 工作空间窗口 消息管理窗口 菜单栏 模型编辑器 新建物体 网格视图 观察面 移动 旋转 缩放 文件 编辑 视图 帮助 核心部分 模型树窗口：工程文件包含的所有元件( 几何元件、记录器、监视器等 )都显示在此。 材料：不同材料的颜色通常是不一致的，用户可手动设置。 坐标轴：模型编辑窗口中的坐标轴为全局坐标轴，可通常模型树窗口显示或隐藏坐标轴。 网格：网格便于用户查看网格划分情况，用户同样可以通过模型树窗口显示或隐藏网格视图。 相关主题： 模型编辑器 参考 仿真分析 参考 ',title : '模型文档编辑器',flags : 0,children : []},{file:'./data/help_ui_editor_editor_fieldviewer.htm',name : 'help_ui_editor_editor_fieldviewer',body : '实时场观察器 EastWave 7 提供的实时场观察器，主要用于实时观察当前仿真的具体情况。 打开方式 通过菜单栏 文件 &gt; 新建 &gt; 实时场观察器 ，用户可以新建一个实时场观察器。 开启 FDTD 计算后，用户通过设置 IP 地址 以及 端口 可以对指定 FDTD 计算任务进行链接，链接成功后即可观察实时场数据。 界面直览 为了向用户提供有关实时场观察器的高级直观概览，下图显示了通过实时场观察器中链接一个 FDTD 计算后的界面： 其中： 窗口 实时场观察器窗口 模型树窗口 工作空间窗口 消息管理窗口 菜单栏 色度条 网格视图 观察面 移动 旋转 缩放 文件 编辑 视图 帮助 核心部分 链接 FDTD 计算：设置 IP 地址、端口后，对指定 FDTD 计算进行链接。 色度条：运算结果数值范围对应的色度条范围。 ',title : '实时场观察器',flags : 0,children : []}]},{file:'./data/help_ui_detail.htm',name : 'help_ui_detail',body : '1. 主菜单栏 2. 工具栏 3. 状态栏 4. 其它窗口 ',title : '详细功能',flags : 0,children : [{file:'./data/help_ui_detail_menu.htm',name : 'help_ui_detail_menu',body : '1. 文件 2. 编辑 3. 视图 4. 帮助 5. 观察面 6. 移动 7. 旋转 8. 缩放 9. 文本 10. 色度条 11. 时间控制 12. 模型编辑器 13. 新建物体 14. 网格视图 ',title : '主菜单栏',flags : 0,children : [{file:'./data/help_ui_detail_menu_file.htm',name : 'help_ui_detail_menu_file',body : '文件 菜单 文件菜单用于管理 EastWave 7 工程文件，包括文件的 新建 、 打开 、 保存 、 关闭 以及 CAD模型的导入导出 等操作。 文件下拉菜单包含的所有操作命令如下图所示。 菜单项 备注 文件 &gt; 打开 打开一个本地工程 文件 &gt; 新建 新建一个编辑器窗口 文件 &gt; 保存 保存当前工程文件 文件 &gt; 另存为 把当前工程文件另存为... 文件 &gt; 全部保存 保存所有工程文件 文件 &gt; 关闭 关闭当前工程文件 文件 &gt; 关闭全部 关闭所有工程文件 文件 &gt; 载入工作空间文件 - 文件 &gt; 保存工作空间文件 - 文件 &gt; 导入 导入 STL 模型 文件 &gt; 导出 导出 STL 模型 文件 &gt; 打开文件历史 - 文件 &gt; 推出 推出 EastWave 7 ',title : '文件',flags : 0,children : []},{file:'./data/help_ui_detail_menu_edit.htm',name : 'help_ui_detail_menu_edit',body : '编辑 菜单 编辑菜单主要用于对模型窗口中的对象、文本编辑器下的脚本 进行编辑操作以及截图 ，编辑下拉菜单包含的所有操作命令如图所示。  菜单项 备注 编辑 &gt; 撤销 撤销上一步操作 编辑 &gt; 重做 恢复上一步操作 编辑 &gt; 剪切 剪切当前选中文本或对象 编辑 &gt; 复制 复制当前选中文本或对象 编辑 &gt; 粘贴 粘贴当前选中文本或对象 编辑 &gt; 删除 删除当前选中文本或对象 编辑 &gt; 全选 - 编辑 &gt; 查找 - 编辑 &gt; 替换 - 编辑 &gt; 截图 - ',title : '编辑',flags : 0,children : []},{file:'./data/help_ui_detail_menu_view.htm',name : 'help_ui_detail_menu_view',body : '视图 菜单 视图菜单用于管理界面的窗口布局以及显示。视图下拉菜单包含的所有命令如图所示。   菜单项 备注 视图 &gt; 工作空间 显示或隐藏工作空间窗口 视图 &gt; 状态栏 显示或隐藏状态栏 视图 &gt; 消息 显示或隐藏消息窗口 视图 &gt; 工具条 自定义快捷工具栏 视图 &gt; 其它窗口 显示或隐藏其它窗口 视图 &gt; 布局 自定义窗口布局或使用默认布局 视图 &gt; 语言 设置 EastWave 7 全局语言 视图 &gt; 选项 显示或隐藏工作空间窗口 视图 &gt; 工具箱 常用工具 视图 &gt; 表达式解析器 - 视图 &gt; 全屏显示 - ',title : '视图',flags : 0,children : []},{file:'./data/help_ui_detail_menu_help.htm',name : 'help_ui_detail_menu_help',body : '帮助 菜单 帮助菜单主要用于访问自带的帮助文档系统以及查看 EastWave 的产品信息、许可信息。帮助下拉菜单中的所有操作命令如图所示。 菜单项 备注 帮助 &gt; 官方网站 打开 EastWave 官方网站，获取更多资料 帮助 &gt; 帮助文档 打开 EastWave 7 帮助文档系统 帮助 &gt; 关于我们 显示软件、公司以及许可证相关信息 ',title : '帮助',flags : 0,children : []},{file:'./data/help_ui_detail_menu_look.htm',name : 'help_ui_detail_menu_look',body : '观察面 菜单 观察面菜单是 绘图编辑器 、 模型文档编辑器 以及 实时场观察器 的特有菜单， 主要用于控制观察的平面，便于用户从不同角度查看模型或者监视器。 菜单项 备注 观察面 &gt; XOY+ 观察 XOY 正平面 观察面 &gt; XOZ+ 观察 XOZ 正平面 观察面 &gt; YOZ+ 观察 YOZ 正平面 观察面 &gt; XOY- 观察 XOY 负平面 观察面 &gt; XOZ- 观察 XOZ 负平面 观察面 &gt; YOZ- 观察 YOZ 负平面 观察面 &gt; 3D 观察 3D(立体) 平面 ',title : '观察面',flags : 0,children : []},{file:'./data/help_ui_detail_menu_move.htm',name : 'help_ui_detail_menu_move',body : '移动 菜单 移动菜单是 绘图编辑器 、 模型文档编辑器 以及 实时场观察器 的特有菜单， 主要用于微调物体的移动。 菜单项 备注 移动 &gt; 左移 视角上将物体左移 移动 &gt; 右移 视角上将物体右移 移动 &gt; 下移 视角上将物体下移 移动 &gt; 上移 视角上将物体上移 移动 &gt; 后移 视角上将物体后移 移动 &gt; 前移 视角上将物体前移 &nbsp;&nbsp;提示 移动菜单的所有操作，只是简单改变观察视角，并不会影响物体内部实际的位置参数。 ',title : '移动',flags : 0,children : []},{file:'./data/help_ui_detail_menu_rotate.htm',name : 'help_ui_detail_menu_rotate',body : '旋转 菜单 旋转菜单是 绘图编辑器 、 模型文档编辑器 以及 实时场观察器 的特有菜单， 主要用于微调物体的旋转。 菜单项 备注 旋转 &gt; 自上向下 视角上将物体自上向下旋转 旋转 &gt; 自下向上 视角上将物体自下向上旋转 旋转 &gt; 自右往左 视角上将物体自右往左旋转 旋转 &gt; 自左往右 视角上将物体自左往右旋转 旋转 &gt; 顺时针 视角上将物体顺时针旋转 旋转 &gt; 逆时针 视角上将物体逆时针旋转 &nbsp;&nbsp;提示 旋转菜单的所有操作，只是简单改变观察视角，并不会影响物体内部实际的位置参数。 ',title : '旋转',flags : 0,children : []},{file:'./data/help_ui_detail_menu_scale.htm',name : 'help_ui_detail_menu_scale',body : '缩放 菜单 缩放菜单是 绘图编辑器 、 模型文档编辑器 以及 实时场观察器 的特有菜单， 主要用于微调物体的缩放。 菜单项 备注 缩放 &gt; 放大 视角上将物体放大 缩放 &gt; 缩小 视角上将物体缩小 缩放 &gt; 合适比例 视角上将物体缩放至合适比例 &nbsp;&nbsp;提示 缩放菜单的所有操作，只是简单改变观察视角，并不会影响物体内部实际的位置参数。 ',title : '缩放',flags : 0,children : []},{file:'./data/help_ui_detail_menu_text.htm',name : 'help_ui_detail_menu_text',body : '文本 菜单 文本菜单为 文本文件编辑器 特有菜单，主要用于控制文本的各种格式以及模式。文本下拉菜单包含的所有操作命令如下图所示。 菜单项 备注 文本 &gt; 语言 设置文本的语言规则 文本 &gt; 语法高亮 语法关键词高亮 文本 &gt; 折叠 自动折叠语句块 文本 &gt; 自动换行 - 文本 &gt; 显示行号 - 文本 &gt; 显示缩进提示 - 文本 &gt; 显示长句标识 - 文本 &gt; 显示空白字符 - 文本 &gt; 显示换行符 - 文本 &gt; 只读模式 文本以只读模式打开，不可修改任何内容 文本 &gt; 改写模式 文本以改写模式打开，输入皆为 Insert 模式 ',title : '文本',flags : 0,children : []},{file:'./data/help_ui_detail_menu_colormap.htm',name : 'help_ui_detail_menu_colormap',body : '色度条 菜单 色度条菜单是 绘图编辑器 和 实时场观察器 特有的菜单，主要用于控制计算结果数值与色度范围的对应值，以便于直观地观察计算结果。 色度条下拉菜单包含的所有操作命令如下图所示。 菜单项 备注 色度条 &gt; 自动适应 自适应色度条范围 色度条 &gt; 增加范围 增加色度条范围值 色度条 &gt; 降低范围 降低色度条范围值 ',title : '色度条',flags : 0,children : []},{file:'./data/help_ui_detail_menu_timectrl.htm',name : 'help_ui_detail_menu_timectrl',body : '时间控制 菜单 时间控制菜单为 绘图编辑器 特有菜单，主要用于控制动态绘图的播放进度。时间控制下拉菜单包含的所有操作命令如下图所示。 菜单项 备注 时间控制 &gt; 播放 开始播放已绘制完毕的动态图 时间控制 &gt; 停止 停止播放已绘制完毕的动态图 时间控制 &gt; 重新开始 重新播放已绘制完毕的动态图 时间控制 &gt; 前进 切换至上一张绘图 时间控制 &gt; 后退 切换至下一张绘图 ',title : '时间控制',flags : 0,children : []},{file:'./data/help_ui_detail_menu_model_edit.htm',name : 'help_ui_detail_menu_model_edit',body : '模型编辑器 菜单 模型编辑器菜单为 模型文档编辑器 特有菜单，主要包含对仿真环境的设置以及几何结构、材料库相关功能。模型编辑器下拉菜单包含的所有操作命令如下图所示。 菜单项 备注 模型编辑器 &gt; 文档参数 &gt; 设置模版 设置文档的顶层模块参数 模型编辑器 &gt; 文档参数 &gt; 设置变量表 用户自定义变量表 模型编辑器 &gt; 文档参数 &gt; 设置单位 工程文档的基本单位(长度、频率、时间) 模型编辑器 &gt; 文档参数 &gt; 设置计算模式 选择相应的 计算模式 并设置参数 模型编辑器 &gt; 文档参数 &gt; 设置背景材料 设置全局背景材料 模型编辑器 &gt; 文档参数 &gt; 设置计算区域 - 模型编辑器 &gt; 文档参数 &gt; 设置边界 设置边界类型以及边界条件 模型编辑器 &gt; 文档参数 &gt; 设置频率参数 设置最小频率、最大频率 模型编辑器 &gt; 文档参数 &gt; 设置时间参数 设置时间步长等 模型编辑器 &gt; 文档参数 &gt; 设置输出 设置输出文件的路径以及文件名等 模型编辑器 &gt; 文档参数 &gt; 设置求解器 包含对微引擎数、零引擎、求解器最小步数的设置 模型编辑器 &gt; 文档参数 &gt; 设置网格 对网格类型、网格加密、网格修正的设置 运行 运行工程，进行仿真求解 生成网格 生成物体离散化网格 检查所有物体封闭性 检测工程文件中所有几何物体的封闭性 导出所有物体(STL) 导出工程文件中所有的几何物体 材料管理器 为用户提供的 材料库 ，材料库中提供了 拟合色散材料功能 ',title : '模型编辑器',flags : 0,children : []},{file:'./data/help_ui_detail_menu_new_item.htm',name : 'help_ui_detail_menu_new_item',body : '新建物体 菜单 新建物体菜单为 模型文档编辑器 特有菜单，主要提供了一系列几何结构的快速构造方式，不仅包含长方体、圆柱体等基础几何结构，也包含 拉伸体、FFS、复杂旋转体等扩展几何结构。新建物体下拉菜单包含的所有操作命令如下图所示。 菜单项 备注 新建物体 &gt; 创建立方体 参看 立方体 新建物体 &gt; 创建柱体 参看 柱体 新建物体 &gt; 创建球体 参看 球体 新建物体 &gt; 创建圆台 参看 圆台 新建物体 &gt; 创建拉伸体 参看 拉伸体 新建物体 &gt; 创建实心旋转体 参看 实心旋转体 新建物体 &gt; 创建空洞旋转体 参看 空洞旋转体 新建物体 &gt; 创建扫描体 参看 扫描体 新建物体 &gt; 创建环体 参看 环体 新建物体 &gt; 创建天线罩 &gt; 尖锥(Conical)天线罩  参看 尖锥(Conical)天线罩 新建物体 &gt; 创建天线罩 &gt; 正切卵形(Tangent Ogive)天线罩  参看 正切卵形(Tangent Ogive)天线罩 新建物体 &gt; 创建天线罩 &gt; 球形鼻锥(Spherrically-blunted Cone)天线罩  参看 球形鼻锥(Spherrically-blunted Cone)天线罩 新建物体 &gt; 创建天线罩 &gt; 幂次形旋转体(Power Series)天线罩  参看 幂次形旋转体(Power Series)天线罩 &nbsp;&nbsp;提示 关于几何元件的具体介绍，请参看 几何元件 。 ',title : '新建物体',flags : 0,children : []},{file:'./data/help_ui_detail_menu_mesh.htm',name : 'help_ui_detail_menu_mesh',body : '网格视图 菜单 网格视图菜单为 模型文档编辑器 特有菜单，主要提供了对网格以及物体视图的一些控制，包括物体实体显示、物体线框显示、物体网格显示、全局平面网格显示等。 网格视图下拉菜单包含的所有操作命令如下图所示。 菜单项 备注 网格视图 &gt; 显示实体 显示或隐藏物体实体视图 网格视图 &gt; 显示线框 显示或隐藏物体线框视图 网格视图 &gt; 网格 显示或隐藏物体网格划分情况 网格视图 &gt; XY平面 显示或隐藏XY平面全局网格 网格视图 &gt; ZX平面 显示或隐藏ZX平面全局网格 网格视图 &gt; YZ平面 显示或隐藏YZ平面全局网格 ',title : '网格视图',flags : 0,children : []}]},{file:'./data/help_ui_detail_bar.htm',name : 'help_ui_detail_bar',body : '工具栏 工具栏位于 EastWave 7 主菜单下方，在工具栏中列出了 EastWave 7 中常用操作命令的快捷方式按钮，单击这些按钮可以快速地执行相应的操作命名。 绝大多数的工具栏只是菜单栏的快捷方式。把鼠标悬停在工具栏按钮上，鼠标指针的下方会显示出该按钮的功能说明。 下图为工具栏的总览图： 1. 标准 2. 地址栏 3. 链接 4. 观察面 5. 移动 6. 旋转 7. 缩放 8. 模型编辑器 9. 新建物体 10. 网格视图 11. 色度条 12. 时间控制 13. 显示控制 ',title : '工具栏',flags : 0,children : [{file:'./data/help_ui_detail_bar_std.htm',name : 'help_ui_detail_bar_std',body : '标准 工具条 标准工具条对应 文件菜单 ，主要包含了对工程文件的一些基本操作( 新建、打开、复制、保存等 )。 图标 功能说明  打开工程文件  新建编辑器  保存当前工程文件  保存所有工程文件  剪切  复制  粘贴  删除  撤销  重做 ',title : '标准',flags : 0,children : []},{file:'./data/help_ui_detail_bar_href.htm',name : 'help_ui_detail_bar_href',body : '地址栏 工具条 地址栏工具条可用于访问指定的网站(EastWave 7 内置了 Web 浏览器)。 图标 功能说明  地址栏输入框  浏览按钮 ',title : '地址栏',flags : 0,children : []},{file:'./data/help_ui_detail_bar_link.htm',name : 'help_ui_detail_bar_link',body : '链接 工具条 链接工具条主要用于链接当前正在进行的 FDTD 计算任务，输入需要链接的 IP 地址以及端口后即可创建链接。 图标 功能说明  IP 地址输入框  端口输入框  开始链接按钮  断开链接按钮 ',title : '链接',flags : 0,children : []},{file:'./data/help_ui_detail_bar_look.htm',name : 'help_ui_detail_bar_look',body : '观察面 工具条 观察面工具条对应 观察面菜单 ，主要用于快速调整模型的观察面。 图标 功能说明  XOY+  XOZ+  YOZ+  XOY-  XOZ-  YOZ-  3D ',title : '观察面',flags : 0,children : []},{file:'./data/help_ui_detail_bar_move.htm',name : 'help_ui_detail_bar_move',body : '移动 工具条 移动工具条对应 移动菜单 ，主要包含了在视角上对物体的平移操作。 图标 功能说明  左移  右移  下移  上移  后移  前移 ',title : '移动',flags : 0,children : []},{file:'./data/help_ui_detail_bar_rotate.htm',name : 'help_ui_detail_bar_rotate',body : '旋转 工具条 旋转工具条对应 旋转菜单 ，主要包含了在视角上对物体的旋转操作。 图标 功能说明  自上向下  自下向上  自右往左  自左往右  顺时针  逆时针 ',title : '旋转',flags : 0,children : []},{file:'./data/help_ui_detail_bar_scale.htm',name : 'help_ui_detail_bar_scale',body : '缩放 工具条 缩放工具条对应 缩放菜单 ，主要包含了在视角上对物体的缩放操作。 图标 功能说明  放大  缩小  合适比例 ',title : '缩放',flags : 0,children : []},{file:'./data/help_ui_detail_bar_model_editor.htm',name : 'help_ui_detail_bar_model_editor',body : '模型编辑器 工具条 模型编辑器工具条对应 模型编辑器菜单 ，主要是包含求解器设置以及几何结构、材料( 材料库 )相关的功能。 图标 功能说明  设置文档参数  运行当前工程文件  生成物体网格信息  检测当前工程文档所有几何结构的封闭性  导出当前工程文档所有几何结构体 ',title : '模型编辑器',flags : 0,children : []},{file:'./data/help_ui_detail_bar_new_item.htm',name : 'help_ui_detail_bar_new_item',body : '新建物体 工具条 新建物体工具条对应 新建物体菜单 ，该工具条为用户提供了快速建模的各种方法。 图标 功能说明  新建长方体  新建圆柱体  新建球体  新建圆台  新建垂直拉伸体  新建实心旋转体  新建空心旋转体  新建扫描体  新建环体  新建天线罩 ',title : '新建物体',flags : 0,children : []},{file:'./data/help_ui_detail_bar_mesh.htm',name : 'help_ui_detail_bar_mesh',body : '网格视图 工具条 网格视图工具条对应 网格视图菜单 ，主要用于控制网格显示相关内容。 图标 功能说明  显示物体实体表面  显示物体线框结构  显示物体网格情况  显示XY平面网格  显示ZX平面网格  显示YZ平面网格 ',title : '网格视图',flags : 0,children : []},{file:'./data/help_ui_detail_bar_colormap.htm',name : 'help_ui_detail_bar_colormap',body : '色度条 工具条 色度条工具条对应 色度条菜单 ，主要用于控制计算结果的色度范围。 图标 功能说明  色度条范围自适应  增加色度条范围  降低色度条范围 ',title : '色度条',flags : 0,children : []},{file:'./data/help_ui_detail_bar_timectrl.htm',name : 'help_ui_detail_bar_timectrl',body : '时间控制 工具条 时间控制工具条对应 时间控制菜单 ，主要作用于绘图得到的动态图，便于用户控制动态图的情况。 图标 功能说明  播放  停止  重新开始  前进  后退 ',title : '时间控制',flags : 0,children : []},{file:'./data/help_ui_detail_bar_settings.htm',name : 'help_ui_detail_bar_settings',body : '显示控制 工具条 显示控制工具条，主要用于控制 实时场观察器 的观察数据以及观察面。 图标 功能说明  播放  停止  选择数据  选择观察分量  选择观察平面  -  更新观察值  关闭 ',title : '显示控制',flags : 0,children : []}]},{file:'./data/help_ui_detail_state.htm',name : 'help_ui_detail_state',body : '状态栏 状态栏位于 EastWave 7 工作界面的底部，用于显示当前操作命令的说明信息。 EastWave 7 状态栏包含以下部分： 工程文档位置及文件名信息，位于状态栏左边； 当前鼠标的位置信息，位于状态栏中间，只有在鼠标悬停于物体上时才给出提示。 这里给出的位置信息为鼠标坐标投影到屏幕截面上的坐标，因此只作为参考，不一定是该位置在软件坐标系中的真实位置信息。  ',title : '状态栏',flags : 0,children : []},{file:'./data/help_ui_detail_other_window.htm',name : 'help_ui_detail_other_window',body : '1. 工作空间窗口 2. 任务管理窗口 3. 消息管理窗口 4. 模型树窗口 5. 变量窗口 6. 文本文件编辑窗口 7. MXLab 窗口 8. 绘图编辑窗口 9. 三维模型窗口 10. 实时场观察器窗口 ',title : '其它窗口',flags : 0,children : [{file:'./data/help_ui_detail_other_window_workplace.htm',name : 'help_ui_detail_other_window_workplace',body : '工作空间窗口 工程空间窗口默认位于 EastWave 7 工作界面左上方。通过主菜单 视图 &gt; 工作空间 操作命令，可以显示/隐藏工作空间窗口。 工作空间窗口通过树的形式对 EastWave 工程及计算结果进行管理，该窗口下主要包含以下内容： 所有已载入或曾经载入过的工程文件( *.ewp )； 计算结束后自动生成的与工程名称同名的的结果文件（ *.ewd ），双击结果文件即可跳转到后处理窗口对结果进行查看、处理。 &nbsp;&nbsp;注意 在打开某些旧版文档时，EastWave 可能报警告称某些行内容无法识别，此时可以关闭该工程后，右键点击该工程文档并选择用文本文件方式打开，然后编辑相应行。 ',title : '工作空间窗口',flags : 0,children : []},{file:'./data/help_ui_detail_other_window_mission.htm',name : 'help_ui_detail_other_window_mission',body : '任务管理窗口 任务管理窗口主要用于查询提交至 服务器 的计算任务的当前信息。通过主菜单 视图 &gt; 其它窗口 &gt; 任务管理器 操作命令，可以显示/隐藏任务管理器窗口。 用户可以根据任务管理器提供的信息： IP 地址和端口号：对计算中的任务进行观察(通过实时场观察器)； 当前任务状态：判断任务是否完成，还是中途出错； 队列信息：任务的优先级别。 ',title : '任务管理窗口',flags : 0,children : []},{file:'./data/help_ui_detail_other_window_message.htm',name : 'help_ui_detail_other_window_message',body : '消息管理窗口 消息管理窗口用于显示工程设计求解过程中的各项信息。通过主菜单 视图 &gt; 消息 操作命令，可以显示/隐藏消息窗口。 信息管理窗口下包含以下三种信息： 普通 消息：提示当前操作的步骤，格式：[时间]操作信息； 错误 消息：提示当初操作的错误信息，格式:[时间]错误信息，当脚本载入解析时发生错误，将给出错误在脚本中的行号信息， 用户可通过该信息对脚本中错误行进行检查（可通过工作空间中工程文件右键菜单 使用...打开 &gt; 文本编辑器 ，进入工程脚本编辑状态）； 警告 消息：提示可能会导致问题的信息。 ',title : '消息管理窗口',flags : 0,children : []},{file:'./data/help_ui_detail_other_window_modeltree.htm',name : 'help_ui_detail_other_window_modeltree',body : '模型树窗口 模型树窗口显示当前活动的工程设计，该模型树包含了当前工程文档中所有的元件，以及它们之间的层级关系。 操作说明： 通过该工程的模型树可以便捷的查看和操作(新建、删除、修改等)当前工程的 计算模式参数、模型参数、激励源参数、记录器参数及结果信息 ； 通过点击工程树左侧的展开按钮和收起按钮按钮，可以 展开和收起 当前节点； 通过点击勾选按钮勾选和取消勾选，可以 显示和隐藏 对应节点的物体、激励源、记录器；在同一节点下，通过组合操作 shift键+鼠标左键 连续选择或 ctrl键+鼠标左键 加选多个对象。 ',title : '模型树窗口',flags : 0,children : []},{file:'./data/help_ui_detail_other_window_variable.htm',name : 'help_ui_detail_other_window_variable',body : '变量窗口 变量窗口显示了当前用户定义的所有变量的类型与数值。用户可以通过该窗口，直观的查看已定义的变量以及数值。 ',title : '变量窗口',flags : 0,children : []},{file:'./data/help_ui_detail_other_window_text.htm',name : 'help_ui_detail_other_window_text',body : '文本文件编辑窗口 文本文件编辑窗口主要用于编辑或查看可读文件( *.txt, *.ewp2, *.ewsl, *.cpp等 )。 ',title : '文本文件编辑窗口',flags : 0,children : []},{file:'./data/help_ui_detail_other_window_mxlab.htm',name : 'help_ui_detail_other_window_mxlab',body : 'MXLab 窗口 MXLab 窗口主要用于 MX 语言的交互使用。 ',title : 'MXLab 窗口',flags : 0,children : []},{file:'./data/help_ui_detail_other_window_figure.htm',name : 'help_ui_detail_other_window_figure',body : '绘图编辑窗口 绘图编辑窗口主要用于显示数据曲线图像等。通过该窗口，用户可以 同时绘制 多幅图像，并且 单独控制 每一幅数据图。 ',title : '绘图编辑窗口',flags : 0,children : []},{file:'./data/help_ui_detail_other_window_modelview.htm',name : 'help_ui_detail_other_window_modelview',body : '三维模型窗口 三维模型窗口默认位于 EastWave 7 工作界面右方。三维模型窗口是创建、编辑和显示物体、激励源、记录器等对象的区域，默认位于软件的右侧， 通过上方的 Tab 可以在各工程之间快速切换。 三维模型窗口中包含如下对象： 物体、激励源、记录器等对象； 坐标轴。位于三维模型窗口的左下方，方便快速获取当前模型的空间朝向信息； 参考线。位于三维模型窗口中央，与全局坐标系一致，可作为模型创建过程中的位置参考对象； 计算区域。作为计算区域范围的标识框，随计算区域范围的变化而变化； 物体包围框和提示信息。当选中物体时显示包围框，在屏幕左上角显示提示信息，其中 Name 表示物体的名称， Pmin 表示包围框 X、Y、Z 方向上的最小值， Pmax 表示包围框 X、Y、Z 方向上的最大值， Lx、Ly、Lz 分别表示包围框在 X、Y、Z 三个方向上的长度， 表示格式为“[长度值/单位]”； ',title : '三维模型窗口',flags : 0,children : []},{file:'./data/help_ui_detail_other_window_truetime.htm',name : 'help_ui_detail_other_window_truetime',body : '实时场观察器窗口 实时场观察器窗口主要用于显示当前计算任务的场分布图等。通过该窗口，用户可以直观清晰的观察当前计算任务的场具体分布情况。 ',title : '实时场观察器窗口 ',flags : 0,children : []}]}]}]},{file:'./data/help_definition.htm',name : 'help_definition',body : '工程定义 EastWave仿真模型将一些被引用的参数放在 定义 中，以便用户定义模型元件时使用。 - 变量表 - 单位 - 材料 - 元件（库） 变量表 变量表提供了设计参数管理的手段。用户在变量表中定义变量（可以使用MX语言的表达式来计算变量值）。在工程模型元件中的参数通常可以使用变量表中的变量进行定义。 单位 设定当前文档有关的单位。对于电磁仿真，主要是时间单位、长度单位和频率单位。常见的单位包括： 国际单位制（SI）：米 m 、秒 s 、赫兹 Hz 电磁波工程常用：毫米 mm 、纳秒 ns 、吉赫兹 GHz 材料 设定当前文档有关的材料。 EastWave V7提供了下列材料模型： 材料模型 名称  说明  简单材料  介电常数、电导率等为常数的材料  德拜材料  德拜材料模型  洛仑兹材料  洛仑兹材料模型  修正洛仑兹材料  修正洛仑兹材料模型  电磁组合材料  电特性和磁特性可以分别绑定不同材料模型的材料  空间相关材料  空间每一点的介电常数、电导率可以取不同的数值  条件选择材料  根据用户设定的条件在空间的不同区域选择不同材料  元件（库） 元件库是EastWave V7中可以用于建立仿真模型的所有元件组织成的库。在元件库中的元件相当于工厂的零件仓库，既有可能被使用，也有可能没有被使用。对于可见对象，即几何结构（Geometry Entity）、物理元件（Physical Entity）、组、阵列，以及监视器和激励源等，如果要被仿真过程应用，必须在“模型”节点下被组装起来。 ',title : '工程定义',flags : 0,children : []},{file:'./data/help_workmode.htm',name : 'help_workmode',body : '计算模式 参考指南 本参考指南用来详细说明各个专业计算模式的功能、模式设定、输入参量、结果输出等。 简介 计算模式是针对领域特定问题开发的参数化仿真方案。用户根据需要求解的工程问题选择恰当的计算模式后，一般只需要设定必要的分析参数即可对用户模型进行分析计算。使用计算模式，可以省去大量的仿真参数设置过程，这些过程容易出错，而且在多次计算任务中可能产生一些复杂行为，普通用户难以轻松掌握。 目前计算模式包括： - 雷达目标RCS计算模式 - 雷达目标成像模式 - 天线计算模式 - 天线阵计算模式 - 元器件计算模式 概览 针对用户的工程需求，东峻研发团队集成开发的计算模式， 包括： 1. 自动计算透反率模式 2. 天线罩计算模式 3. 天线阵计算模式 4. 雷达目标RCS计算模式 5. 电磁兼容计算模式 6. 雷达目标成像计算模式 7. 天线计算模式 &nbsp;&nbsp;提升 专业计算模式包含东峻针开发的独特快速算法，对于电大体系，相比于传统 FDTD 算法，可获得至少10倍以上的速度提升。 相关主题：  个性化“计算模式”亮点优势 快速入门 ',title : '计算模式',flags : 0,children : [{file:'./data/help_workmode_auto_tra_ref.htm',name : 'help_workmode_auto_tra_ref',body : '自动透反率计算模式 概述 计算无穷大周期结构正入射时不同频率的透射/反射率（两端口S参数），这里透射/反射率为 0阶透射/反射率 。 计算模式根据输入参数（频率范围和入射方向等）和模型结构，自动设置激励源和记录器，计算结束后自动完成后处理，输出透射率/反射率。 在 计算模式 中选中DWorkmodeTransrefl，即可进入自动透反率模式设置界面。 模式默认设置 自动透反率模式为用户提前预设了一些必要的参数，具体包括单位、激励源、监视器以及边界条件的设置，其中单位用户可以根据具体需要 更改为合适的量纲。 单位（默认设置） 长度单位：mm 频率单位：GHz 时间单位：ns 默认单位修改操作步骤： 在 模型 悬浮框，点击展开 单位 进入参数设置的单位设置功能； 在 unit 的下拉框中点击 新建单位 ，设置文档单位，按顺序分别为长度(m)、频率(Hz)、时间(s)。 激励源 空间分布：平面波 时域波形：脉冲（信号频率范围覆盖输入的频率范围） 发射方向：根据用户输入的模式参数“入射方向” 极化角度：激励源偏振角度为 45度 ，记录器分别记录0度和90度场分量， 后处理需对入射信号幅度进行归一化处理 位置：距离计算区域边界4个网格 监视器 类型：时域截面场平均 位置：距离计算区域边界2个网格（透射和反射记录器分别位于激励源的发射方向和背向） 边界设置 入射/反射方向：开放边界（默认：20层CPML吸收边界） 其他方向：周期边界 &nbsp;&nbsp;注意 入射方向网格数目需要大于8； 文档单位为全局单位，计算文档中的材料、结构在没有设置单位时，其单位为文档单位，如自建Lorentz材料若没有单位，其$ omega_a$、$ omega _c$、$ omega _p$单位为文档中频率单位，详见： 材料模块 。 除默认设置外，用户需要根据计算模型和计算要求手动设置一些参数，包括方向和频率范围、计算区域大小、结构模型、网格策略、共形策略等。 方向和频率 在 模型悬浮 框内双击 计算模式 输入方向和频率范围参数: 输入项 描述 频率序列 最小频率：freq_min，最大频率：freq_max，频率间隔：freq_delta。 入射方向 选择电磁波的入射方向。 垂直于结构周期方向（正入射）。 计算区域设置 在 模型悬浮 框内点击展开 模板 ，双击 计算区域 输入x、y、z方向计算范围: 建立模型 设置结构 几何结构设置参看： 几何元件 ； 设置材料 设置新材料或导入系统材料参看： 材料元件 ； 绑定材料和结构 在 模型 悬浮窗内的 显示 、 模型 选项内 右键 点击需要绑定材料的模型，并左键点击 修饰 选项； 在 模型 悬浮窗内的 显示 、 模型 选项内找到包含原结构的 DSymbolPtr ；  右键 点击 DSymbolPtr ，并左键点击 属性 选项，在 mat_name 中选择所要绑定的材料，并点击确定。 模型建立可参看： 刻蚀结构 Demo ； 网格设置 在 模型悬浮 框内点击展开 模板 ，双击 网格 进行网格和共形设置。 网格设置:  在 网格设置 选项内进行网格数目设置，网格类型可以选用均匀网格和非均匀网格，当 网格类型 选用 均匀网格 时， 在 网格 选项内输入x、y、z方向的网格数目: 共形设置:  在 共形设置 选项内设置共形策略 PEC共形(PMC共形) 为关闭时，电场(磁场)不采用任何共形策略，计算存在staircase error; PEC共形(PMC共形) 非关闭时，PEC(PMC)材料共形开启，非PEC(PMC)材料共形策略进入可选状态； 非PEC(PMC)材料共形策略 ，线共形推荐 segment ，面共形推荐 average 。 共形具体参数意义参见 共形设置 ； 运行 在主界面 模型编辑器 内选择 运行 ; run_at 选项选择local_cmd_window， 总核数 选项设置计算核数； 矢量加速可以提高计算速度，默认为SSE，若无法运行可选择关闭或选择其它加速方式； 输出结果 计算结果保存于与计算文档在相同文件夹的 同名ewd文件 中，输出结果为： 输出项 一级节点 二级节点 说明 备注 result source、rcd_ta、rcd_tb、rcd_ra、rcd_rb、freq_max、freq_min、freq_delta 模式计算的原始结果 在ewsl交互编辑器内获取数据命令为result.source、result.rcd_ta... src1 [0]g_src.g2 data 输入信号 在ewsl交互编辑器内获取信号数据命令为src1[0].signal; rcd_trans [0]g_rcd.g2 data 透射方向记录器 在ewsl交互编辑器内获取信号数据命令为avg1[0].data[0](A偏振)，avg1[0].data[1](B偏振); rcd_refl [0]g_rcd.g2 data 反射方向记录器 在ewsl交互编辑器内获取信号数据命令为avg2[0].data[0](A偏振)，avg2[0].data[1](B偏振); smartdata 绘制透反率强度和相位 绘图策略采用DFT时将采用直接傅里叶变换给出freq_max:freq_delta:freq_min序列的所有结果，采用FFT时只给出freq_min和freq_max频率范围内满足FFT条件的频率点结果。 dparam 模型计算相关信息 &nbsp;&nbsp;极化定义: A极化：电矢量E的振动方向平行于入射轴下一轴； B极化：电矢量E的振动方向垂直于入射轴下一轴； 例如，入射方向为X正方向，则A偏振电场沿Y轴，B偏振电场沿Z轴。 ',title : '自动计算透反率模式',flags : 0,children : []},{file:'./data/help_workmode_radome.htm',name : 'help_workmode_radome',body : '天线罩计算模式 概述 计算天线罩的透波率和BSE的计算模式，可以计算频率响应和（辐射）角度响应。计算模式根据用户输入参数，自动设定内部的激励源和监视器，完成相应的参数扫描。 天线罩模式的仿真流程 选择分析类型为透波率或者BSE 设置分析参数 建立天线罩和环境的模型 回到天线罩模式设置对话框，指定好天线罩物体的名称 计算 分析结果 模式设定 1. 单位（建议采用以下单位制） 长度单位：mm 时间单位：ns 频率单位：GHz 2. 激励源 场源 时域波形：高斯脉冲 空间分布：均匀分布或者其他空间函数 方向：目前设定为Z+方向初射 极化：允许用户设定一个初射极化方向 3. 监视器 时域远场监视器（计算透波率） 频域远场监视器（计算BSE和方向图） 4. 边界设置 自动设置为开放边界 建议6层PML/CPML 5. 其他 无 模式图示 模式 设置 界面如下： image 1: 天线罩设置  image 2: 口径设置  image 3: 方向图设置 image 4: 杂项设置 模式参数 基本设置 参数名称  说明  备注  分析类型  透波率或BSE计算   目标天线罩  待分析的天线罩名称  要求挂载在模型顶层  频率设定模式  选择频率设定方式   角度扫描方式  选择角度扫描方式  Theta扫描或Phi扫描  辐射角$ theta$  设定辐射角$ theta$  角度制  辐射角$ phi$  设定辐射角$ phi$  角度制  辐射极化角  设定辐射极化角  角度制  口径设置 参数名称  说明  备注  口径类型  等效口径或实体天线  目前仅开发等效口径  口径形状类型  圆形、矩形或者自定   口径宽度X/Y  设定口径的宽度   口径位置X/Y/Z  设定口径的位置   口径分布  选择分布类型  仅实现均匀分布  方向图设置 参数名称  说明  备注  方向图模式  选择查看方向图的项目   方向图记录  用户自定义的方向图   杂项 参数名称  说明  备注  远场距离  外推距离   延拓空间（监视器）  监视器包围框相对位置设定  填写相对波长的比例  延拓空间（计算区域） 计算区域相对位置设定  填写相对波长的比例  计算策略  选择计算策略  见 补充说明 BSE预扫角范围  设定BSE计算时在初射方向附近的扫描角度宽度 默认8度  BSE预扫角分辨率  设定BSE计算时的扫描精度  默认1分  补充说明： 三种计算策略 严格模式：计算透波率两次的各种计算参数保持一致。 准严格模式：计算透波率两次的大部分参数保持一致，但是计算区域会重新计算。 理想无环境：计算无罩模型的时候仅考虑口径本身的远场，不考虑其他非罩结构的影响。 输出结果 天线罩模式目前使用智能数据对计算结果进行分析。 透波率 在计算模式参数设置中选择计算“透波率”，软件将按照计算透波率的预设流程进行计算。计算结束后，用户可以点击结果文件，打开后双击“Transmission”节点。 image 5: 透波率结果（按频率） image 6: 透波率结果（按角度） 说明： 总透波率 定义为有罩和无罩情况下，给定某个口面激励条件下，远场某个方向上指定电磁场的强度比例（按电场或者按模式） 同极化 和 交叉极化 的计算的是透波率中同极化部分和交叉极化部分的贡献部分。 定义公式如下： $$ begin{align*} T_ text{total} &= dfrac{E_ text{total,w}}{E_ text{total,wo}} T_ text{copolar} &= dfrac{E_ text{copolar,w}}{E_ text{total,wo}} T_ text{crosspolar} &= dfrac{E_ text{crosspolar,w}}{E_ text{total,wo}} end{align*} $$ 公式项意义见下表： 项 意义 w 有罩 wo 无罩 total 总透波率 copolar 同极化 crosspolar 交叉极化 瞄准线误差（BSE） 在计算模式参数设置中选择计算“瞄准线误差”（BSE），软件将按照计算BSE的预设流程进行计算。计算结束后，用户可以点击结果文件，打开后双击“BSE”节点。 image 7: 瞄准线误差结果（智能数据） 说明： 瞄准线误差（BSE）定义为在差波束条件下，有罩状态的远场零点（最低点）与无罩状态的远场零点（最低点）之间的角度差，一般按 角度分 单位度量。 微分瞄准线误差（DBSE）定义为BSE值对待预期角度坐标取导数。 ',title : '天线罩计算模式',flags : 0,children : []},{file:'./data/help_workmode_antenna_array.htm',name : 'help_workmode_antenna_array',body : 'empty page ',title : '天线阵计算模式',flags : 0,children : []},{file:'./data/help_workmode_rcs.htm',name : 'help_workmode_rcs',body : '雷达目标散射截面(RCS)计算模式 概述 计算物体单站及双站 RCS 的频率响应或角度响应。计算模式根据输入参数（频率范围或扫描角度等），自动设置激励源和记录器，完成频率或角度扫描，并自动完成后处理给出 RCS 的频率 / 角度响应曲线。 本计算模式兼容单站及双站 RCS 计算，对于单站 RCS ，使用脉冲分析方法，可以同时得到多频点或宽带的 RCS 特性。双站 RCS 为用户可选选项，默认为关闭状态，开启时，每个单站角度都会进行双站扫描计算。双站 RCS 监视器支持延迟的 RCS 计算智能数据、固实的 RCS 数值智能数据两类。延迟计算的 RCS 智能数据仅支持频域远场监视器（即不能宽带扫描）。 单站 RCS 模式的仿真流程 ： 设置基本参数（工作频率、发射雷达角度范围、极化角度等） 建立散射体模型（RCS 目标） 计算（计算模式根据设定角度自动完成单站 RCS 角度扫描） 分析结果（智能数据处理得到单站模式下角度及频率响应曲线） 双站 RCS 模式的仿真流程 ： 设置基本参数（开启双站、工作频率、发射及接收雷达角度范围、极化角度等） 建立散射体模型（RCS 目标） 计算（计算模式根据设定角度自动完成双站 RCS 角度扫描） 分析结果（智能数据处理得到双站模式下角度及频率响应曲线） 模式设定 单位 ：默认单位设置如下，也可修改文档单位。 长度单位： mm 时间单位： ns 频率单位： GHz 激励源 ： 空间分布：平面波（总场散射场） 时域波形：默认设置脉冲（信号频率范围覆盖输入的频率范围），也可在 杂项 中自定义信号波形。 发射方向：根据用户输入的模式参数 发射雷达角度 $ theta$ 、$ phi$ 确定。 极化角度：根据用户输入的模式参数 发射雷达极化角 $ alpha$ 确定。 位置：激励源的默认设置位置为距离物体包围框的 LAMBDA / 4 处，用户也可在 杂项 中自定义激励源的位置。 记录器 ： 类型：单站模式下，默认设置为时域远场记录器；双站模式下，默认设置为频域远场记录器。 远场方向：单站模式下，无需设置，接收方向与发射方向反向；双站模式下，根据用户输入的模式参数 接收雷达角度 $ theta$ 、$ phi$ 确定。 位置：记录器的默认设置位置为距离物体包围框的 LAMBDA / 2 处，用户也可以在 杂项 中自定义记录器的位置。 边界设置 ： 开放边界，默认设置为 12 层 PML 吸收边界。 其他 ： 根据输入角度范围自动完成角度扫描。  模式图示 模式界面如下： image 1: RCS模式设置  image 2: 杂项设置  模式参数 设置 频率设置 ： 频率设置  参数  说明  单一频点  频率单值  单一频点模式下，仅需要设置单一频率，即为工作频率  线性步进  最小频率、最大频率、频率间隔 生成（最小频率：频率间隔：最大频率）的频率序列  均匀采样  最小频率、最大频率、频率数  生成以最小频率、最大频率、频率数构造的等差频率序列  频率列表  频率列表  离散的频率点  发射雷达角度设置 ： 角度设置  参数  说明  角度模式  $ theta$ 扫描 / $ phi$ 扫描  发射雷达入射角扫描模式  球坐标模式  ISO / HCS / GCS  球坐标系模式  $ theta$ 角度  $ theta$  发射雷达入射角度 $ theta$ $ phi$ 角度  $ phi$  发射雷达入射角度 $ phi$  极化角度  $ alpha$  发射雷达极化角  双站外推设置 ：（ 目前双站默认设置为频域记录器（立即外推），这三个参数暂时不起作用 ） 双站外推设置  参数  说明  备注  立即频域外推  双站远场监视器选择频域远场监视器（立即外推）  暂时无效 延迟频域外推  双站远场监视器选择频域远场监视器（延迟外推）  暂时无效 时域远场外推  双站远场监视器选择时域远场监视器  暂时无效 接收雷达角度设置 （仅限双站）： 角度设置  参数  说明  角度模式  $ theta$ 扫描 / $ phi$ 扫描  接收雷达角度扫描模式  球坐标模式  ISO / HCS / GCS  球坐标系模式  $ theta$ 角度  $ theta$  接收雷达角度 $ theta$  $ phi$ 角度  $ phi$  接收雷达角度 $ phi$  杂项 杂项中主要包括自定义激励源、自定义监视器等其他一些高级设置选项： 激励源设置中主要包括：自定义信号的设置、激励源的入射方向、激励源位置 监视器设置主要是监视器的位置设置 其他和计算相关的设置（如计算精度，计算区域位置等） &nbsp;&nbsp;说明 本计算模式默认设置激励源的信号为用户设置的频率范围的脉冲信号，勾选自定义信号，即可根据用户自己的需求设置时域信号（设置参数包括中心频率、脉冲宽度、信号强度、信号延迟）。 激励源的入射方向有两个选项：雷达（源）方向 / 波矢方向，默认设置为雷达（源）方向。 激励源的位置默认设置为自动拓展空间，拓展的距离是距离物体框 LAMBDA / 4 ，用户也可以修改这个拓展距离，也可以自定义激励源的位置。 监视器的位置默认设置为自动拓展空间，拓展的距离是距内置激励源位置的 LAMBDA / 4 ，用户可以修改拓展距离，也可以自定义监视器的位置。 精度设置暂时无效 计算区域设置暂时无效 输出结果： 智能数据结果主要分为两大部分： RCS 角度响应结果 RCS 频率响应结果 单站 RCS 智能数据界面如下（扫频）： 双站 RCS 智能数据界面如下（扫角）： &nbsp;&nbsp;注意: 角度设置：发射雷达的入射角度 $ theta$ 及 $ phi$ 不能同时为序列，接受雷达的角度设置也是如此。 双站开启：默认设置双站关闭状态，勾选双站开启后，双站外推设置及接收雷达角度设置才有效。 极化角：发射雷达极化角暂时仅能设置为单值，不能设置成序列。 角度扫描：角度扫描方式要和设置的 $ theta$、$ phi$ 一致。（例如：$ phi$ 扫描模式下，$ phi$ 为序列，$ theta$ 为单值。$ theta$ 扫描模式同理） 案例： 单站RCS-PEC球 双站RCS-PEC球 双站RCS-介质包裹PEC球 双站RCS-贴片天线阵 ',title : '雷达目标RCS计算模式',flags : 0,children : []},{file:'./data/help_workmode_elec_comp.htm',name : 'help_workmode_elec_comp',body : 'empty page ',title : '电磁兼容计算模式',flags : 0,children : []},{file:'./data/help_workmode_radar_img.htm',name : 'help_workmode_radar_img',body : '雷达成像计算模式 概述 雷达回波数据主要是指雷达照射目标的散射场，它真实地反映了目标结构和材料的散射特性，对回波数据的图像化处理就是雷达成像， 通过雷达图像提取目标散射特性，识别雷达目标和指导目标隐身设计是雷达目标成像的目的。 对于高分辨率距离（HRRP）成像，目标在雷达距离向上的散射特性体现在这个方向上散射强点构成的曲线图上； 对于逆合成孔径雷达（ISAR）成像，虽然空间目标的表面特性复杂，但是通常可以看成是有很多不同位置、不同反射系数的散射点 构成的。ISAR成像的目标就是要正确显示各散射点的相对位置和回波强度。 仿真流程： 设置基本参数（单位、工作频率、发射雷达扫描中心角、极化方式、雷达分辨率等） 建立模型（几何建模和材料设置） 网格设置 计算 结果显示和后处理 模式设置 基本设置 单位（默认设置） 长度单位：mm 频率单位：GHz 时间单位：ns 默认单位修改步骤： 在 模型 悬浮框，依次点击展开 doc --&gt; 定义 ； 双击 单位 --&gt;选择 设置单位 --&gt;点击单位对话框右边的编辑按钮--&gt;设置长度、频率和时间单位。 空间分布：平面波 时域波形：根据用户模式界面选择的信号类型（目前仅实现了Gauss信号） 发射方向：根据用户模式界面输入的角度参数$ theta$，$ phi$ 极化角度：根据用户模式界面选择的极化：垂直极化和水平极化 分辨率 距离分辨率：根据用户模式界面输入的距离向分辨率值 方位分辨率：根据用户模式界面输入的方位向分辨率值  画布尺寸 距离向尺寸：根据用户模式界面输入的距离向尺寸值 方位向尺寸：根据用户模式界面输入的方位向尺寸值 远场外推位置： 默认1e8[mm] 监视器 类型：时域远场记录器 位置：距离计算区域边界2个网格 边界设置 吸收边界（默认：12层CPML吸收边界） 模式界面 模型 --&gt;鼠标右击 计算模式 ，并点击 新建计算模式 --&gt;在 类型 下拉框里选择 DworkmodeImaging2 ,现在在 计算模式 栏里可见该计算模式，然后鼠标右击该计算模式菜单， 点击 激活 ，才能启动该模式，双击该计算模式，出现模式界面： 输入参数设置 主要设置参数如下图所示：   雷达成像子模式选择： ImagingMode: 成像模式，可选ISAR（二维成像）和HRRP（一维距离成像）；   雷达发射信号参数设置: 参数 说明 signal.type 信号类型，可选Gauss(高斯脉冲)、Chirp(啁啾信号)、SFCW（频率步进连续波信号） signal.frequency 中心频率 signal.theta $ theta$角 signal.phi $ phi$角，中心扫描角 signal.amplitude 信号幅度值 signal.polarization 信号极化类型，可选vertical(垂直极化)、horization(水平极化) signal.scsmode 扫角方式，可选ISO、HCS、GCS 注： 信号类型目前仅实现了Gauss信号。 雷达图像参数设置: 参数 说明 image.range_rsl 雷达图像距离分辨率 image.cross_rsl 雷达图像方位分辨率 image.range_size 雷达图像距离像尺寸 image.cross_size 雷达图像方位像尺寸 图像处理参数设置： algorithm.window: 窗函数。 杂项设置： 输出结果 一维成像结果：   一维成像数据：   二维成像结果：   二维成像数据：    ',title : '雷达目标成像计算模式',flags : 0,children : []},{file:'./data/help_workmode_antenna.htm',name : 'help_workmode_antenna',body : '天线计算模式 概述 计算单个天线结构在指定范围扫描角下的，可一次完成宽频范围内多个频点计算。 天线模式的仿真流程 ： 设置工作频率 创建天线结构及馈源 设置天线端口（选择馈源端口，设置端口的功率、强度、延迟、相位等） 设置监视器（设置扫描角度等） 计算（计算模式根据设定完成扫频扫角） 分析结果（智能数据处理得到空间场特性（方向图等）及天线端口特性（S参数、端口阻抗等）） 模式设定 单位 ：默认单位设置如下，也可修改文档单位。 长度单位： mm 时间单位： ns 频率单位： GHz 记录器 ： 类型：默认设置为 频域远场记录器 。 远场方向：根据用户输入的模式参数远场记录器 $ theta$ 、$ phi$ 确定。 位置：记录器的默认设置位置为距离物体包围框的 LAMBDA / 4 处，用户也可以在 杂项 中自定义记录器的位置。 边界设置 ： 开放边界，默认设置为 12 层 PML 吸收边界。 其他 ： 是否绘制三维方向图（如勾选3D方向图选项，则计算模式内部会另外创建一个 $ theta$-$ phi$ 角度同时扫描的频域远场记录器）。  模式图示 模式 设置 界面如下： image 1: 天线模式设置  image 2: 杂项设置  模式参数 频率设置 ： 频率设置  参数  说明  单一频点  频率单值  单一频点模式下，仅需要设置单一频率，即为工作频率  线性步进  最小频率、最大频率、频率间隔 生成（最小频率：频率间隔：最大频率）的频率序列  均匀采样  最小频率、最大频率、频率数  生成以最小频率、最大频率、频率数构造的等差频率序列  频率列表  频率列表  离散的频率点  天线端口设置 ： 参数  说明  备注  引用  绑定激励源端口  选择已定义的激励源 功率  修改绑定激励源端口的输入功率  暂时无效  强度  修改绑定激励源端口的信号强度  暂时无效  相位  修改绑定激励源端口的信号相位  暂时无效  延迟  修改绑定激励源端口的信号延迟  暂时无效  天线远场监视器设置 ： 远场设置  参数  说明  角度模式  $ theta$ 扫描 / $ phi$ 扫描  远场监视器角度扫描模式  球坐标模式  ISO / HCS / GCS  球坐标系模式  $ theta$ 角度  $ theta$  远场监视器 $ theta$ 角度  $ phi$ 角度  $ phi$  远场监视器 $ phi$ 角度  杂项中主要包括自定义激励源、自定义监视器等其他一些高级设置选项： 激励源设置：自定义信号波形设置（中心频率、频率宽度、相位、延迟） 监视器设置：1. 自动设置延拓空间 2. 自定义区域大小（ 设置 x、y、z 上下边界） 其他和计算相关的设置（如计算精度，计算区域位置等） &nbsp;&nbsp;注意 天线模式结合阵列修饰器功能，也能部分实现天线阵结构的仿真分析功能。 目前天线端口设置中，功率、强度、相位、延迟设置暂时均不起作用，不能修改指定激励源端口的信号。 启用S参数部分，暂时仅能计算端口的s11参数。 杂项设置中，功率记录框目前默认设置为与 Bbox 大小相同，暂时不支持自定义功率记录框功能。 输出结果： 输出结果主要分为两大部分： 空间参数智能数据（方向图及场图） 端口特性智能数据（S参数、端口阻抗等） 空间参数智能数据结果如下（方向图）： image 1: 方向性系数 image 2: 增益 端口特性智能数据结果如下（s参数）： image 3: S参数 公式定义 辐射功率密度 ： $$ S_ text{rad}( theta, phi) = frac{1}{2} Re[E( theta, phi) times H^*( theta, phi)] $$ 表示 $ ( theta, phi) $ 方向上的时间平均功率密度，单位：$W/m^2$。 辐射强度 ： $$ U( theta, phi)= r^2 S_ text{rad}( theta, phi) $$ 表示天线在 $( theta, phi)$ 方向上单位立体角内的辐射功率，单位：$W$。 方向性 ： $$ D( theta, phi)= frac{4 pi U( theta, phi)}{P_ text{rad}} $$ 表示天线在$( theta, phi)$方向上辐射强度与所辐射功率在全部方向上的平均辐射强度之比。 绝对增益 ： $$ G_ text{abs}( theta, phi) = frac{4 pi U( theta, phi)}{P_ text{acc}} $$ 表示天线在 $( theta, phi)$ 方向上的辐射强度与资用功率在全向上的平均辐射强度之比，此种增益定义方式考虑了天线系统的匹配问题。 增益 ： $$ G_ text{in}( theta, phi) = frac{4 pi U( theta, phi)}{P_ text{in}} $$ 表示天线在 $( theta, phi)$ 方向上的辐射强度与其输入功率在全向上的平均辐射强度之比，此种增益定义方式不考虑天线系统的失配损失。 辐射效率 ： $$ eta_r = frac{P_ text{rad}}{P_ text{acc}} $$ 表示辐射功率与进入到天线系统的功率之比。 匹配效率 ： $$ eta_m = frac{P_ text{acc}}{P_ text{in}} $$ 表示进入到天线系统的功率与总输入功率之比。 参数说明 &nbsp;&nbsp;公式参数说明 $ P_ text{in} $ 表示 总输入功率 。 $ P_ text{rad} $ 表示 总辐射功率 。 $ P_ text{acc} $ 表示进入到天线系统的功率。 $ P_ text{availabel} $ 表示 资用功率 ，意义为：当信号源和天线与传输线均匹配时，也就是共轭匹配条件下，信号源传输给天线的功率。 $pout$ 表示给定频点附近的，单位 $Hz$ 电磁波贡献的总能量，单位：$J$。 $power0$ 表示给定频点附近，$df$ 范围（由$T_ text{max}$决定）的电磁波贡献的总功率，单位：$W$。 $power1$ 表示给定频点附近，$df$ 范围（由$T_ text{mon}$决定）的电磁波贡献的总功率，单位：$W$。 $pout$、$power0$、$power1$ 均挂载在频域远场记录器结果文件节点下。 案例： 偶极子天线 ',title : '天线计算模式',flags : 0,children : []}]},{file:'./data/help_model.htm',name : 'help_model',body : '模型编辑器 参考指南 本参考指南详细介绍了 EastWave 7 中各种元件的基础信息，同时也提供了对不同类型元件进行组合的操作方法。 简介 EastWave 7 提供的模型编辑器，主要是为用户提供强大的建模功能。通过该模型编辑器，用户可以创建各种复杂模型、 生成各种复杂材料、创建指定位置的激励源或监视器等。对于建立大型物理模型而言，EastWave 7 模型编辑器帮助用户 大大加快了建模过程以及显著降低了建模复杂度。 概览 元件概念 ：功能上实现 结构信息 、 材料信息 、 坐标变换信息 的分离。   EastWave 7 提供的元件包括： 几何元件 材料元件 物理元件 激励源元件 记录器元件 坐标变换元件 ',title : '建模',flags : 0,children : [{file:'./data/help_model_symbol_concept.htm',name : 'help_model_symbol_concept',body : '元件概念 元件是一种抽象概念，它可以是： 物体基本的 结构 信息：外形、初始中心位置等。 物体的 材料 属性信息：普通材料或复杂材料等。 物体的 坐标变换 信息：平移、旋转等。 我们可以对不同的元件进行 组合 、 拆分 和 复用 。更为关键的是，通过元件概念，软件建模在功能上实现 结构信息 、 材料信息 、 坐标变换信息 的分离。 组合 通过对 几何元件 和 材料元件 的组合，我们可以得到 物理元件 。 物理元件 与 坐标变换元件 的组合，又可以生成新的物理元件。 拆分 使用 阵列 建模功能生成阵列后，可以通过 打散组 的功能，把单一阵列元件拆分成多个分散的独立元件。 复用 在 具有重复结构类型 的物体（如天线阵）建模时，具有相同属性信息的物体（如所有天线单元），可以通过 共用元件 实现，也可通过修改 共用元件 来实现统一修改。 ',title : '元件概念',flags : 0,children : []},{file:'./data/help_model_shape_symbol.htm',name : 'help_model_shape_symbol',body : '几何元件 几何元件是 EastWave 7 提供的作为参数化对象的结构信息元件。   使用 EastWave 几何元件功能可快速生成适合特定工程问题的物体模型，大大减小建模的复杂度。 如何创建几何元件 界面创建几何元件（推荐）  脚本创建几何元件（高级建模）  所有几何元件 除了 基础几何元件 外，EastWave 从工程应用角度出发，还开发了 扩展几何元件 。 基础几何元件 元件分类 元件名称 元件说明 基础几何元件 长方体 长方体可用于生成最简单的基本几何体。包括长方体面板、立方体小块等。 圆柱体 圆柱体可用于生成截面为正圆或椭圆的实心或空心的柱形几何体。 球体 球体可用于生成具有厚度的完整球体或椭圆体。 几何球体 几何球体可用于生成基于正二十多面体制作的球体。 圆锥体 圆锥体可用于生成圆形圆锥体。 环体 圆环体可用于生成一个具有圆形截面的环。 扩展几何元件 元件分类 元件名称 元件说明 扩展几何元件 实心旋转体 实心旋转体可用于生成基于外形线旋转一周形成的对称几何体。 空心旋转体 空心旋转体可用于生成基于给定表面旋转一定角度形成的几何体。 参数扫描体 参数扫描体可用于生成基于给定平面和变换矩阵参数构造的几何体。 垂直拉伸体 垂直拉伸体支持对给定的平面进行垂直拉伸建模。可用于构造棱柱等几何体。 导入CAD模型 导入CAD模型支持从外部导入常见CAD格式模型。 强制网格面 强制网格可在所指定的关键网格位置强制生成网格体或网格面或网格线，并加密周围网格。 多层物体 多层物体支持对给定的表面按照特定方向生长多层材料的建模。 天线罩 EastWave V7 根据常用天线罩形线预定义了内置天线罩模型，用户使用时只需输入模型所对应的外形线参数。 阵列 阵列用于设计基于某种元件，按照指定的空间排布生成的阵列结构或阵列激励源。   ',title : '几何元件',flags : 0,children : [{file:'./data/help_model_shape_symbol_DShapeCreate.htm',name : 'help_model_shape_symbol_DShapeCreate',body : '创建几何元件 用户可以通过 EastWave V7 界面或者脚本创建相应的几何元件。 通过界面创建几何元件 界面建模比较直观、方便，用户可以直接在界面上创建所有类型的几何元件（基础几何元件、扩展几何元件）。  通过界面创建几何元件，有以下两种方法： 方法一 在 EastWave V7 中打开 文件 菜单，然后选择 新建 &gt; 新建模型文档 以创建三维建模窗口。 在 EastWave V7 中打开 新建物体 菜单，然后选择希望创建的几何体以打开物体 属性 对话框。 在物体 属性 对话框中，设置物体各项 参数 。选择 确定 创建几何元件。  方法二 在 EastWave V7 中打开 文件 菜单，然后选择 新建 &gt; 新建模型文档 以创建三维建模窗口。 在 模型 节点资源管理器中，选择并展开 显示 节点。 右键单击 模型 节点打开菜单，然后选择 添加 &gt; 添加结构 以打开物体 属性 对话框。 在 类型 的下拉列表菜单中，选择希望创建的几何体类型，设置物体各项 参数 。选择 确定 创建几何元件。 注意：  若未显示 模型 节点资源管理器窗口，可以通过以下方法显示：  在 EastWave V7 中打开 视图 菜单，选择 其他窗口 &gt; 模型 。 通过脚本创建几何元件 脚本建模属于高级建模。  脚本建模的优势在于：可以设置未在界面开放的少量特殊参数（几何体精密度等）。   若对几何元件特殊参数有要求的用户，请参看 高级建模 &gt; 脚本建模 。   注意：  一般情况下，更加推荐用户 通过界面创建几何元件 。 ',title : '创建几何元件',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll.htm',name : 'help_model_shape_symbol_DShapeAll',body : '所有几何元件 元件分类 元件名称 元件说明 基础几何元件 长方体 长方体可用于生成最简单的基本几何体。包括长方体面板、立方体小块等。 圆柱体 圆柱体可用于生成截面为正圆或椭圆的实心或空心的柱形几何体。 球体 球体可用于生成具有厚度的完整球体或椭圆体。 几何球体 几何球体可用于生成基于正二十多面体制作的球体。 圆锥体 圆锥体可用于生成圆形圆锥体。 环体 圆环体可用于生成一个具有圆形截面的环。 扩展几何元件 实心旋转体 实心旋转体可用于生成基于外形线旋转一周形成的对称几何体。 空心旋转体 空心旋转体可用于生成基于给定表面旋转一定角度形成的几何体。 参数扫描体 参数扫描体可用于生成基于给定平面和变换矩阵参数构造的几何体。 垂直拉伸体 垂直拉伸体支持对给定的平面进行垂直拉伸建模。可用于构造棱柱等几何体。 导入CAD模型 导入CAD模型支持从外部导入常见CAD格式模型。 强制网格面 强制网格可在所指定的关键网格位置强制生成网格体或网格面或网格线，并加密周围网格。 多层物体 多层物体支持对给定的表面按照特定方向生长多层材料的建模。 天线罩 EastWave V7 根据常用天线罩形线预定义了内置天线罩模型，用户使用时只需输入模型所对应的外形线参数。 阵列 阵列用于设计基于某种元件，按照指定的空间排布生成的阵列结构或阵列激励源。 ',title : '所有几何元件',flags : 0,children : [{file:'./data/help_model_shape_symbol_DShapeAll_DShapeBase.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeBase',body : '基础几何元件 基础几何元件就是现实世界中常见的各种物体，例如大而窄的长方体面板、小钢珠等。用户可以通过对多个基础几何元件进行组合的方式来建立复杂模型。 基础几何元件集合 长方体  长方体可用于生成最简单的基本几何体。包括长方体面板、立方体小块等。 圆柱体  圆柱体可用于生成截面为正圆或椭圆的实心或空心的柱形几何体。 球体  球体可用于生成具有厚度的完整球体或椭圆体。 几何球体  几何球体可用于生成基于正二十多面体制作的球体。 圆锥体  圆锥体可用于生成圆形圆锥体。 环体  圆环体可用于生成一个具有圆形截面的环。 ',title : '基础几何元件 ',flags : 0,children : [{file:'./data/help_model_shape_symbol_DShapeAll_DShapeBase_DShapeCube.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeBase_DShapeCube',body : '长方体 长方体可用于生成最简单的基本几何体。包括长方体面板、立方体小块等。 定义方式 定义方式 中心（中心点——长宽高） 边（左下前角点——右上后角点） 属性对话框 参数含义 参数名称 说明 备注 中心点  指定长方体中心点的坐标 - 长宽高  指定长方体的长度、宽度、高度 - 参数 说明 备注 左下前角点  指定长方体的左下前角点坐标 - 右上后角点 指定长方体的右上后角点坐标 - 示意图 如何创建长方体 界面创建长方体 脚本创建长方体   ',title : '长方体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeBase_DShapeCylinder.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeBase_DShapeCylinder',body : '圆柱体 圆柱体可用于生成截面为正圆或椭圆的实心或空心的柱形几何体。 定义方式 定义方式 体中心（体中心——长宽高） 底面中心（面中心——高度） 属性对话框 参数含义 参数名称 说明 备注 边数 指定圆柱体的切割份数 越高越精密 体空心比 指定圆柱体的体空心比率 取值范围0.0~1.0 体中心 指定圆柱体中心点的坐标 - 长宽高 指定圆柱体的长度、宽度、高度 - 参数 说明 备注 边数 指定圆柱体的切割份数 越高越精密 体空心比 指定圆柱体的体空心比率 取值范围0.0~1.0 底面中心 指定圆柱体底面中心的坐标 X、Y两个方向 底面半径 指定底面圆的半径 X、Y方向的长度 高度 指定圆柱体的高度 - 示意图 如何创建圆柱体 界面创建圆柱体 脚本创建圆柱体   ',title : '圆柱体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeBase_DShapeSphere.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeBase_DShapeSphere',body : '球体 球体可用于生成具有厚度的完整球体或椭圆体。 定义方式 球中心——三维半径 属性对话框 参数含义 参数名称 说明 备注 体中心 指定球体中心点的坐标 - 三维半径 指定球体X、Y、Z三个方向上的半径 - 厚度 指定球体表面的厚度 厚度为0时，球体为实心 纵向层数 指定球体的纵向切割份数 - 横向片数 指定球体的横向切割份数 - 示意图 如何创建球体 界面创建球体 脚本创建球体 ',title : '球体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeBase_DShapeGeoSphere.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeBase_DShapeGeoSphere',body : '几何球体 几何球体可用于生成基于正二十多面体制作的球体。 定义方式 球中心——三维半径 属性对话框 参数含义 参数名称 说明 备注 体中心 指定几何球体中心点的坐标 - 三维半径 指定几何球体X、Y、Z三个方向上的半径 - 段数 指定几何球体的段数 段数越高则越接近规则球体 示意图 如何创建几何球体 界面创建几何球体 脚本创建几何球体 ',title : '几何球体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeBase_DShapeCone.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeBase_DShapeCone',body : '圆锥体 圆锥体可用于生成圆形圆锥体。 定义方式 底面半径——高 属性对话框 参数含义 参数名称 说明 备注 边数 指定圆锥体底部圆的边数 边数越高越接近圆 高度 指定圆锥体高度 - 底面半径 指定圆锥体底面的二维（X、Y）坐标 - 示意图 如何创建圆锥体 界面创建圆锥体 脚本创建圆锥体 ',title : '圆锥体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeBase_DShapeTorus.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeBase_DShapeTorus',body : '环体 环体可用于生成一个具有圆形截面的环。 定义方式 外环半径——圆母线半径 属性对话框 参数含义 参数名称 说明 备注 环半径 指定环体的外环半径 - 环段数 指定环体的段数 - 圆半径 指定环体圆母线半径 - 圆边数 指定环体圆母线边数 - 示意图 如何创建环体 界面创建环体 脚本创建环体 ',title : '环体',flags : 0,children : []}]},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt',body : '扩展几何元件 扩展几何元件是 EastWave V7 中复杂几何元件的集合。包括各种旋转对称体、天线罩、阵列等。 扩展几何元件集合 实心旋转体  实心旋转体可用于生成基于外形线旋转一周制作的对称几何体。 空心旋转体  空心旋转体可用于生成基于闭合线（外形线以及内形线）旋转给定角度形成的几何体。 参数扫描体  参数扫描体可用于生成基于给定平面和变换矩阵参数制作的几何体。 垂直拉伸体  垂直拉伸体支持对给定的平面进行垂直拉伸建模。可用于构造棱柱等几何体。 导入CAD模型  导入CAD模型支持从外部导入常见CAD格式模型。 强制网格面  强制网格可在所指定的关键网格位置强制生成网格体或网格面或网格线，并加密周围网格。 多层物体  多层物体支持对给定的表面按照特定方向生长多层材料的建模。 天线罩  EastWave V7 根据常用天线罩形线预定义了内置天线罩模型，用户使用时只需输入模型所对应的外形线参数。 阵列  阵列用于设计基于某种元件，按照指定的空间排布生成的阵列结构或阵列激励源。 ',title : '扩展几何元件 ',flags : 0,children : [{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt_DShapeSpin.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt_DShapeSpin',body : '实心旋转体 实心旋转体可用于生成基于外形线旋转一周形成的对称几何体。 定义方式 外形线——底面半径 属性对话框 参数含义 参数名称 说明 备注 外形线 指定实心旋转体的外形线方程 (_x-100.0)*tan(120.0/180.0*3.14159) 底面半径步长 指定实心旋转体半径的步长 用于构造圆滑曲线 底面半径 指定实心旋转体的半径 - 反转 是否反转表面 - 示意图 如何创建实心旋转体 界面创建实心旋转体 脚本创建实心旋转体 ',title : '实心旋转体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt_DShapeSpin2.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt_DShapeSpin2',body : '空心旋转体 空心旋转体可用于生成基于给定表面旋转一定角度形成的几何体。  定义方式 旋转表面——旋转角度 属性对话框 参数含义 参数名称 说明 备注 引用表面 指定空心旋转体的待旋转表面 可引用内部二维平面或导入的STL平面 起始角度 指定实心旋转体的旋转起始角度 角度制 终止角度 指定实心旋转体的旋转终止角度 角度制 反转 是否反转表面 - 示意图 如何创建空心旋转体 界面创建空心旋转体 脚本创建空心旋转体 ',title : '空心旋转体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt_DShapeSweeped.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt_DShapeSweeped',body : '参数扫描体 参数扫描体可用于生成基于给定平面和变换矩阵参数构造的几何体。  定义方式 中心——坐标变换矩阵 属性对话框 参数含义 参数名称 说明 备注 待旋转表面 指定参数扫描体的待旋转表面 可引用内部二维平面或导入的STL平面  扫描表达式 指定参数扫描体的扫描长度以及间隔 例如： 0：1：30 中心表达式 指定参数扫描体的中心表达式 中心有X、Y、Z三个维度 变换矩阵表达式 指定参数扫描体的变换矩阵表达式 T(transformation matrix) u2x v2x n2x 0 u2y v2y n2y 0 u2z v2z n2z 0 0 0 0 1 反转 是否反转表面 - 示意图 如何创建参数扫描体 界面创建参数扫描体 脚本创建参数扫描体 ',title : '参数扫描体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt_DShapeColumn.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt_DShapeColumn',body : '垂直拉伸体 垂直拉伸体支持对给定的平面进行垂直拉伸建模。可用于构造棱柱等几何体。  定义方式 引用表面——拉伸高度 属性对话框 参数含义 参数名称 说明 备注 待拉伸表面 指定垂直拉伸体的待拉伸表面 可引用内部二维平面或导入的STL平面  垂直拉伸高度 指定垂直拉伸体的高度 高度为负值时反向拉伸 示意图 如何创建参数扫描体 界面创建垂直拉伸体 脚本创建垂直拉伸体 ',title : '垂直拉伸体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt_DShapeStl.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt_DShapeStl',body : '导入CAD模型 导入CAD模型支持从外部导入常见CAD格式模型。  定义方式 导入模型 STL文件格式 参数含义 参数名称 说明 备注 文件路径 指定导入CAD模型的文件路径 STL格式  分块载入 超大型文件内存不足以一次性加载模型时，可通过分块载入导入CAD模型 - 如何导入CAD模型 界面导入CAD模型 脚本导入CAD模型 ',title : '导入CAD模型',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt_DShapeForcedMesh.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt_DShapeForcedMesh',body : '强制网格 强制网格可在所指定的关键网格位置强制生成网格体或网格面或网格线，并加密周围网格。  定义方式 中心——三维长度 属性对话框 参数含义 参数名称 说明 备注 平面类型 指定强制网格的类型 XY平面、YZ平面、ZX平面或BOX体（平面可退化为线）  中心 指定强制网格的中心位置 - 三维长度 指定X、Y、Z三个方向的长度 对应的平面会自动忽略不需要维度的长度量（例如XY平面会忽略Z方向长度） 示意图 如何创建强制网格 界面创建强制网格 脚本创建强制网格 ',title : '强制网格面',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt_DShapeSurfaceStretch.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt_DShapeSurfaceStretch',body : '多层物体 多层物体支持对给定的表面按照特定方向生长多层材料的建模。  定义方式 材料——厚度 属性对话框 参数含义 table 1: 多层物体（材料--厚度）参数说明表 参数名称 说明 备注 表面 指定多层物体的基础表面 支持导入STL格式的平面  材料 指定当前层的材料 - 厚度 指定当前层的厚度 - 示意图 如何创建多层物体 界面创建多层物体 脚本创建多层物体 ',title : '多层物体',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt_DShapeRadome.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt_DShapeRadome',body : '天线罩 EastWave V7 根据常用天线罩形线预定义了内置天线罩模型，用户使用时只需输入模型所对应的外形线参数。   为避免参数定义混乱，内置天线罩模型作如下约定：  天线罩厚度为表面切线的法向厚度，法向厚度等厚；  天线罩“头部朝向”默认朝向Z轴正方向（注意：天线罩相关计算模式约定将天线罩头部朝向Z轴正方向）；  天线罩分类 1. 尖锥（Conical）天线罩 2. 正切卵形（Tangent Ogive）天线罩 3. 球形鼻锥（Spherrically-blunted Cone）天线罩 4. 幂次形旋转体（Power Series）天线罩 1. 尖锥（Conical）天线罩 尖锥天线罩横截面示意图 尖锥天线罩参数设置对话框  尖锥天线罩参数含义 参数名称 说明 备注 厚度（T） 指定尖锥天线罩的厚度 -  半锥角（θ） 指定尖锥的半锥角 单位为角度 高度（H） 指定尖锥天线罩顶点到底面的高度 - 平移距离（D） 指定尖锥天线罩沿轴向平移的距离 轴向即天线罩头部的朝向 边数 指定尖锥天线罩的底面切割份数 - 如何创建尖锥天线罩 界面创建尖锥天线罩 脚本创建尖锥天线罩 2. 正切卵形（Tangent Ogive）天线罩 正切卵形天线罩横截面示意图 正切卵形天线罩参数设置对话框  正切卵形天线罩参数含义 参数名称 说明 备注 厚度（T） 指定正切卵形天线罩的厚度 -  半径（R） 指定正切卵形天线罩外形线（圆弧）的半径 外（内）形线即正切卵形天线罩的外（内）母线 它是一段圆弧，其圆心落在图中的横轴（灰色）上 宽度（W） 指定正切卵形天线罩外形线距离中轴线最远处的距离 - 高度（H） 指定正切卵形天线罩顶点到底面的高度 - 平移距离（D） 指定正切卵形天线罩沿轴向平移的距离 轴向即天线罩头部的朝向 边数 指定正切卵形天线罩的底面切割份数 - 如何创建正切卵形天线罩 界面创建正切卵形天线罩 脚本创建正切卵形天线罩 3. 球形鼻锥（Spherrically-blunted Cone）天线罩 球形鼻锥天线罩横截面示意图 球形鼻锥天线罩参数设置对话框  球形鼻锥天线罩参数含义 参数名称 说明 备注 厚度（T） 指定球形鼻锥天线罩的厚度 -  半径（R） 指定球形鼻锥天线罩头部球体的半径 - 半锥角（θ） 指定球形鼻锥天线罩的半锥角 单位为角度 高度（H） 指定球形鼻锥天线罩顶点到底面的高度 - 平移距离（D） 指定球形鼻锥天线罩沿轴向平移的距离 轴向即天线罩头部的朝向 边数 指定球形鼻锥天线罩的底面切割份数 - 如何创建球形鼻锥天线罩 界面创建球形鼻锥天线罩 脚本创建球形鼻锥天线罩 4. 幂次形旋转体（Power Series）天线罩 幂次形旋转体天线罩横截面示意图 幂次形旋转体天线罩参数设置对话框  幂次形旋转体天线罩参数含义 参数名称 说明 备注 厚度（T） 指定幂次形旋转体天线罩的厚度 -  半径（R） 指定幂次形旋转体天线罩底部的半径 - 系数（A） 指定幂函数 $y = A( frac{x}{B})^N $的系数A - 系数（B） 指定幂函数 $y = A( frac{x}{B})^N $的系数B - 指数（N） 指定幂函数 $y = A( frac{x}{B})^N $的指数N - 平移距离（D） 指定幂次形旋转体天线罩沿轴向平移的距离 轴向即天线罩头部的朝向 边数 指定幂次形旋转体天线罩的底面切割份数 - 如何创建幂次形旋转体天线罩 界面创建幂次形旋转体天线罩 脚本创建幂次形旋转体天线罩 ',title : '天线罩',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeAll_DShapeExt_DArray.htm',name : 'help_model_shape_symbol_DShapeAll_DShapeExt_DArray',body : '阵列 阵列用于设计基于某种元件，按照指定的空间排布生成的阵列结构或阵列激励源。  阵列分类 1. 圆周（Circle）阵列 2. 镜像（Mirror）阵列 3. 普通（Simple）阵列 4. 正交（Orthorhombic）阵列 5. 自由点（Free）阵列 6. 参数扫描（Expr）阵列 7. 三角（Trigonal）阵列 8. FSS天线罩（FSS）阵列 1. 圆周（Circle）阵列 圆周阵列示意图 圆周阵列参数设置对话框  圆周阵列参数含义 参数名称 说明 备注 待处理元件 指定圆周阵列中单元的元件信息 - 旋转半径 指定圆周阵列的旋转半径 以坐标原点为圆心  起始角度 指定圆周阵列的旋转起始角度 单位为角度 终止角度 指定圆周阵列的旋转终止角度 单位为角度 角度步长 指定圆周阵列的角度步长 单位为角度 自旋 指定圆周阵列的元件是否需要自旋 - 如何创建圆周阵列 界面创建圆周阵列 脚本创建圆周阵列 2. 镜像（Mirror）阵列 镜像阵列示意图 镜像阵列参数设置对话框  镜像阵列参数含义 参数名称 说明 备注 待处理元件 指定镜像阵列中单元的元件信息 - 镜面法向向量 指定镜像阵列镜面的法向向量 - 镜面所处位置 指定镜像阵列镜面的位置 - 如何创建镜像阵列 界面创建镜像阵列 脚本创建镜像阵列 3. 普通（Simple）阵列 普通阵列示意图 普通阵列参数设置对话框  普通阵列参数含义 table 1: 普通阵列参数说明表 参数名称 说明 备注 待处理元件 指定普通阵列中单元的元件信息 - 栅格范围 指定普通阵列的三维栅格范围 X、Y、Z三个维度的格子数 a1 指定普通阵列中元件在X维度的排列情况 a1有X、Y、Z三个方向的长度 a2 指定普通阵列中元件在Y维度的排列情况 a2有X、Y、Z三个方向的长度 a3 指定普通阵列中元件在Z维度的排列情况 a3有X、Y、Z三个方向的长度 如何创建普通阵列 界面创建普通阵列 脚本创建普通阵列 4. 正交（Orthorhombic）阵列 正交阵列示意图 正交阵列参数设置对话框  正交阵列参数含义 参数名称 说明 备注 待处理元件 指定正交阵列中单元的元件信息 - 栅格范围 指定正交阵列的三维栅格范围 X、Y、Z三个维度的格子数 元件间隔 指定正交阵列的元件间隔 X、Y、Z三个方向的间隔 如何创建正交阵列 界面创建正交阵列 脚本创建正交阵列 5. 自由点（Free）阵列 自由点阵列示意图 自由点阵列参数设置对话框  自由点阵列参数含义 参数名称 说明 备注 待处理元件 指定自由点阵列中单元的元件信息 - 离散点 指定自由点阵列中元件所在的位置集合（点） X、Y、Z三个维度 如何创建自由点阵列 界面创建自由点阵列 脚本创建自由点阵列 6. 参数扫描（Expr）阵列 参数扫描阵列示意图 参数扫描阵列参数设置对话框  参数扫描阵列参数含义 参数名称 说明 备注 待处理元件 指定参数扫描阵列中单元的元件信息 - t0、t1、t2 指定参数扫描阵列的三个参数值（范围以及步长） t0: 0:20:80 位置表达式 指定参数扫描阵列的位置表达式 X、Y、Z三个维度 如何创建参数扫描阵列 界面创建参数扫描阵列 脚本创建参数扫描阵列 7. 三角（Trigonal）阵列 三角阵列示意图 image 1: 三角阵列示意图 三角阵列参数设置对话框 image 2: 三角阵列参数设置对话框  三角阵列参数含义 参数名称 说明 备注 待处理元件 指定三角阵列中单元的元件信息 - 栅格范围 指定三角阵列的三维栅格范围 X、Y、Z三个维度的格子数 元件间隔 指定三角阵列的元件间隔 X、Y、Z三个方向的间隔 如何创建三角阵列 界面创建三角阵列 脚本创建三角阵列 8. FSS天线罩（FSS）阵列 FSS天线罩阵列示意图 image 3: FSS天线罩阵列示意图 FSS天线罩阵列参数设置对话框 image 4: FSS天线罩阵列参数设置对话框  FSS天线罩阵列参数含义 参数名称 说明 备注 待处理元件 指定FSS中单元的元件信息 - 待处理表面 指定待处理的FSS天线罩表面 - 六的倍数排列 指定每一层铺设的元件数量是否六的倍数 - Z轴对齐 指定是否按Z轴对齐 Z轴对齐：以Z为高度方向，每一层FSS单元位于等高线上 单元宽度 指定单元的二维宽度 X、Y两个方向的宽度 铺设范围H1 指定FSS单元铺设时的起始高度 - 铺设范围H2 指定FSS单元铺设时的终止高度 - 起始角度 指定FSS单元每一层铺设的起始角度 单位为角度 如何创建FSS天线罩阵列 界面创建FSS天线罩阵列 脚本创建FSS天线罩阵列 ',title : '阵列',flags : 0,children : []}]}]},{file:'./data/help_model_shape_symbol_DShapeDemo.htm',name : 'help_model_shape_symbol_DShapeDemo',body : '1. 长方体 Demo 2. 刻蚀结构 Demo 3. 变换矩阵 Demo ',title : '完整示例',flags : 0,children : [{file:'./data/help_model_shape_symbol_DShapeDemo_demo_cube.htm',name : 'help_model_shape_symbol_DShapeDemo_demo_cube',body : '长方体 Demo 创建一个中心坐标为(0, 10, 20)，长宽高分别为(30, 40, 50)立方体具体步骤： 在 EastWave V7 中打开 文件 菜单，然后选择 新建 &gt; 新建模型文档 以创建三维建模窗口。 在 EastWave V7 中打开 新建物体 菜单，选择 创建立方体 打开立方体 属性 对话框。 在 属性 对话框中，设置立方体 参数 ，其中中心坐标x、y、z分别输入0、10、20，长宽高分别输入30、40、50。 左键单击 确定 完成立方体的创建。 ',title : '长方体 Demo',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeDemo_demo_etching.htm',name : 'help_model_shape_symbol_DShapeDemo_demo_etching',body : '刻蚀结构 Demo EastWave V7 帮助文档提供了刻蚀结构的完整 Demo 以帮助用户更好的学习如何利用建模系统建立特定刻蚀结构。   该刻蚀结构的完整文档文件可以点击 刻蚀结构 Demo 文档 下载。 相关技术 创建 基础几何元件 导入 材料库中所需材料到计算工程文档 绑定 材料到几何元件 应用 变换矩阵 相关约定 几何元件本身 不包含材料信息、单位信息、变换矩阵信息 ，几何元件需要经过 DSymbolPtr 元件修饰后，才可以绑定上述各种信息。 几何元件不设置单位信息时，单位追随文档单位。 后建 几何元件 覆盖已建 几何元件和背景的 重叠区域材料 属性。 变换矩阵系统采用 局部坐标系系统 ，所有元件的坐标变换都是以元件 自身坐标系 为基础进行变换。 对修饰元件 DSymbolPtr 、 DSymbolGrp 、 DSymbolArr 、 DSymbolStk 进行 复制 操作时，其包含的子节点元件均采用 引用方式 进行复制。 若子节点元件需要使用 拷贝方式 进行复制，再对指定子节点元件进行一次 独特 操作即可。 &nbsp;&nbsp;备注 所有几何元件的初始坐标系与世界坐标系 完全重叠 。 引用方式 复制元件：复制后的元件和被复制的元件共享属性， 只需要修改一个元件的属性(如材料) ，其余所有以 引用方式 复制的元件的属性都会同步改变。  拷贝方式 后的元件：使用 独特 操作后的元件，解除其引用方式，无论如何修改该元件的属性，都只影响其自身，对其它元件无影响。 刻蚀结构最终模型截图 刻蚀结构创建步骤 步骤索引 导入材料库材料 创建Si材料长方体（最底部） 创建SiO2材料长方体（中间部分） 创建Y结构 创建X结构 一、导入材料库材料 在 EastWave V7 中打开 模型编辑器 菜单，然后选择 材料管理器 以打开三维建模窗口。选择相应的 Si 、 Si3N4 、 SiO2 材料， 导入 至需要计算的工程文档。 二、创建Si材料长方体（最底部） 最终效果图（红色高亮部分） 详细步骤 创建长方体几何元件  选中 模型树 窗口中的 显示 &gt; 模型 节点，右键打开菜单，选中 添加 &gt; 添加结构 打开几何元件创建界面，类型选择 DShapeCube ，参数设置如下图。 其中长方体中心为(0, 0, -400)，长宽高分别为(300, 200, 800)，元件名称为 Si_Cube 。 确定 完成长方体几何创建。 添加Si材料信息  选中上一步中创建完毕的长方体元件节点，打开其右键菜单，选中 修饰 。创建该长方体元件的修饰器元件 DSymbolPtr 。打开该 DSymbolPtr 的右键菜单并且选中 属性 打开其属性界面，设置其单位为 Si (Silicon) -Palik-0.2un-30um ，元件名称为 Si 。 确定 完成修饰器修改。 三、创建SiO2材料长方体（中间部分） 最终效果图（红色高亮部分） 详细步骤 创建长方体几何元件  参照步骤二，创建长方体。参数设置如下图。 其中长方体中心为(0, 0, 50)，长宽高分别为(300, 200, 100)，元件名称为 SiO2_Cube 。 添加SiO2材料  参照步骤二，为几何元件添加修饰器 DSymbolPtr ，添加 SiO2 材料信息，并修改其属性设置如下图。 四、创建Y结构 最终效果图（红色高亮部分以及蓝灰夹层部分） 详细步骤 添加外层长方体几何元件，长方体属性为 中心(0, 0, 200)，长宽高(300, 33, 200)，名称 Spacer 。 并在该长方体元件上添加一层修饰器 DSymbolPtr ，属性为 材料 Si3N4 ，名称 Si3N4_Spacer 。 得到如下结构（蓝色部分）： 添加内嵌长方体几何元件，长方体属性为 中心(0, 0, 175)，长宽高(300.1, 21, 150)，名称 Poly 。 并在该长方体元件上添加一层修饰器 DSymbolPtr ，属性为 材料 Si ，名称 Si_Poly 。 得到如下结构（红色部分，内嵌于Spacer中）： 在 模型树 窗口中，同时选中 Si3N4_Spacer 、 Si_Poly 节点，右键打开菜单，选择 组合 ，得到 DSymbolGrp 组修饰器。 右键打开新得到的 DSymbolGrp 节点，打开其 属性 界面，修改其名字为 Y+75nm ，并进行坐标变换。从图中可以看出，我们将该几何元件组 往Y轴正方向进行了 75nm 的平移。 选中平移后的几何元件组 Y+75nm 节点，右键打开菜单选择 复制 ，得到 Y+75nm 元件组的 深度拷贝 。打开新得到的复制品 Y+75nm_1 属性界面，改名为 Y+25nm 我们可以 看到上个步骤中的坐标平移变换依然存在，我们只需要在这基础上往Y轴负方向平移 50nm 即可。 重复 复制 &gt; 坐标变换 的操作，最终我们可以得到四个完整的Y结构体。 总结，各 DSymbolGrp 几何元件组最终坐标变换情况 几何元件组名称 坐标变换矩阵 Y+75nm 平移 - Y轴正方向 - 75 Y+25nm 平移 - Y轴正方向 - 75 平移 - Y轴负方向 - 50 Y-25nm 平移 - Y轴正方向 - 75 平移 - Y轴负方向 - 50 平移 - Y轴负方向 - 50 Y-75nm 平移 - Y轴正方向 - 75 平移 - Y轴负方向 - 50 平移 - Y轴负方向 - 50 平移 - Y轴负方向 - 50 五、创建X结构 最终效果图（红色高亮部分） 详细步骤 添加梯形体  建立X结构的底部梯形体部分，可以使用 EastWave V7 提供的 DShapeColumn 拉伸体建模工具。 模型 节点右键菜单， 添加 &gt; 添加结构 ，选中 DShapeColumn 类型。点击 引用表面 下拉框，选择 新建结构 ，弹出的界面即为 二维几何体创建界面 ， 选中 DShapePoly 类型创建多边形。参数如下图所示，给出一个二维平面的梯形。设置好参数后，点击 确定 按钮返回 DShapeColumn 属性界面。其中梯形体名称为 X-1 structure bottom 。 在 DShapeColumn 属性界面输入XY平面几何往Z轴正方向拉伸高度 200.1 。点击 确定 按钮，即可生成梯形体结构。 得到的梯形体如下图所示（红色高亮部分） 往新建的梯形体添加顶部长方体  新建好的梯形体，梯形面位于XY平面。后续还需要将该梯形体进行坐标变换才能转换到我们所需的位置。不过在进行坐标变换之前，我们应该先添加其顶部长方体， 把顶部的长方体和底部的梯形体捆绑为一个 DSymbolGrp 几何元件组，最后才进行统一的坐标变换。  模型 节点右键菜单， 添加 &gt; 添加结构 ，选中 DShapeCube ，选中 类型下拉框 的 边 选项，以角点的方式构造长方体。我们只需给定左下前角点(-5, 100, 0) 以及右上后角点(5, 200, 200.1)即可把长宽高分别为(10, 100, 200.1)的长方体添加到梯形体的顶部。其中顶部长方体名称为 X-1 structure top 。 得到的顶部长方体如下图所示（红色高亮部分） 捆绑梯形以及顶部长方体并进行坐标变换 模型树 窗口中，同时选中 X-1 structure bottom 和 X-1 structure top 节点，右键打开菜单，选中 组合 得到 DSymbolGrp 几何元件组。 打开新得到的 DSymbolGrp 几何元件组的属性界面。命名为 X-1 structure_0 ，设置材料为 Si 材料，并且添加坐标变换，绕X轴逆时针旋转90度。得到如下图结构。 上个步骤中， X-1 structure_0 几何元件组绕X轴逆时针旋转90度后，几何元件组的自身坐标系已经发生了变换，其X轴正方向仍然与世界坐标系X轴正方向重叠， 但其Y轴正方向与世界坐标系的Z轴正方向重叠，其Z轴正方向与世界坐标系的Y轴负方向重叠。 因此，若要把 X-1 structure_0 几何元件组 底面中心 移至与 世界坐标系的原点 重合。实际上就是往自身坐标系的Z轴负方向平移 100.05nm 距离。 再把 X-1 structure_0 几何元件组往自身坐标系X方向移动 135nm 即可得到最终的 X-1 structure_0 结构。 通过 复制 操作，创建其它 X-1 structure 选中 X-1 structure_0 节点，右键打开菜单选择 复制 ，得到 X-1 structure_1 ，继续沿X轴负方向移动 30nm 即可得到最终的 X-1 structure_1 。 选中 X-1 structure_1 节点，右键打开菜单选择 复制 ，得到 X-1 structure_2 ，继续沿X轴负方向移动 60nm 即可得到最终的 X-1 structure_2 。 选中 X-1 structure_1 节点，右键打开菜单选择 复制 ，得到 X-1 structure_3 ，继续沿X轴负方向移动 60nm 即可得到最终的 X-1 structure_3 。 选中 X-1 structure_1 节点，右键打开菜单选择 复制 ，得到 X-1 structure_4 ，继续沿X轴负方向移动 30nm 即可得到最终的 X-1 structure_4 。 选中 X-1 structure_1 节点，右键打开菜单选择 复制 ，得到 X-1 structure_5 ，继续沿X轴负方向移动 60nm 即可得到最终的 X-1 structure_5 。 选中 X-1 structure_1 节点，右键打开菜单选择 复制 ，得到 X-1 structure_6 ，继续沿X轴负方向移动 30nm 即可得到最终的 X-1 structure_6 。 最终得到的 X-1 结构如下图所示 &nbsp;&nbsp;提醒 以上演示的坐标变换步骤只是获得最终结构体的众多方法中的其中一种，用户也可以通过其它的平移、旋转和缩放的变换组合得到最终结构体。 &nbsp;&nbsp;几何结构体说明 边定义方式的长方体： 用户提供左下前角点以及右上后角点，即可构造出规则的长方体结构。 垂直拉伸体： 一种高级建模工具，用户只需提供一个XY平面的引用表面以及提供往Z轴正方向拉伸的高度，即可生成稍微复杂的几何结构体。 ',title : '刻蚀结构 Demo',flags : 0,children : []},{file:'./data/help_model_shape_symbol_DShapeDemo_demo_transform.htm',name : 'help_model_shape_symbol_DShapeDemo_demo_transform',body : 'empty page ',title : '变换矩阵 Demo',flags : 0,children : []}]}]},{file:'./data/help_model_material_symbol.htm',name : 'help_model_material_symbol',body : '材料元件 EastWave 的材料元件采用具有严格意义的物理模型，可支持几乎所有的电磁/光电材料，包括电介质材料、金属材料、各向异性材料、激光材料、磁性材料等。 如果面对的是一种全新的材料，只要有实测的宽频色散曲线，EastWave 就可利用内部引擎进行 色散自动拟合 ，进行稳定的 FDTD 求解。 如何创建材料元件 界面创建材料元件（推荐）  脚本创建材料元件（高级建模） 如何从材料库导入材料元件至工程 打开材料库界面后，选中目标材料元件，点击 导入至当前工程 即可。具体操作，请参看 材料库导入材料元件 ， 如何拟合生成材料元件 材料拟合工具集成于材料库中，需要通过材料库的 拟合生成功能 才可以打开拟合工具。拟合生成材料元件的具体步骤，请参看 拟合生成材料元件 。 所有材料元件 材料类别表 材料类别  特点  备注  普通材料  具有常数的$ varepsilon$、$ mu$、$ sigma_e$和$ sigma_m$   洛仑兹材料  具备洛仑兹色散关系的材料   空间相关材料  物理属性与空间分布有关的材料   涂敷材料  用来定义薄板或者物体表面加油指定厚度或者电磁属性的材料  多层材料和阻抗材料  ',title : '材料元件',flags : 0,children : [{file:'./data/help_model_material_symbol_DMaterialCreate.htm',name : 'help_model_material_symbol_DMaterialCreate',body : 'empty page ',title : '创建材料元件',flags : 0,children : []},{file:'./data/help_model_material_symbol_material_depot.htm',name : 'help_model_material_symbol_material_depot',body : '材料库管理器 EastWave V7 中提供了材料库管理器，便于用户对不同材料进行系统的管理。   &nbsp;&nbsp;注意 材料库管理器中的材料元件，必须先 导入到需要计算的工程文档 ，才能在工程文档中使用。 材料库管理器界面 材料库分类 EastWave V7 材料库按类型分为 系统材料库 和 自定义材料库 。  系统材料库：系统预置材料库，命名以 system_ 开头，包含常见的微波材料及光学材料，用户不可修改系统库中任何材料的属性。 自定义材料库：用户根据自己的需求创建的材料库，用于存储用户自行创建的材料。 材料库管理 材料库 右键菜单： 新建材料库：创建新的材料库。 导入材料库：从外部导入已存在的材料库。 系统材料库 右键菜单： 导出材料库：导出指定材料库到外部。 用户材料库 右键菜单： 新建材料：创建新的材料元件。相关主题： 材料元件 。 拟合生成材料：将通过实验测的材料数据转换成软件能够识别的材料模型。相关主题： 材料拟合工具 。 重命名材料库：对已创建的材料库重命名。 导出材料库：导出指定材料库到外部。 删除材料库：删除指定材料库。 材料管理 材料 节点右键菜单： 导入材料至当前工程：把指定材料导入到当前工程文档。 色散曲线：绘制出当前选中材料的色散曲线。 删除材料：从材料库中删除指定材料。 属性：打开当前选中材料的属性界面。 材料拟合工具 EastWave V7 中的材料拟合工具可用于将通过实验测的材料数据转换成软件能够识别的材料模型。具体使用，请参看 拟合生成材料元件 。 ',title : '材料库导入材料元件',flags : 0,children : []},{file:'./data/help_model_material_symbol_material_fitting.htm',name : 'help_model_material_symbol_material_fitting',body : '拟合生成材料元件 EastWave V7 中的材料拟合工具可用于将通过实验测的材料数据转换成软件能够识别的材料模型。 材料拟合工具界面 材料拟合工具参数说明 参数名称 说明 文件 含有实测材料数据信息的文本文件。 文本中数据存储的格式包含三列数据： 第一列为频率信息； 第二列为材料介电常数实部信息； 第三列为材料介电常数虚部信息。 最小频率 指定实际拟合的频率（可选择单位）范围。 最大频率 振子个数 指定拟合模型中采用的振子个数。 虚部权重 指定拟合过程中优先考虑实部还是优先考虑虚部。 优先选项 指定拟合过程中优先考虑精度还是优先考虑速度。 是否有电导率 指定拟合目标模型中是否带有电导率项。 拟合进度 显示当前拟合的进行情况。 材料拟合工具使用步骤 原始数据  载入实测数据，选择实际拟合区间。 设置拟合参数  在载入待拟合实测数据，并指定完需要拟合的频段后，设置振子个数、虚部权重等拟合参数。 执行拟合  在拟合开始后，用户可以选择让拟合进程到达100%后自动终止，也可以通过观察上方的拟合曲线结果，若结果符合用户精度要求，用户可手动“终止拟合”。 导入材料  点击“确定”按钮，即可将拟合生成的材料导入指定的材料库中。 ',title : '拟合生成材料元件',flags : 0,children : []},{file:'./data/help_model_material_symbol_material_class.htm',name : 'help_model_material_symbol_material_class',body : '所有材料元件 EastWave 中，材料作为元件进行定义。赋予了材料的 几何元件 成为 物理元件 。  材料属性 显示属性 颜色 透明度 反射方式 绘制方式（线框模型、面模型、纹理） 基本电属性 $ varepsilon$、$ sigma_e$ $ mu$、$ sigma_m$ 高级属性 由材料的物理模型决定参数 其他物理参数 其他参数 材料类型 材料类别表 材料类别  特点  备注  普通材料  具有常数的$ varepsilon$、$ mu$、$ sigma_e$和$ sigma_m$   洛仑兹材料  具备洛仑兹色散关系的材料   空间相关材料  物理属性与空间分布有关的材料   涂敷材料  用来定义薄板或者物体表面加油指定厚度或者电磁属性的材料  多层材料和阻抗材料  &nbsp;&nbsp;常用 EastWave 提供了三种默认材料，其中的 vacuum 和 pec 两种材料在大多数电磁波工程仿真中会用到。 相关主题： 物理元件 ',title : '所有材料元件',flags : 0,children : [{file:'./data/help_model_material_symbol_material_class_common.htm',name : 'help_model_material_symbol_material_class_common',body : '材料公共属性 光电材料的频域电磁性质由复介电系数$ epsilon( omega)$和复磁导率$ mu( omega)$决定的。 介质的损耗、色散、吸收、增益、非线性等特性均可以通过$ epsilon( omega)$和$ mu( omega)$来描述， EastWave根据严格的物理模型，内建了描述各种不同材料不同特性的介电系数和磁导率模型， 并提供了灵活直观的设置方式，完美支持模拟计算各种材料的电磁学特性。 EastWave中，材料作为元件进行定义。赋予了材料的 几何元件 成为 物理元件 。 材料公共参数设置对话框如下图所示： 材料复介电系数$ epsilon( omega)$和复磁导率$ mu( omega)$包含公共部分： $$ epsilon( omega)= epsilon_ infty+i frac{ sigma_{e}}{ omega}$$ $$ mu( omega)= mu_ infty+i frac{ sigma_{m}}{ omega}$$ 其中$ sigma_{e}$和$ sigma_{m}$代表材料电损耗和磁损耗；  EastWave材料公共属性说明： 材料公共属性 参数  说明  备注  名称  材料名称   单位  材料参数的单位 EastWave的材料在设置时可以同时设置单位，若此处不设置单位，则材料的参数单位为文档单位； 类型  材料类型可选普通材料、各种色散材料   颜色  材料在模型中的颜色   sg_compatible  用来定义$ sigma_{e}$和$ sigma_{m}$的单位  当此选项勾选时，$ sigma_{e}$和$ sigma_{m}$单位为国际单位， 即$S/m$和$1/Sm$;当为勾选时， $ sigma_{e}$和$ sigma_{m}$ 重新定义为满足$ frac{ sigma_e}{f_{e}}=1$ 和$ frac{ sigma_m}{f_{m}}$=1 的频率值，该频率单位和材料其它参数单位规则相同。  EastWave提供了三种默认材料，在大多数电磁波工程仿真中会用到其中的 vacuum 和 pec 两种材料。 &nbsp;&nbsp;注意 材料参数单位只与材料属性中的单位和文档单位相关，当材料属性中未定义文档时，材料参数单位参考文档单位； sg_compatible选中时，只影响$ sigma_e$和$ sigma_m$，材料其余参数不受影响。  相关主题： 物理元件 ',title : '公共属性',flags : 0,children : []},{file:'./data/help_model_material_symbol_material_class_Debye.htm',name : 'help_model_material_symbol_material_class_Debye',body : '德拜材料 德拜色散模型常用于模拟各种金属的色散特性，其表达式如下： $$ epsilon( omega)= epsilon_ infty+i frac{ sigma_{e}}{ omega}+ sum frac{ Delta epsilon}{1-i omega tau_{e}} $$ $$ mu( omega)= mu_ infty+i frac{ sigma_{m}}{ omega}+ sum frac{ Delta mu}{1-i omega tau_{m}} $$ 其中磁导率德拜色散部分尚未开放 ； 德拜色散模型材料参数设置如下： 参数含义如下： 洛伦兹材料参数 参数名称  说明  备注  $f_{a}$、$f^{"}_{a}$  谐振频率$f_{a}= omega_{a}/2 pi$  单位为材料单位，若无材料单位则为文档单位 $f_{c}$、$f^{"}_{c}$  阻尼频率$f_{c}= omega_{c}/2 pi$  $f_{p}$、$f^{"}_{p}$  等离子体谐振频率$f_{p}= omega_{p}/2 pi$  相关主题： 物理元件 ',title : '德拜材料',flags : 0,children : []},{file:'./data/help_model_material_symbol_material_class_Lorentz.htm',name : 'help_model_material_symbol_material_class_Lorentz',body : '洛伦兹材料 $$ epsilon( omega)= epsilon_ infty+i frac{ sigma_{e}}{ omega}+ sum_{i=1}^n frac{(2 pi f_{p,i})^2}{(2 pi f_{a,i})^2-i omega(2 pi f_{c,i})- omega^2} $$ $$ mu( omega)= mu_ infty+i frac{ sigma_{m}}{ omega}+ sum_{i=1}^n frac{(2 pi f^{"}_{p,i})^2}{(2 pi f^{"}_{a,i})^2-i omega(2 pi f^{"}_{c,i})- omega^2} $$洛伦兹(Lorentz)色散模型涵盖了所有电磁色散模型，其中$f_{p,i}$表示第i个谐振子的等离子体频率，$f_{a,i}$表示第i个谐振子的谐振角频率，$f_{c,i}$表示第i个谐振子的阻尼频率。 其中磁导率洛伦兹色散部分尚未开放 ； 洛伦兹色散模型材料参数设置如下： 参数含义如下： 洛伦兹材料参数 参数名称  说明  备注  $f_{a}$、$f^{"}_{a}$  谐振频率$f_{a}= omega_{a}/2 pi$  单位为材料单位，若无材料单位则为文档单位 $f_{c}$、$f^{"}_{c}$  阻尼频率$f_{c}= omega_{c}/2 pi$  $f_{p}$、$f^{"}_{p}$  等离子体谐振频率$f_{p}= omega_{p}/2 pi$  相关主题： 物理元件 ',title : '洛伦兹材料',flags : 0,children : []}]}]},{file:'./data/help_model_Conformal.htm',name : 'help_model_Conformal',body : '共形技术 为了解决FDTD的Yee网格所产生的阶梯误差，新版中加入了修改FDTD基本迭代式或修改网格场量材料属性的共形技术。 新版共形分为PEC（PMC）共形和材料（除PEC（PMC）以外的无色散材料和色散材料）共形。具体设置界面如下： 选项 描述 备注 PEC共形级别 关闭：不启用,场量材料属性由场量所在位置的材料决定 级别1：线段中有PEC材料，则认为整段是PEC材料 级别2：线段中只允许一段非PEC材料，不满足的情况下根据具体情况退化为一段或填充为PEC 级别3：线段中允许有两段非PEC材料 PMC共形级别 关闭：不启用,场量材料属性由场量所在位置的材料决定 级别1：线段中有PMC材料，则认为整段是PMC材料 级别2：线段中只允许一段非PMC材料，不满足的情况下根据具体情况退化为一段或填充为PMC 级别3：线段中允许有两段非PMC材料 非PEC(PMC)材料共形 材料线策略 普通材料线策略选项，包括：无（不开启普通材料线共形）、线分段（材料分段策略）、线平均（材料参数按长度比例几何平均） 精度要求高时建议采用 线分段 策略  材料面策略 普通材料面策略选项，包括：无（不开启普通材料面共形）、平均（材料参数几何平均） 面共形的平均策略和线共形平均策略类似，都是材料参数的几何平均，线共形按网格线段中的材料长度比例平均，面共形按照回路中材料面积比例平均  SC策略 SC共形精度值决定共形的精度，值越小时间步越接近Courant时间步，同时精度越低 SC共形精度值必须大于等于0，小于0时SC策略失效 &nbsp;&nbsp;注意 非PEC(PMC)材料共形只有在PEC和PMC共形开启时才开启，即使计算结构内无PEC、PMC也必须开启PEC和PMC共形 才能使用材料共形。 SC策略 PEC(PMC)共形会造成时间步的严重下降，会急剧增加计算时间。SC策略通过牺牲一定计算精度， 使得计算的时间步保持在一个可容忍的范围。SC基于Dey-Mittra共形技术，但对某些共形线段的 长度数据进行更改，从而避免时间步的减小。下面以PEC共形为例介绍SC策略基本原理: 对PEC部分填充的网格，求得非PEC所占比例。即对网格面，求得非PEC所占的面积与该网格面积的比例； 对于网格线段，求得非PEC部分的线段长度与该网格线段长度的比例。以 图 为例我们将非PEC线段和面积占比分别用 $r_{l1}$、$r_{l2}$、$r_{l3}$和$r_s$表示，当$r_l$与$r_s$比值过大时，容易使得计算不稳定，必须减小时间步。 为了在保持一定精度下，使得时间步更为接近$dt_{courant}$，非PEC线段比例$r_{ln}$将按$r^{new}_{ln}=min⁡(2SC_{eff}r_{s},r_{ln} )$ 重新调整为$r^{new}_{ln}$，其中$SC_{eff}$即为SC精度值； 可以看到$SC_{eff}$值必须大于等于0才有意义，当$SC_{eff}$很大时，不会对Dey-Mittra的PEC共形做任何 更高，此时计算精度最高，但时间步会减小；$SC_{eff}$一般建议取2至3。 ',title : '共形技术',flags : 0,children : []},{file:'./data/help_model_physical_symbol.htm',name : 'help_model_physical_symbol',body : '物理元件 物理元件（通俗的可以理解为“物体”）是赋予了材料属性的几何元件，同时物理元件可以在坐标系中进行一系列的坐标变换。 "align=left" 物理元件的参数定义如下表： 物理元件参数表 参数  参数类型  参数分类  说明  几何元件  元件引用  基本参数   材料  材料引用  基本参数   坐标变换  坐标变换列表  高级参数   局部网格  局部网格参数  高级参数   单位集  单位参数  杂项   相关主题 几何元件 材料元件 活动组 ',title : '物理元件',flags : 0,children : []},{file:'./data/help_model_source_symbol.htm',name : 'help_model_source_symbol',body : '激励源 激励源是可以向仿真计算区域的场区产生激励作用的元件。 偶极子 偶极子是模拟无限小的电偶极子对场区激励的作用。偶极子参数见下表： 偶极子参数集 参数  参数类型  说明  信号  时间函数引用   强度  表达式  浮点数  延迟  表达式  浮点数  偶极类型  选项  电偶极子、磁偶极子  坐标  三坐标表达式   极化矢量  三坐标表达式  单位矢量  极化按全局坐标系定义  开关   平面波 平面波是模拟无限远处向场区辐射一个电磁波的激励源。平面波参数如下： 平面波参数集 参数  参数类型  说明  信号  时间函数引用   入射方向  选项  按雷达方位或波矢方向  球坐标系模式  选项  选择球坐标系模式  入射波$ theta$  表达式  设置$ theta$数值，单值  入射波$ phi$  表达式  设置$ phi$数值，单值  入射波极化  表达式  设置极化角  平面波杂项设置如下： 平面波杂项设置 参数  参数类型  说明  自动设置区域  开关   总场区域延展空间  表达式  总场区域和物体框 BBox 的距离  区域上下界  表达式  设定区域的上下界（自定义时有效） 强度  表达式  设定附加的强度  延迟  表达式  设定附加延迟  背景材料  材料引用  在介质中激励时使用  启用数值色散修正  开关  启用数值色散修正  数值色散修正参考频率  表达式  正数时为修正的参考频率，否则自动设置 设置窗口如下： image 1: 平面波设置 image 2: 平面波杂项设置 补充说明： 默认情况下的平面波的区域参数是根据物体包围框自动推算得到的，通常设定为包围框扩大$ dfrac{ lambda}{4}$的范围。 场源 场源是模拟一个通过一个口径向场区辐射电磁波信号的一种激励源。场源参数如下： 场源基本设置 参数  参数类型  说明  信号  时间函数引用   空间分布  空间函数引用   口径方向  选项  正方向/负方向  口径轮廓类型  选项  定义轮廓的方式  轮廓形状  引用  指定一个二维平面图形  口径宽度  二坐标表达式   口径中心  三坐标表达式   补充说明： 修改口径的朝向、口径平面位置不会对口径重心在全局的实际位置产生影响。在没有其他修饰器（Decorator）对场源修饰的情况下，口径的中心即全局坐标。 场源支持 导入口面场 点击空间分布参数下拉框中的 新建 按钮，在弹出的对话框中选择导入数据即可。具体参看 导入口面场 。 高斯分布 点击空间分布参数下拉框中的 新建 按钮，在弹出的对话框中选择高斯分布即可。具体参看 高斯分布 。 高斯波束 点击空间分布参数下拉框中的 新建 按钮，在弹出的对话框中选择高斯波束即可。具体参看 高斯波束 。 口径场 点击空间分布参数下拉框中的 新建 按钮，在弹出的对话框中选择口径分布即可。具体参看 口径场 。 相关阅读： 文档函数 活动组 ',title : '激励源元件',flags : 0,children : []},{file:'./data/help_model_monitor_symbol.htm',name : 'help_model_monitor_symbol',body : '监视器 EastWave提供监视器对仿真数据进行记录和分析。主要提供下列几种监视器：  场监视点 ：类似于旧版中的“点记录器”，记录指定位置（在计算区域之内）的场 场记录器 区域场监视器 区域场监视器（频域） 区域场监视器（时域） 表面场监视器 表面场监视器（频域） 表面场监视器（时域） 远场监视器 远场记录器（频域） 远场记录器（时域） 表面场监视器 补充说明： 准远场推算功能集成在对应的远场监视器 ',title : '监视器元件',flags : 0,children : [{file:'./data/help_model_monitor_symbol_Probe.htm',name : 'help_model_monitor_symbol_Probe',body : '场点监视器 场点监视器(Probe)，内部名称 DMonitorTPoint ，是用来监视计算区域中某个位置的实时场数据的一种基本监视器。 基本参数设置如下： 场点监视器基本设置 参数  英文  参数类型  参数分类  说明  场量  Field  选项  基本设置   按局部坐标系定义  field_local  开关  基本设置   坐标  pos  三元表达式  基本设置   image 1: 基本参数设置 image 2: 时间参数设置 说明： 启用“按局部坐标系定义”功能后，如果旋转监视器，其记录的场分量按照旋转后局部坐标系的计算。 时间参数设置 时域记录器的时间设置基本是相同的。分为几种情况： 自动设置时间步 自动设定。由监视器自身默认设置方式来设定，场点监视器的默认设置策略是记录计算周期的所有时间步上的数据。 按整数步设置 按整数步设定。用户需要设定起始 s1 、结束 s2 和步长 ds 三个参数，记录的时间步按照 s1:ds:s2 的方式确定真正记录的时间步。 结果说明 场点监视器结果 节点  类型  说明  data  数组  原始数据  field  字符串  场量名称  time_record  数组  记录时间  pos  数组  记录器位置  when  变量表  记录时间设置  figure  图  记录的时间图  ',title : '场监视点',flags : 0,children : []},{file:'./data/help_model_monitor_symbol_FieldMonitor.htm',name : 'help_model_monitor_symbol_FieldMonitor',body : '区域场监视器 目前软件提供三种区域场监视器 区域场监视器（时域） 区域场监视器（频域） 表面场监视器（频域） ',title : '区域场监视器',flags : 0,children : [{file:'./data/help_model_monitor_symbol_FieldMonitor_TSliceRaw.htm',name : 'help_model_monitor_symbol_FieldMonitor_TSliceRaw',body : '区域场监视器（时域） 区域场监视器（时域）是一种用于记录计算区域中某个截面的场在不同时刻点状态的监视器。内部名称 DMonitorTSliceRaw 。 基本参数设置如下： 区域场监视器（时域） 参数  参数类型  说明  场量  选项   截面  选项   按局部坐标系定义  开关   X上界  单值浮点表达式   Y上界  单值浮点表达式   Z上界  单值浮点表达式   X下界  单值浮点表达式   Y下界  单值浮点表达式   Z下界  单值浮点表达式   image 1: 基本参数设置 image 2: 时间参数设置 时间参数设置 时域监视器的时间设置基本是相同的。分为几种情况： 自动设置时间步 自动设定。由监视器自身默认设置方式来设定，截面场监视器（时域）的默认设置策略是记录计算周期的所有时间步上的数据。 按整数步设置 按整数步设定。用户需要设定起始 s1 、结束 s2 和步长 ds 三个参数，记录的时间步按照 s1:ds:s2 的方式确定真正记录的时间步。 按物理时间步设定 按物理时间设定。用户需要设定起始物理时间和结束物理时间以及参考的采样间隔。用户设定的采样间隔（文档时间单位）会四舍五入到最接近的迭代时间步整数倍（最少为1倍）。 按频率宽度 按物理时间设定。用户需要设定起始物理时间和结束物理时间以及参考的频率宽度。根据傅里叶变换的对应关系： $$ Delta t = dfrac{1}{f_{ text{max}}-f_{ text{min}}} $$ 软件会根据频率宽度信息推算出一个合适的采样时间间隔。最终的采样时间间隔要求是迭代时间步的整数倍（最少为1倍）。 杂项 参数  参数类型  说明  记录面偏移策略  选项  默认为向原点收缩  计算区域策略  选项  默认不延展CBOX  记录面偏移策略 该参数通常不需要特殊设定。记录面偏移策略是针对FDTD网格而言，平行于网格的记录面选择精确网格位置时需要。如果用户需要记录面恰好定在网格位置上，可以使用修视器，给监视器增加相应的网格控制。 计算区域策略 确定计算区域是否影响CBOX的参数。当用户选择延展CBOX时，如果该元件所在的组没有限制更新阶段，那么添加该物体可能会导致在某些方向上延展计算区域。对于该监视器，默认不延展计算区域。 ',title : '区域场监视器（时域）',flags : 0,children : []},{file:'./data/help_model_monitor_symbol_FieldMonitor_FSliceCpx.htm',name : 'help_model_monitor_symbol_FieldMonitor_FSliceCpx',body : '区域场监视器（频域） 区域场监视器（频域）是用于记录计算区域中一个范围内的场在指定时间区间和采样间隔下的指定频率信号的成分。对于电场和磁场的标量分量，其结果为复数。 基本参数设置如下： 区域场监视器（频域） 基本设置  参数类型  说明  频率  浮点表达式  数组或单值  场量  选项   截面  选项   场分量按局部定义  开关   X上界  单值浮点表达式   Y上界  单值浮点表达式   Z上界  单值浮点表达式   X下界  单值浮点表达式   Y下界  单值浮点表达式   Z下界  单值浮点表达式   image 1: 基本参数设置 image 2: 时间参数设置 时间参数设置 频域监视器的时间设置基本相同，分为两种情况： 自动设置时间步 自动设定。由监视器自身默认设置方式来设定，截面场监视器（时域）的默认设置策略是记录计算周期的所有时间步上的数据。 按频率宽度 按物理时间设定。用户需要设定起始物理时间和结束物理时间以及参考的频率宽度。根据傅里叶变换的对应关系： $$ Delta t = dfrac{1}{f_{ text{max}}-f_{ text{min}}} $$ 杂项 参数  参数类型  说明  记录面偏移策略  选项  默认为向原点收缩  计算区域策略  选项  默认不延展CBOX  记录面偏移策略 该参数通常不需要特殊设定。记录面偏移策略是针对FDTD网格而言，平行于网格的记录面选择精确网格位置时需要。如果用户需要记录面恰好定在网格位置上，可以使用修视器，给监视器增加相应的网格控制。 计算区域策略 确定计算区域是否影响CBOX的参数。当用户选择延展CBOX时，如果该元件所在的组没有限制更新阶段，那么添加该物体可能会导致在某些方向上延展计算区域。对于该监视器，默认不延展计算区域。 ',title : '区域场监视器（频域）',flags : 0,children : []},{file:'./data/help_model_monitor_symbol_FieldMonitor_Surface.htm',name : 'help_model_monitor_symbol_FieldMonitor_Surface',body : '表面场监视器（频域） 表面场监视器用于记录一个表面（可能是物体的表面或者其他指定几何曲面）上的电磁场的频率成分。 基本参数设置如下： 区域场监视器（频域） 基本设置  参数类型  说明  频率  浮点表达式  数组或单值  场量  选项   截面  选项   场分量按局部定义  开关   X上界  单值浮点表达式   Y上界  单值浮点表达式   Z上界  单值浮点表达式   X下界  单值浮点表达式   Y下界  单值浮点表达式   Z下界  单值浮点表达式   image 1: 基本参数设置 表面场监视器计算结果 ',title : '表面场监视器（频域）',flags : 0,children : []}]},{file:'./data/help_model_monitor_symbol_FarFieldMonitor.htm',name : 'help_model_monitor_symbol_FarFieldMonitor',body : '远场监视器 频域远场监视器 频域远场监视器通过等效原理计算出指定频率的电磁波在指定距离（按无限远近似处理）处的电磁波场强度。 参数如下： 频域远场监视器 参数  英文  参数类型  参数分类  说明  频率  Frequency  浮点数组  基本设置   区域  Box   基本设置   远场参数列表  Far Field Parameters  基本设置   设置窗口： image 1: 频域远场监视器设置 image 2: 时间设置 时间设置包括 自动设置时间步 和 按频率宽度 设置时间步。 原始数据见下表： 频域远场监视器原始数据 节点  说明  单位  备注  data  数据包   可用于脚本外推计算  freq  记录的频点序列   数组  ff_param  远场参数   数组  pout  各个频率成分通过记录面的能量  J/Hz  每个频点附近的平均能量  pout_im  各个频率成分在记录面附近振荡的能量  J/Hz  每个频点附近的平均能量  power0  各个频率成分通过记录面的平均功率  J/s  平均有功功率在最大计算时间内对应分析频宽内的贡献  power1  各个频率成分通过记录面的平均功率  J/s  平均有功功率在有效记录时间内对应分析频宽内的贡献  when  监视器的时间设置   变量表  far_result  预先外推的计算结果   数组  说明： data 节点可调用下列方法或数据： `data`节点 子节点  说明  备注  ntff  外推器  对象  pout  获取$ text{P}_ text{out}$  函数，通过记录面的能量，复数。实部为有功部分，虚部为无功部分。仅考虑正频率的贡献，考虑正负频率贡献时需按双倍计算。  power  获取$ text{Power}$  函数，通过记录面的功率，复数。实部为有功部分，虚部为无功部分。仅考虑正频率的贡献，考虑正负频率贡献时需按双倍计算。  freq  频率数据   size  频点个数   时域远场监视器 频域远场监视器通过等效原理计算出电磁波在指定距离（按无限远近似处理）处的电磁波场的信号波形。 image 3: 频域远场监视器设置 image 4: 时间设置 时间设置包括： 自动设置时间步 按整数步设置（整数） 起始 结束 步长 按物理时间步设置（浮点数，物理时间，文档时间单位） 起始 结束 采样时间间隔 按频率宽度设置（浮点数，物理时间，文档时间单位、频率单位） 起始 结束 频率宽度 设定时间序列（浮点数，物理时间，文档时间单位） 设定时间序列 频域准远场监视器 时域准远场监视器 频域准远场监视器 ',title : '远场监视器',flags : 0,children : []}]},{file:'./data/help_model_Port.htm',name : 'help_model_Port',body : '端口 ',title : '端口',flags : 0,children : []},{file:'./data/help_model_Wire.htm',name : 'help_model_Wire',body : '导线 细导线时一根直径小于一个格子大小的理想圆导线，其周围的平行电场分量满足距离分之一衰减。 细导线属性界面： 细导线参数说明： 参数 说明 备注 类型 分为细导线及固体导线 - 材料 设置细导线的材料 - 半径 导线半径 - 定义方式 线段（起点、终点） 贝塞尔曲线（起点、控制点、终点） 参数方程（X、Y、Z方向关于t的参数方程） - &nbsp;&nbsp;提示 细导线可以设置为倾斜，也可以设置为曲线。 用户可将细导线按照阵列进行绑定后产生细导线阵列，从而实现对天线阵馈线的自动设置。 细导线的行为与激励源类似，与网格上的材料无关（可认为细导线覆盖网格上的材料）。 ',title : '导线',flags : 0,children : []},{file:'./data/help_model_Visualizer.htm',name : 'help_model_Visualizer',body : '模型视图 ',title : '模型视图',flags : 0,children : []},{file:'./data/help_model_Settings.htm',name : 'help_model_Settings',body : '1. 设置单位 2. 背景材料 3. 计算区域 4. 边界设置 5. 频率设置 6. 时间设置 7. 输出设置 8. 求解器 ',title : '参数设置',flags : 0,children : [{file:'./data/help_model_Settings_unit.htm',name : 'help_model_Settings_unit',body : '设置单位 界面 参数说明 参数  说明 备注 单位    长度单位    频率单位    时间单位    ',title : '设置单位',flags : 0,children : []},{file:'./data/help_model_Settings_bgmat.htm',name : 'help_model_Settings_bgmat',body : '背景材料 界面 参数说明 参数  说明 备注 背景材料   ',title : '背景材料',flags : 0,children : []},{file:'./data/help_model_Settings_fbox.htm',name : 'help_model_Settings_fbox',body : '计算区域 界面 参数说明 参数  说明 备注 计算区域设置策略   计算区域    ',title : '计算区域',flags : 0,children : []},{file:'./data/help_model_Settings_border.htm',name : 'help_model_Settings_border',body : '边界设置 界面 参数说明 参数  说明 备注 边界条件    吸收边界类型   吸收边界层数   ',title : '边界设置',flags : 0,children : []},{file:'./data/help_model_Settings_freq.htm',name : 'help_model_Settings_freq',body : '频率设置 界面 参数说明 参数  说明 备注 最小频率   最大频率   ',title : '频率设置',flags : 0,children : []},{file:'./data/help_model_Settings_time.htm',name : 'help_model_Settings_time',body : '时间设置 界面 参数说明 参数  说明 备注 参考比例    最大物理时间   自定义 dt    dt 参考值    ',title : '时间设置',flags : 0,children : []},{file:'./data/help_model_Settings_output.htm',name : 'help_model_Settings_output',body : '输出设置 界面 参数说明 参数  说明 备注 输出文件路径   输出文件名称   ',title : '输出设置',flags : 0,children : []},{file:'./data/help_model_Settings_solver.htm',name : 'help_model_Settings_solver',body : '求解器 界面 参数说明 参数  说明 备注 微引擎划分粒度    启用自动结束计算   自动结束能量收敛   最小计算步数    开启零引擎    ',title : '求解器',flags : 0,children : []}]},{file:'./data/help_model_Advanced.htm',name : 'help_model_Advanced',body : '1. 参数化 2. 文档函数 3. 匿名元件 4. 局部网格 5. 活动组 6. 工作坐标系 7. 脚本建模 ',title : '高级建模',flags : 0,children : [{file:'./data/help_model_Advanced_parametrization.htm',name : 'help_model_Advanced_parametrization',body : 'EastWave 模型编辑器 ',title : '参数化',flags : 0,children : []},{file:'./data/help_model_Advanced_function.htm',name : 'help_model_Advanced_function',body : '文档函数 时间信号 正弦信号 余弦信号 微分正弦信号 微分余弦信号 上升下降沿 高斯脉冲 时域滤波信号 空间分布 均匀分布 高斯分布 高斯波束 口径分布（空间滤波、波束赋形） 导入数据 建模函数 ',title : '文档函数',flags : 0,children : []},{file:'./data/help_model_Advanced_anonymous.htm',name : 'help_model_Advanced_anonymous',body : 'EastWave 模型编辑器 ',title : '匿名元件',flags : 0,children : []},{file:'./data/help_model_Advanced_local_mesh.htm',name : 'help_model_Advanced_local_mesh',body : 'EastWave 模型编辑器 ',title : '局部网格',flags : 0,children : []},{file:'./data/help_model_Advanced_active_group.htm',name : 'help_model_Advanced_active_group',body : 'EastWave 模型编辑器 ',title : '活动组',flags : 0,children : []},{file:'./data/help_model_Advanced_wcs.htm',name : 'help_model_Advanced_wcs',body : '工作坐标系 工作坐标系的定义 工作坐标系是使用基矢量定义空间向量表示的元件。工作坐标系包括几种类型： 全局坐标系（Global Coordinate System）。 使用UVN模式定义的坐标系，实际上要求用户给定两个互相独立的单位基矢量 u 和 v （的全局表示）来构建的局部坐标系统。 显式引用元件的方式，通过路径方式引用某个元件所在的坐标系。（注意 限制 ） 什么地方需要用到工作坐标系？ 用到工作坐标系的地方主要是激励源和记录器，在默认的情况下，部分监视器可以将自身装载进一个元件组里而自动获得这个组所在的局部坐标系的信息。但是这种方式不适合大部分常规建模的思路，这是因为监视器是分析型元件，并不是几何型元件，其中部分参数与监视器所在的位置并没有严格的逻辑联系。有时候一些监视器或者记录器的空间位置只是算法需要而引入的一个设定，实际上没有（也不应该）赋予与常规几何物体一样的局部坐标属性（不过需要考虑和计算区域坐标系的关系）。 坐标系定义有什么限制？ 定义坐标系的时候，由于我们处理的问题大部分是和物理场（向量场）有关系，因此我们必须限制坐标变换的性质： 必须符合右手螺旋规则 不包含任何比例缩放 工作坐标的参数 坐标原点 对于任何一种设定方式，允许用户额外设定一个坐标原点，该坐标为在选定的局部坐标系下的表示。使用这种方式可以解决部分监视器要求知道相位参考中心的问题。该选项默认为$(0,0,0)$。 坐标模式选项 允许用户选择全局坐标系、UVN设定模式和引用元件模式三种方式 全局坐标模式，默认$ vec{u}=(1,0,0)$、$ vec{v}=(0,1,0)$、$ vec{n}=(0,0,1)$ 引用元件模式，实际上是引用元件实例的路径（同一个元件可能存放于不同的位置，有多个实例副本）所在位置的局部坐标系信息 ',title : '工作坐标系',flags : 0,children : []},{file:'./data/help_model_Advanced_ewsl_model.htm',name : 'help_model_Advanced_ewsl_model',body : '脚本建模 使用 EastWave V7 脚本，用户可以创建所有的几何元件（基础几何元件、扩展几何元件），并且可以为某些几何元件的特殊参数（几何体精密度）赋值。  本节内容 如何使用脚本建模 新建脚本文件 初始化模型文档 添加几何元件 运行脚本文件   几何元件脚本参数 几何元件脚本参数说明 长方体 圆柱体 球体 几何球体 圆锥体 环体 实心旋转体 空心旋转体 参数扫描体 垂直拉伸体 导入CAD模型 强制网格面 多层物体 天线罩 阵列   ',title : '脚本建模',flags : 0,children : [{file:'./data/help_model_Advanced_ewsl_model_How.htm',name : 'help_model_Advanced_ewsl_model_How',body : '如何使用脚本建模 操作步骤 1.新建脚本文件 任意工作目录下新建文本文档，并将文本文档重命名为 .ewp2 格式。 2.初始化模型文档 EastWave V7 模型文档定义了 计算模式 、 变量表 、 顶层模块 、 基础参数 、 调度器 、 网格属性 。  用户使用脚本建模，实际上就是在 顶层模块 中添加新的几何元件。  打开并编辑脚本文件，添加以下代码初始化模型文档： td.beg("doc","DDocument"); //定义模型文档 td.beg("default","DTemplateBasic"); td.set("workmode","workmode1"); //工作模式 td.set("variable","vartable"); //变量表 td.set("topgroup1","topgroup1"); //顶层模块 td.set("parameter","param"); //基础参数 td.set("dispatcher1",""); //调度器 td.set("dispatcher2",""); td.set("meshsetting","meshsetting"); //网格属性 td.end(); //定义工作模式 td.beg("workmode1","DWorkmodeCustom"); td.set("unit",""); td.end(); //定义变量表 td.beg("vartable","DVariable"); td.set("variables",[]); td.end(); //定义顶层模块 td.beg("topgroup1","DSymbolGrp"); td.set("unit",""); td.set("meshinfo",""); td.set("material",""); td.set("n_dp_level",0x0); td.set("transforms",[]); td.set("children",["cube"]); //添加长方体几何元件到顶层模块 td.set("reference",""); td.end(); //定义长方体几何元件 td.beg("cube","DShapeCube"); td.set("unit",""); td.set("opt_type#Cube#Shape",0x0); td.set("x3e_center.x#Cube#Shape","0.0"); td.set("x3e_center.y#Cube#Shape","0.0"); td.set("x3e_center.z#Cube#Shape","0.0"); td.set("x3e_width.x#Cube#Shape","100.0"); td.set("x3e_width.y#Cube#Shape","100.0"); td.set("x3e_width.z#Cube#Shape","100.0"); td.set("u3e_corner_1.u#Cube#Shape","0.0"); td.set("u3e_corner_1.v#Cube#Shape","0.0"); td.set("u3e_corner_1.n#Cube#Shape","0.0"); td.set("u3e_corner_2.u#Cube#Shape","10.0"); td.set("u3e_corner_2.v#Cube#Shape","10.0"); td.set("u3e_corner_2.n#Cube#Shape","10.0"); td.set("mvm_arrayvec3#Cube#Shape",[["1.0","0.0","0.0",20],["0.0","1.0","0.0",20],["0.0","0.0","1.0",20]]); td.end(); //定义基础参数 td.beg("param","DParameter"); td.set("unit","unit"); td.set("bgmat","air"); td.set("fbox.lo.x","-300"); td.set("fbox.lo.y","-300"); td.set("fbox.lo.z","-300"); td.set("fbox.hi.x","300"); td.set("fbox.hi.y","300"); td.set("fbox.hi.z","300"); td.set("border.lo.x",0x0); td.set("border.lo.y",0x0); td.set("border.lo.z",0x0); td.set("border.hi.x",0x0); td.set("border.hi.y",0x0); td.set("border.hi.z",0x0); td.set("time.step_max","1000"); td.set("time.time_max","4000"); td.set("time.dt_ratio","1.6/2.25"); td.set("time.dt_reference","1.0"); td.set("time.policy",0xFFFFFFFFFFFFFFFF); td.set("pml.size","12"); td.set("pml.type",0x0); td.set("freq.min","1.0"); td.set("freq.max","2.0"); td.set("flags",0x0); td.end(); //定义单位 td.beg("unit","DUnit"); td.set("ul.type",0x0); td.set("ul.expr","1.0e-3"); td.set("ut.type",0x0); td.set("ut.expr","1.0e-9"); td.set("uf.type",0x0); td.set("uf.expr","1.0e9"); td.set("flags",0x0); td.end(); //定义普通材料 td.beg("air","DMaterialSimple"); td.set("unit",""); td.set("material.color",0xFFE09C8B); td.set("material.extra",0x0); td.set("eps","1"); td.set("sge","0"); td.set("xmu","1"); td.set("sgm","0"); td.end(); //定义网格属性 td.beg("meshsetting","DMeshsetting"); td.set("meshinfo.basic.flags",0x0); td.set("meshinfo.basic.delta.x",10); td.set("meshinfo.basic.delta.y",10); td.set("meshinfo.basic.delta.z",10); td.set("meshinfo.basic.extend.x",0); td.set("meshinfo.basic.extend.y",0); td.set("meshinfo.basic.extend.z",0); td.set("meshinfo.refine.flags",0x27); td.set("meshinfo.refine.edge_factor",1); td.set("meshinfo.refine.vol_factor",1); td.set("meshinfo.snapping.flags",0x1); td.set("meshinfo.config.flags",0x400); td.set("meshinfo.config.edge_fraction",3); td.set("meshinfo.config.vol_smooth_ratio",1.1); td.set("meshinfo.config.edge_additional_fine_cells",0x3); td.set("meshinfo.config.vol_additional_fine_cells",0x3); td.set("meshinfo.config.weight_near.x",1); td.set("meshinfo.config.weight_near.y",1); td.set("meshinfo.config.weight_near.z",1); td.set("meshinfo.config.weight_far.x",1); td.set("meshinfo.config.weight_far.y",1); td.set("meshinfo.config.weight_far.z",1); td.set("meshinfo.config.num_near",15); td.set("meshinfo.config.num_far",15); td.set("meshinfo.mesh.type",0x0); td.set("meshinfo.mesh.grid.x","50"); td.set("meshinfo.mesh.grid.y","50"); td.set("meshinfo.mesh.grid.z","50"); td.set("meshinfo.fillmethod",0x0); td.set("meshinfo.conformal.level_e",0x0); td.set("meshinfo.conformal.level_h",0x0); td.set("meshinfo.conformal.line_policy",0x1); td.set("meshinfo.conformal.line_fc_policy",0x0); td.set("meshinfo.conformal.SC_error",0); td.end(); td.run(0); td.end(); 3.添加几何元件 对于脚本建模来说，以上脚本代码中，最重要的部分是： //定义顶层模块 td.beg("topgroup1","DSymbolGrp"); ...... td.set("children",["cube"]); //添加长方体几何元件到顶层模块 ...... td.end(); //定义长方体几何元件 td.beg("cube","DShapeCube"); ...... td.end(); 添加新的几何元件也比较简单：定义了新的几何元件后，只需要把几何元件名称添加到 topgroup1 的 children 属性中即可。 /*下面这段脚本代码，定义了一个新的圆柱体几何元件，并将其添加到了顶层模块topgroup1。*/ //定义顶层模块 td.beg("topgroup1","DSymbolGrp"); ...... td.set("children",["cube","cylinder"]); //添加新定义的圆柱体到顶层模块中 ...... td.end(); //定义长方体几何元件 td.beg("cube","DShapeCube"); ...... td.end(); //定义圆柱体几何元件 td.beg("cylinder","DShapeCylinder"); ...... td.end(); 相关文档：  几何元件脚本参数说明 长方体 圆柱体 球体 几何球体 圆锥体 环体 实心旋转体 空心旋转体 参数扫描体 垂直拉伸体 导入CAD模型 强制网格面 多层物体 天线罩 阵列  4.运行脚本文件 保存脚本文件 &gt; 运行 EastWave V7 软件 &gt; 打开 文件 菜单 &gt; 选择 打开 &gt; 选中脚本文件 &gt; 单击 打开 运行脚本文件。   ',title : '如何使用脚本建模',flags : 0,children : []},{file:'./data/help_model_Advanced_ewsl_model_Guide.htm',name : 'help_model_Advanced_ewsl_model_Guide',body : '几何元件脚本参数 索引表 几何元件脚本参数说明 长方体 圆柱体 球体 几何球体 圆锥体 环体 实心旋转体 空心旋转体 参数扫描体 垂直拉伸体 导入CAD模型 强制网格面 多层物体 天线罩 阵列 长方体 中心（定义方式） 示例代码 td.beg("cube", "DShapeCube"); td.set("unit", ""); //物体单位 td.set("opt_type#Cube#Shape", 0x0); //定义方式 //体中心 td.set("x3e_center.x#Cube#Shape", "0.0"); td.set("x3e_center.y#Cube#Shape", "0.0"); td.set("x3e_center.z#Cube#Shape", "0.0"); td.set("x3e_width.x#Cube#Shape", "100.0"); //长度 td.set("x3e_width.y#Cube#Shape", "100.0"); //宽度 td.set("x3e_width.z#Cube#Shape", "100.0"); //高度 td.end(); 脚本参数说明 参数名称 说明 备注 opt_type#Cube#Shape 指定长方体 定义方式 0:中心 1:边  x3e_center.[xyz]#Cube#Shape 指定长方体 中心点 - x3e_width.[xyz]#Cube#Shape 指定长方体的 长度、宽度、高度 - 边（定义方式） 示例代码 td.beg("cube","DShapeCube"); td.set("unit",""); //物体单位 td.set("opt_type#Cube#Shape",0x1); //定义方式 //左下前角点 td.set("u3e_corner_1.u#Cube#Shape","0.0"); td.set("u3e_corner_1.v#Cube#Shape","0.0"); td.set("u3e_corner_1.n#Cube#Shape","0.0"); //右上后角点 td.set("u3e_corner_2.u#Cube#Shape","100.0"); td.set("u3e_corner_2.v#Cube#Shape","100.0"); td.set("u3e_corner_2.n#Cube#Shape","100.0"); td.end(); 脚本参数说明 参数名称 说明 备注 opt_type#Cube#Shape 指定长方体 定义方式 0:中心  1:边 u3e_corner_1.[uvn]#Cube#Shape 指定长方体 左上前角点 - u3e_corner_2.[uvn]#Cube#Shape 指定长方体 后下后角点 - 圆柱体 中心（定义方式） 示例代码 td.beg("cylinder","DShapeCylinder"); td.set("unit",""); //物体单位 td.set("opt_type#Cylinder#Shape",0x0); //定义方式 td.set("int_sides#Cylinder#Shape",0x24); //边数 td.set("exp_void_ratio#Cylinder#Shape","0.5"); //体空心比 //体中心 td.set("x3e_center.x#Cylinder#Shape","0.0"); td.set("x3e_center.y#Cylinder#Shape","0.0"); td.set("x3e_center.z#Cylinder#Shape","0.0"); td.set("x3e_width.x#Cylinder#Shape","100.0"); //长度 td.set("x3e_width.y#Cylinder#Shape","100.0"); //宽度 td.set("x3e_width.z#Cylinder#Shape","100.0"); //高度 td.end(); 脚本参数说明 参数名称 说明 备注 中心（定义方式） 示例代码 td.beg("cylinder","DShapeCylinder"); td.set("unit",""); //物体单位 td.set("opt_type#Cylinder#Shape",0x1); //定义方式 td.set("int_sides#Cylinder#Shape",0x24); //边数 td.set("exp_void_ratio#Cylinder#Shape","0.5"); //体空心比 //底面中心 td.set("x3e_center.x#Cylinder#Shape","0.0"); td.set("x3e_center.y#Cylinder#Shape","0.0"); td.set("x3e_center.z#Cylinder#Shape","0.0"); //底面半径 td.set("x2e_radius.x#Cylinder#Shape","20.0"); td.set("x2e_radius.y#Cylinder#Shape","20.0"); td.set("exp_height#Cylinder#Shape","100.0"); //高度 td.end(); 脚本参数说明 参数名称 说明 备注 球体 示例代码 td.beg("sphere","DShapeSphere"); td.set("unit",""); //物体单位 //体中心 td.set("x3e_center.x#Sphere#Shape","0.0"); td.set("x3e_center.y#Sphere#Shape","0.0"); td.set("x3e_center.z#Sphere#Shape","0.0"); //三维半径 td.set("x3e_radius.x#Sphere#Shape","10.0"); td.set("x3e_radius.y#Sphere#Shape","10.0"); td.set("x3e_radius.z#Sphere#Shape","10.0"); td.set("exp_thickness#Sphere#Shape","0.0"); //厚度 td.set("int_stacks#Sphere#Shape",0x32); //纵向层数 td.set("int_slices#Sphere#Shape",0x64); //横向片数 td.end(); 脚本参数说明 参数名称 说明 备注 几何球体 示例代码 td.beg("geosphere","DShapeGeoSphere"); td.set("unit",""); //物体单位 //体中心 td.set("x3e_center.x#GeoSphere#Shape","0.0"); td.set("x3e_center.y#GeoSphere#Shape","0.0"); td.set("x3e_center.z#GeoSphere#Shape","0.0"); //三维半径 td.set("x3e_radius.x#GeoSphere#Shape","100.0"); td.set("x3e_radius.y#GeoSphere#Shape","100.0"); td.set("x3e_radius.z#GeoSphere#Shape","100.0"); td.set("int_segments#GeoSphere#Shape",0x2); //段数 td.end(); 脚本参数说明 参数名称 说明 备注 圆锥体 示例代码 td.beg("cone","DShapeCone"); td.set("unit",""); //物体单位 td.set("int_sides#Spin#Shape",0x24); //边数 td.set("exp_height#Cone#Shape","100.0"); //高度 td.set("exp_radius#Cone#Shape","50.0"); //底面半径 td.end(); 脚本参数说明 参数名称 说明 备注 环体 示例代码 td.beg("torus","DShapeTorus"); td.set("unit",""); //物体单位 td.set("exp_cutplane_distance#Torus#Shape","100.0"); //环半径 td.set("int_segments#Torus#Shape",0x48); //环段数 td.set("exp_cutplane_radius#Torus#Shape","20.0"); //圆半径 td.set("int_sides#Torus#Shape",0x24); //圆边数 td.end(); 脚本参数说明 参数名称 说明 备注 实心旋转体 示例代码 //代码 脚本参数说明 参数名称 说明 备注 空心旋转体 示例代码 //代码 脚本参数说明 参数名称 说明 备注 参数扫描体 示例代码 //代码 脚本参数说明 参数名称 说明 备注 垂直拉伸体 示例代码 //代码 脚本参数说明 参数名称 说明 备注 导入CAD模型 示例代码 //代码 脚本参数说明 参数名称 说明 备注 强制网格 示例代码 //代码 脚本参数说明 参数名称 说明 备注 多层物体 示例代码 //代码 脚本参数说明 参数名称 说明 备注 天线罩 示例代码 //代码 天线罩还需要细分类型 脚本参数说明 参数名称 说明 备注 阵列 示例代码 //代码 阵列还需要细分类型 脚本参数说明 参数名称 说明 备注 相关文档 如何把几何元件脚本代码添加到模型文档。 如何使用更为便捷的界面建模。 ',title : '几何元件脚本参数',flags : 0,children : []}]}]},{file:'./data/help_model_LumpedPort.htm',name : 'help_model_LumpedPort',body : '集总端口 在天线和微波器件的仿真中时常会用到集总端口，在FDTD仿真中集总端口尺度假定为远小于波长，其和电磁场间的相互响应 只考虑在集总所在位置的一个电网格上。EastWave中集总端口可以是有源的（以电流源或电压源给出）或无源的，集总端口的 电路主要为串联或并联RCL电路，以并联RCL电路的电压源集总端口为例，其模型如下图： &nbsp;&nbsp;注意 集总端口朝向为全局坐标轴正方向（负指向正），例如一个朝向x轴正方向发射的正电压信号的时候，端口会在端口上馈出一个正的Ex值； 反之，如果外场输入一个Ex为负值，则集总端口接收到的电压信号为负。 集总端口参数设置窗口如下图所示：  具体参数含义如下： 集总端口参数 参数名称  参数说明  备注  位置  指定集总端口的中心位置   方向  指定集总端口的方向   反转  反转向集总端口馈入电压或电流的方向  等价于直接在馈入信号幅度前乘以-1 RCL参数 电路连接 集总端口内电路的类型  R  集总端口电路内电阻值 C  集总端口电路内电容值 L  集总端口电路内电感值 馈电类型  有源集总端口的类型 材料  集总端口所在位置的材料类型 暂时不考虑材料除电导率以外的色散部分性质 激励 信号 集总端口的馈入信号 强度  馈入信号的强度 延迟 馈入信号的相位延迟 &nbsp;&nbsp;注意 集总端口在进行旋转操作后，其方向会发生变化， 用户必须保证集总端口方向在经过旋转操作后仍然为xyz方向之一 。 集总端口的输出结果入下: 集总端口输出 结果名称 结果说明 备注 RCL参数 R  集总端口电路内电阻值 C  集总端口电路内电容值 L  集总端口电路内电感值 馈入信号 Vs_by_time 馈入端口的电压信号 馈电类型为电压源时有值 Is_by_time 馈入端口的电流信号 馈电类型为电流源时有值 V_by_time 输出电压信号 I_by_time 输出电流信号 ',title : '集总端口',flags : 0,children : []},{file:'./data/help_model_Appendix.htm',name : 'help_model_Appendix',body : '附录 ',title : '附录',flags : 0,children : []},{file:'./data/help_model_Indices.htm',name : 'help_model_Indices',body : '索引 ',title : '索引',flags : 0,children : []}]},{file:'./data/help_solver.htm',name : 'help_solver',body : '仿真分析 参考指南 本参考指南详细介绍了求解器相关的设置以及配置、结果与后处理相关内容以及参数扫描与寻优具体操作。 简介 EastWave 7 提供了仿真分析的各种设置选项，主要是为了让用户能够 高度定制 自己的仿真解决方案。 EastWave 7 同时也提供了参数扫描和寻优功能，帮助用户找到最优解。 概览 1. 求解器设置 2. 求解器配置 3. 结果与后处理 4. 参数扫描和寻优 ',title : '仿真分析',flags : 0,children : [{file:'./data/help_solver_solver_settings.htm',name : 'help_solver_solver_settings',body : '求解器设置 本章主要说明 EastWave 7 仿真计算过程中用到的核心设置选项： 1. 常规设置 2. 边界设置 3. 网格设置 4. 物体优先级设置 5. 变量设置和内置常量 6. 其它设置 ',title : '求解器设置',flags : 0,children : [{file:'./data/help_solver_solver_settings_common.htm',name : 'help_solver_solver_settings_common',body : '常规设置 单位 、 背景材料 和 频率 是用户文档最基本的参数。用户可以在菜单栏中的“求解器”菜单中进行设置。 单位 在“求解器”菜单中点击“设置单位”，打开单位设置对话框如下图所示：   用户可以设定文档中使用的长度、时间和频率单位： 电磁波工程类用户建议使用毫米和GHz为单位，时间单位建议选择自动相关。 光电类用户，长度单位可取纳米、微米，频率单位可取Hz或THz，时间单位同样建议选择自动相关。 相应的文档全局变量分别为UL、UT和UF，在计算时如需消除单位差异而进行的运算中可引用这些全局变量 （例如定义时域波形中的相位是无量纲的，需要用这几个参数）。 &nbsp;&nbsp;注意 网格尺度限制满足Courant稳定条件： $$ c Delta t le dfrac{1}{ dfrac{1}{ Delta x^2} + dfrac{1}{ Delta y^2} + dfrac{1}{ Delta z^2} } $$ 使用具有宽谱特性的信号时，信号中的高频成分计算结果将不会准确，并且高频成分在相对粗网格区域会产生严重色散现象。因此，使用高斯脉冲时，频率宽度不应设置得过宽（对应时间宽度不应过窄）。 背景材料 在“求解器”菜单中点击“设置背景”，打开背景材料设置对话框如下图所示：   在模拟一些介质中电磁波的传播行为时有时需将背景材料修改为用户需要的某种材料。 &nbsp;&nbsp;注意 部分监视器、光源处于非空气介质中，需要设置背景材料的介电常数、波阻抗等参数。 如果背景材料有较高的介电常数或其他复杂色散行为，需要考虑将网格参数调节得较为精细。 频率 在“求解器”菜单中点击“设置频率”，打开频率设置对话框如下图所示：   选择一个合适的频率范围对获得正确的FDTD仿真结果非常重要。 用户在该对话框中设置了三参数：最小频率、最大频率和频率间隔，将会产生几个全局文档那个变量： 频率有关参数 变量名  说明  freq.min  最小频率  freq.max  最大频率  freq.ref  参考频率  lambda.min 最小波长  lambda.max 最大波长  lambda.ref 参考波长  在设置网格、激励源和监视器时可以使用上述变量，可加强工程文档的可重用能力。 &nbsp;&nbsp;注意 freq.ref 、 lambda.ref 参数会影响网格的设置。 ',title : '常规设置',flags : 0,children : []},{file:'./data/help_solver_solver_settings_border.htm',name : 'help_solver_solver_settings_border',body : '边界设置 在仿真不同类型电磁波问题时可能使用不同的边界条件。 边界类型分为：开放边界、周期边界、PEC 边界、PMC 边界和布洛赫边界。 边界类型 边界类型  使用条件  常见问题  备注  开放边界  模拟无限大开放边界   需要设定吸收层  PEC 边界  模拟电反射边界    PMC 边界  模拟磁反射边界    周期边界  在一个方向上的周期边界条件    &nbsp;&nbsp;周期边界条件 电反射边界条件：电场水平分量为0，磁场水平分量不变，对应无限大理想金属平板（$ sigma_e rightarrow infty$） 磁反射边界条件：磁场水平分量为0，电场水平分量不变，对应无限大理想磁导体平板（$ sigma_m rightarrow infty$） 用户打开边界设置对话框如下图：   当选择开放边界时，需要正确选择和合适的吸收边界。每种边界的含义和用法如下表：  吸收层类型 吸收边界  含义  用法  PML  完美匹配层   CPML  卷积型完美匹配层   &nbsp;&nbsp;注意 开放边界附近有强色散材料时注意延拓空间（ADDSPACE）要适当增大，否则可能引发边界附近计算不精确或部分发散。 通常PML层数越多吸收效果越好，但过多的吸收层将增大内存和计算开销。 ',title : '边界设置',flags : 0,children : []},{file:'./data/help_solver_solver_settings_mesh.htm',name : 'help_solver_solver_settings_mesh',body : '网格设置 网格设置是 EastWave 仿真过程中的重要设置，与计算量的大小和计算结果的精度密切相关。 EastWave 提供3种网格划分策略，分别为 均匀网格 、 非均匀网格（策略一） 、 非均匀网格（策略二） ， 其中非均匀网格（策略二）为 6.0 版本新增内容。 EastWave 6.0 还提供了薄层网格划分功能，可用最少的网格保证薄层网格的连通性，在保证计算精度的基础上，大大减小了计算量。 索引 1. 常规网格设置 2. 均匀网格 3. 非均匀网格策略一 ',title : '网格设置',flags : 0,children : [{file:'./data/help_solver_solver_settings_mesh_common.htm',name : 'help_solver_solver_settings_mesh_common',body : 'empty page ',title : '常规网格设置',flags : 0,children : []},{file:'./data/help_solver_solver_settings_mesh_average.htm',name : 'help_solver_solver_settings_mesh_average',body : 'empty page ',title : '均匀网格',flags : 0,children : []},{file:'./data/help_solver_solver_settings_mesh_no_average_1.htm',name : 'help_solver_solver_settings_mesh_no_average_1',body : 'empty page ',title : '非均匀网格策略一',flags : 0,children : []}]},{file:'./data/help_solver_solver_settings_shape.htm',name : 'help_solver_solver_settings_shape',body : '物体优先级设置 EastWave 不支持布尔操作 ，当不同的物体模型存在区域重叠时，可通过调整优先级的方式对重叠区域赋予材料。 ',title : '物体优先级设置',flags : 0,children : []},{file:'./data/help_solver_solver_settings_variable.htm',name : 'help_solver_solver_settings_variable',body : '变量设置 EastWave 内置了常用常量和一些名称固定的内置变量，用户可在工程设计时使用。 设置参数时可直接使用这些内置常量和内置变量，也可使用自定义变量和表达式， 但需注意自定义变量名称不能和系统内置常量和内置变量同名。 索引 1. 系统内置常量 2. 系统内置变量 3. 自定义常规变量 4. 自定义数组变量 5. 扫描优化参数变量 ',title : '变量设置和内置常量',flags : 0,children : [{file:'./data/help_solver_solver_settings_variable_system_let.htm',name : 'help_solver_solver_settings_variable_system_let',body : 'empty page ',title : '系统内置常量',flags : 0,children : []},{file:'./data/help_solver_solver_settings_variable_system_var.htm',name : 'help_solver_solver_settings_variable_system_var',body : 'empty page ',title : '系统内置变量',flags : 0,children : []},{file:'./data/help_solver_solver_settings_variable_user_var.htm',name : 'help_solver_solver_settings_variable_user_var',body : 'empty page ',title : '自定义常规变量',flags : 0,children : []},{file:'./data/help_solver_solver_settings_variable_user_arr_var.htm',name : 'help_solver_solver_settings_variable_user_arr_var',body : 'empty page ',title : '自定义数组变量',flags : 0,children : []},{file:'./data/help_solver_solver_settings_variable_opt_var.htm',name : 'help_solver_solver_settings_variable_opt_var',body : 'empty page ',title : '扫描优化参数变量',flags : 0,children : []}]},{file:'./data/help_solver_solver_settings_other.htm',name : 'help_solver_solver_settings_other',body : '其它设置 求解器设置的一些其它额外设置，包括： 1. 输出设置 2. 精度设置 3. 初始化电磁场 4. 自定义脚本 5. 采集位置点与测量 6. 工作平面和坐标系 ',title : '其它设置',flags : 0,children : [{file:'./data/help_solver_solver_settings_other_output.htm',name : 'help_solver_solver_settings_other_output',body : 'empty page ',title : '输出设置',flags : 0,children : []},{file:'./data/help_solver_solver_settings_other_precision.htm',name : 'help_solver_solver_settings_other_precision',body : 'empty page ',title : '精度设置',flags : 0,children : []},{file:'./data/help_solver_solver_settings_other_EW.htm',name : 'help_solver_solver_settings_other_EW',body : 'empty page ',title : '初始化电磁场',flags : 0,children : []},{file:'./data/help_solver_solver_settings_other_user_ewsl.htm',name : 'help_solver_solver_settings_other_user_ewsl',body : 'empty page ',title : '自定义脚本',flags : 0,children : []},{file:'./data/help_solver_solver_settings_other_catch.htm',name : 'help_solver_solver_settings_other_catch',body : 'empty page ',title : '采集位置点与测量',flags : 0,children : []},{file:'./data/help_solver_solver_settings_other_workplane.htm',name : 'help_solver_solver_settings_other_workplane',body : 'empty page ',title : '工作平面和坐标系',flags : 0,children : []}]}]},{file:'./data/help_solver_configurations.htm',name : 'help_solver_configurations',body : 'empty page ',title : '求解器配置',flags : 0,children : []},{file:'./data/help_solver_result.htm',name : 'help_solver_result',body : '结果与后处理 当仿真解决方案计算完毕后，最后我们要处理的就是数据结果了，这个阶段称为后处理阶段。 索引 1. 后处理数据结构 2. Report 3. 智能数据 4. 图对象属性 5. 功能操作 6. 脚本后处理 ',title : '结果与后处理',flags : 0,children : [{file:'./data/help_solver_result_struct.htm',name : 'help_solver_result_struct',body : 'empty page ',title : '后处理数据结构',flags : 0,children : []},{file:'./data/help_solver_result_report.htm',name : 'help_solver_result_report',body : 'empty page ',title : 'Report',flags : 0,children : []},{file:'./data/help_solver_result_smart.htm',name : 'help_solver_result_smart',body : 'empty page ',title : '智能数据',flags : 0,children : []},{file:'./data/help_solver_result_figure.htm',name : 'help_solver_result_figure',body : 'empty page ',title : '图对象属性',flags : 0,children : []},{file:'./data/help_solver_result_function.htm',name : 'help_solver_result_function',body : 'empty page ',title : '功能操作',flags : 0,children : []},{file:'./data/help_solver_result_ewsl.htm',name : 'help_solver_result_ewsl',body : 'empty page ',title : '脚本后处理',flags : 0,children : []}]},{file:'./data/help_solver_param.htm',name : 'help_solver_param',body : '1. 参数扫描 2. 参数寻优 ',title : '参数扫描和寻优',flags : 0,children : [{file:'./data/help_solver_param_scan.htm',name : 'help_solver_param_scan',body : '参数扫描 EastWave 参数扫描功能可对自定义变量表中的一个或多个“常规变量“进行扫描计算。   选择菜单 模型 &gt; 参数扫描 或双击工具条 scan ，弹出“参数扫描”对话框如下图所示：   参数扫描对话框使用说明： 输入项 说明 备注 变量名 变量取值序列 ',title : '参数扫描',flags : 0,children : []},{file:'./data/help_solver_param_opt.htm',name : 'help_solver_param_opt',body : '参数寻优 EastWave 的参数寻优功能可对自定义变量表中的一个或多个“常规变量“进行优化分析，最终得到满足条件的变量值。   选择菜单 模型 &gt; 参数寻优 或双击工具条 opt ，弹出“参数寻优”对话框如下图所示：   参数寻优设置步骤如下： 确定需要优化的变量名和变量取值范围 确定优化目标 确定优化算法 执行优化 确定需要优化的变量名和变量取值范围 在“参数寻优”页中指定需要优化的变量名和优化过程中变量允许的取值范围，输入内容如下： 输入项 说明 备注 变量名 需优化的变量名称，输入变量窗口中已定义的常规变量（非数组变量），每行输入一个变量 最小值 优化过程中所在行的变量允许的最小值 最大值 优化过程中所在行的变量允许的最大值 确定优化目标 在“目标”页中指定“优化函数”和“优化目标”。   其中： “优化函数”可以是软件输出的某个结果，如自动计算透反率模式下输出的透反率系数，也可以是调用输出结果的某个目标函数。  更多情况下，通过定义“自定义脚本”，在每次计算后自动后处理返回需要的结果，在优化函数中调用该结果。此用法要求“自定义脚本”最后一行给出需返回的参量，以将该参量的值作为脚本返回值。 “优化目标”中给出结束优化的条件，即认为满足该条件时认为优化目标已达到。可以填入优化函数的目标值。 确定优化算法 EastWave 中提供两种常用的优化算法：单纯形算法和混合算法。根据算法的特点，针对不同的寻优问题，应选择合适的算法： 单纯形算法：当满足条件的值集中在一个较小的范围内适用该方法； 混合算法：当满足条件的值分布于多个不同区域时适用该方法。 两种算法中，通常优先考虑单纯形算法，根据人为判断大致确定最优参数的范围。在采用单纯形算法达不到优化效果的情况下，再考虑采用混合算法。优化算法高级设置如图5-30所示：   各参数对优化速度及结果的影响见下表： 参数类型及名称 全局性 总消耗时间 收敛速度 单纯形参数 遗传算法参数 执行优化 设置完优化参数后，即可启动计算开始循环搜索最优解，计算结束后将在后处理脚本数据树gdata下给出优化后的参数值和优化目标值。关于数据后处理可参看 数据后处理 。 ',title : '参数寻优',flags : 0,children : []}]}]},{file:'./data/help_script.htm',name : 'help_script',body : 'MX程序设计语言帮助手册 目录 1. 简介 2. 第一个程序 3. 基本概念 3.1. 基本数据类型 3.2. 变量表（Variable Table） 3.3. 数组（Array） 3.4. 函数（Function） 3.5. 类和对象 4. 过程控制结构 5. 编写文件读写与字符串处理 5.1. 文本文件的读写 5.2. 从文本文件中导入数组（需要改进） 5.3. 文件流的支持（尚未实现） 5.4. 字符串的处理 5.4.1. 字符串的分解和拼接 6. 编写数值计算程序 6.1. 数值积分与微分 1. 简介 MX程序设计语言 是上海东峻信息科技有限公司开发的一款面向CAE仿真前、后处理和通用接口设计编码的脚本语言。EastWave V7.0脚本语言以下简称 MX 。 EastWave V7版本EWSL与之前版本的EWSL有较多差异，但也有一定的相似性。使用旧版脚本语言可以较快的掌握新版脚本语言的基本用法。 新版EWSL支持动态类型（Dynamic Typed）、C风格语法（C-Style Syntax）、变量表（Variable Table）和动态变量数组（Dynamic Variable Array）、预编译/解释执行（Pre-compiled/Interpretative）、函数/闭包（Function/Closure）、函数式编程（Functional Programming）、面向对象编程（Object Oriented Programming）、面向数组/矩阵运算（Array/Matrix Computation）的语法、数值计算库、绘图库、WEB服务器等多种功能。 2. 第一个程序 从Hello World!开始 像大多数语言的入门教程一样，先实现一个Hello World程序。打开EastWave界面，选择新建“Ewsl交互式编辑器”。然后在交互式编程环境下输入： &gt;&gt; print("Hello World!") 注释  EWSL使用C/C++风格注释，即支持 // 行注释和 /**/ 的块注释。 前处理指令（这部分未来放到其他地方）  EWSL支持前处理指令，用 # 字符开头，用来控制编译器或者解释器的一些行为，以及对源代码文件的含义的解释。目前典型的包括有：  #function #function 前处理指令用来规定该文件内容是定义一个函数，函数的输入参数在 #function 后的括号中表述，诸如： #function(arg1, arg2, ...) #variable #variable 用来指定文件内容中定义变量符号的作用域规则（ local 或者 global ）， #variable(explicit) 表示所有的变量符号定义必须显式指定， #variable(implicit:global) 表示采用隐式规则，并且默认设定为全局变量（除特殊的局部语法规定外）， #variable(implicit:local) 表示采用隐式规则，并且默认设定为局部变量。 #import 和 #export 导入模块和设定模块导出符号表。 #import 用法: 使用 #import modulename 导入整个模块，但是必须使用模块名作前缀名；使用 #import modulename(symbol, ...) 从模块中导入部分符号，并且作为系统变量表中的可用符号。 注意： 系统变量表中的符号不允许同名，如果同名会抛出错误信息。 #export 用法：使用 #export(sym1, ...) ，对 #import ... 可导入的符号产生影响。 #results 设定语句运行时是否打印出返回值 #results(show) 表示语句最后没有分号时，会打印语句的返回值 #results(hide) 表示语句最后没有分号时，不打印语句的返回值 3. 基本概念 3.1. 基本数据类型 数值类型（整数和浮点数） EWSL提供了整数类型（Integer）和浮点数类型（Float），两种基本数值类型。其中整数类型是有符号64位整数类型，浮点数为双精度浮点数。 a = 1; // 定义一个变量a，其值为整数1 b = 2.0; // 定义一个浮点变量b，其值为浮点数2.0 数值类型支持四则运算 + 、 - 、 * 、 / 。此外数值类型在一定程度上可以互相转换。例如我们可以计算勾股定理： $$ c= sqrt{a^2+b^2}, a=3, b=4 $$ 参考代码如下： a = 3; b = 4; c = sqrt(a^2+b^2); print(c); 打印结果为 5 。 布尔类型（Boolean） 布尔类型即布尔代数的数据类型，布尔型包括两个值，真 true 和假 false ，支持 C风格 布尔运算符号：逻辑与 &amp;&amp; 、逻辑或 || 、逻辑非 ! 、逻辑异或 ^^ 。 a = true; b = false; c = a &amp;&amp; b; // 逻辑与运算 d = a || b; // 逻辑或运算 e = !a; // 逻辑非运算 f = a ^^ b // 逻辑异或 复数类型（Complex） EWSL支持复数类型的直接定义语法糖，诸如 1+1i 注意，这里 i 前面的 1 不能省略。相关函数包括取实部 real 、取虚部 imag 、取共轭 conj 、绝对值 abs 和幅角 arg （也可以用 angle 函数）。使用complex类型构造函数 complex 也可以构造一个复数。 例子： a = 1+1i; // a = complex(1,1); b = conj(a); // b = 1-1i c = abs(a); // c = sqrt(2) d = arg(a); // d = pi/4，用d = angle(a)相似 字符串类型（String） EWSL支持字符串类型。定义字符串的方式包括双引号 "abc" 、单引号方式 "abc" 以及多行字符串（无转义字符串） """abc""" 。使用 print 函数可以打印显示，使用 .. 实现字符串的串联功能。复杂的用法见 字符串高级功能 。 定义字符串例子： a = "Hello world!"; b = "Good Luck"; c = """ What you want is what we try to achieve. """ EWSL支持宽字符作为变量，例如可以定义 我=1024 ，也可以使用特殊字符串，这时候必须使用反撇记号( ` )，如 `a-&gt;b`=value; 这样给一个名叫 a-&gt;b 的变量进行赋值。 3.2. 变量表（Variable Table） EWSL支持变量表类型。所谓变量表，本质上是一个字典（Dictation），即一个名称（字符串类型）作为键值（key）映射到一个任意变量的数据结构。变量表用 table 函数定义。 /* 常规定义方式 */ tbl = table(); tbl.x = 1; tbl.y = "abc"; tbl.t = table(); tbl["u"] = [1,2,3]; /* table 直接定义内容的方式，格式对齐可以便于阅读 */ tbl2 = table{ a : 1; b : [1;2;3]; c : "abc"; d : table { x : 0; y : 1; z : 2 } } /* table函数的定义方式 */ tbl3 = table( "a", 1, "b", [1,2,3], "c", "abc", "d", table( "x", 1, "y", 2 ) ) 三种定义方式适用不同情况： (1) 直接定义适合于一般的动态添加子变量的情况。 (2) 用table{}语法糖适合于在程序中直接定义静态的数据结构。 (3) 用table()函数方式适合于用户用程序方式生成参数表，以及一些特殊子变量名称的定义。 变量表引用的方式可以使用 . 也可以使用 [] 的方式： tbl = table("a", 1, "b", 2); tbl.a = 1; tbl["b"] = "xyz"; 使用 . 相当于使用静态的代码字符串字面量作为索引键值，使用 [] 相当于使用一个字符串变量的内容作为键值。 使用 [] 时可以定义一些特殊的名称，不必顾及变量名与语法关键词、算符重名的情况，当作一个通用字典数据库时，推荐使用该方法。 3.3. 数组（Array） EWSL语言支持两类数组，一类由动态类型变量作为值，另一类指定了某种数据类型。动态变量数组可以直接使用方括号（ [] ）定义： a = [1,2,3,4]; b = ["a", "b", 3, 4]; c = []; d = [table("a", 1, "b", 2), 1, 2, 3]; e = [function(x){return x;}, function(x){return x+1;}, math.add, math.sin]; EWSL支持用分号分隔符来定义2维数组： a = [ 1,2,3; 2,3,4; 3,4,5 ] 动态变量类型的数组，允许存入任何变量类型，包括 nil 值类型。 对于数值计算来说，用户可能需要使用特定数据类型数组， EWSL支持： 整型数组 浮点数组 复数数组 用户可以使用“类型构造函数”将动态数组转换成上述三种类型数组： a = integer([1,2,3]); b = double([1,2,3]); c = complex([1,2,3]); 提示1：上述构造函数支持尽可能将字符串转换为数字的功能。转换失败将抛出错误信息。 提示2：EWSL的数组最大支持6个维度，且支持数组嵌套（数组的数组） 数组的其他操作还包括 push 向数组尾部追加元素（一种成员方法，参看 面向对象编程 ） size 函数返回数组的大小 trans 返回二维数组的转置 3.4. 函数（Function） EWSL支持用户自定义函数，定义方式使用 function 关键词或者 def 关键词均可。使用 return 关键词表达函数的返回值。 EWSL的函数支持： 不定参数个数和参数包（Parameter Package，即 ... ） 函数的递归调用（Recursive Call） 多返回值（Multiple Returned Value） 函数体内定义函数 函数可作为变量的值 例如，我们定义一个求和函数： function mysum(...) { local s = 0; for_each(v in [...]) { s = s + v; } return s; } 定义一个阶乘函数： function factorial(n) { if(n==1) { return 1; }else { return self(n-1)*n; } } 函数递归调用时，建议使用self关键词，可以防止出现内存泄漏问题。 函数作为变量的值，并且内部再定义一个函数： local myfunc = function(op) { local candidate = table( "hello", function() { return "Hello!"; }, "good_luck", function() { return "Gool Luck!"; }, "go_home", function() { return "Go Home!"; } ); local default_func = function() { return "Unknown!"; }; if(nil==candidate[op]) { return default_func; }else { return candidate[op]; } } EWSL支持匿名函数语法糖，使用 @(args,...){...} 的方式定义，使用时如下： map(@(x){return x+1;}, [1,2,3]) 函数进一步的使用请参考： 闭包 和 函数式编程 两部分内容。 3.5. 类和对象 EWSL提供了面向对象编程支持，支持用户定义类型和对象，并且重载相应的接口函数。 EastWave 7 文档 类（class）的概念表达的是对一族对象的性质的抽象，定义一个class，意味着任何属于这个类的对象都应当具备这个class规定的接口和数据。 类型的定义由一段EWSL脚本生成，起始用关键词 class 表示，定义成员用 self. 或者 self[member_name] 的方式。定义成员函数有两种方式，一种为动态绑定的成员函数，用 function self.func(...){...} 来定义，另一种用 function meta.func(...){...} 来定义。 class T { self.x = 0; self.y = 0; self.z = 0; function meta.length() // 元表函数，静态绑定，同一个类型的所有实例对象公用一份 { return sqrt(self.x^2 + self.y^2 + self.z^2) } function meta.__get_index__(ind) // 元表函数，静态绑定的索引算符 { switch(ind) { case 0: return self.x; case 1: return self.y; case 2: return self.z; } } function self.bind(f) // 普通成员函数，动态绑定，每个实例对象均有一份 { return f(self); } } 使用类可以定义一些动态的数据结构，提升程序的可读性。经过特别设计的类可以作为接口类对数据进行分类管理。 4. 过程控制结构 EWSL提供了条件分支和switch分支、循环、条件循环几种过程控制结构：  1. if 语句 语法： if 关键词后带一个括号，括号中为一个条件表达式，返回值为布尔值。如果为 true 则执行第一个语句块中的语句，如果 false 则执行 else 关键词后的语句块。例如： if(typename(v)=="string") { print("v is a string-typed variable."); }else { print("v is not a string-typed variable."); } if 语句允许使用初始化语句如： if(local a=10; local b=0; x&lt;a &amp;&amp; x&gt;b) {...} 。 2. switch(){case ... } 语句 语法： switch 后的括号中是一个值表达式，求出的值和 case 分支后的常量值进行匹配。若匹配执行 case ..: 冒号后的语句（直到下一个 case 分支或者 default 默认分支之前）。例如： switch(val) { case 0: print("value = 0"); case 1: print("value = 1"); case 2: print("value = 2"); default: print("other value"); } 注意：与C/C++不同， case 分支不需要用 break 语句跳出分支结构。 3. for 和 for_each for 表达循环控制结构： 语法： for(&lt;init-statement&gt;;&lt;loop-condition-expr&gt;;&lt;iteration-statement&gt;) { &lt;loop-statement&gt; } for 关键词后面的括号里用分号隔开为三项，第一项表示循环前初始化语句，第二项表示循环继续条件表达式，第三项是循环迭代语句（一般用于计数），例如： s = 0; for(local i=0; i&lt;100; ++i) { s += i; } print(s); 在 for 循环体内，可以使用 break 提前跳出循环；使用 continue 跳过循环内语句的后续部分，直接进入下一轮循环过程。 for_each 语句： 语法： for_each (i, v in lst) // or for_each(v in lst) { &lt;loop-statement&gt; } for_each 取目标数组或变量表的索引和值进行迭代，允许省略索引值而只使用值进行迭代。这种语法的好处是能写出意义更加清楚地循环结构。 建议1： for 循环中的初始条件语句可以定义变量，建议使用 local 关键词限制其作用域，防止循环变量污染全局名字空间。  建议2：在 for 循环中谨慎使用 break 和 continue 等跳转语句以及过于复杂的分值判断，滥用可能过程逻辑变得不够清晰。复杂循环的编写可参考 函数式编程 部分内容。  建议3：简单循环尽量使用 for_each 语句来替代 for 循环。  4. while 和 do-while 条件循环控制结构： 语法： // while loop structure while(&lt;loop-condition-expr&gt;) { &lt;loop-statement&gt; } // do-while loop struture do { &lt;loop-statement&gt; }while(&lt;loop-condition-expr&gt;) 其中 while 循环方式的循环判断处于每次循环过程之前，而 do-while 循环的判断处于每次循环过程之后。两者的差别主要在进入循环时是否要先执行一次循环体过程。 在 while 循环体内，与 for 循环类似，可以使用 break 提前跳出循环；使用 continue 跳过循环内语句的后续部分，直接进入下一轮循环过程。 建议：在 while 循环中谨慎使用 break 和 continue 等跳转语句以及过于复杂的分值判断，滥用可能过程逻辑变得不够清晰。复杂循环的编写可参考 函数式编程 部分内容。 5. 编写文件读写与字符串处理 5.1. 文本文件的读写 EWSL的io库中提供了 io.readfile 和 io.savefile 两个函数。 io.readfile 。 下面是一个文本文件示例：（文件名为example.txt） I have a dream that one day this nation will rise up and live out the true meaning of its creed: "We hold these truths to be self-evident: that all men are created equal." I have a dream that one day on the red hills of Georgia the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood. 我们在EWSL交互式命令环境下输入： &gt;&gt; content = io.readfile("example.txt") 返回值赋值给变量 content ，内容就是 "example.txt" 文件的内容。 如果我们要将文件保存出去，可以使用 io.writefile 函数，函数的第一个参数是文件路径（字符串），第二个参数是文件的内容字符串。 content = "Martin Luther King: r n" .. content; io.writefile("output.txt", content); 注意：Windows操作系统的换行符是 r n ，Linux操作系统的换行符是 n ，而MacOS操作系统的换行符是 r 。 5.2. 从文本文件中导入数组（需要改进） 使用 io.load_txt 函数可以导入文本格式的数组： &gt;&gt; arr = io.load_txt("array.dat"); 反之，使用 io.save_txt 函数将数组导出到一个文本文件。 &gt;&gt; a = ones(3,3) 5.3. 文件流的支持（尚未实现） 5.4. 字符串的处理 5.4.1. 字符串的分解和拼接 将读入的文本文件做简单的分析，一般而言，通常我们考虑将文本文件拆分成行(lines)和词(words)。string库提供了 string.lines 函数和 string.words 函数用来分解文本。下列程序： line = content.lines(); word = map(function(x){return x.words();}, line); 可以得到一个嵌套数组（ word ），最外层是行，内层是词， word[i][j] 表示第 i 行、第 j 个词的内容。 反过来，如果我们将词语数组重新组装为一个字符串，需要使用 string.join 函数。 string.join 函数接受一个分隔符和一个字符串数组，将分隔符插入到字符串数组的相邻两个字符串之间，返回最终组装的完整字符串。下列程序： s = string.join(" r n", map(function(x){return string.join(" ",x);}, [ ["abc", "def"], ["xxx", "yyy"] ])); 可以将嵌套字符串数组中的词语先用空格分隔后连接起来，然后再形成行（插入换行符）。 6. 编写数值计算程序 6.1. 数值积分与微分 附录：常用函数列表 全局函数： pcall 容错函数调用 map 和 mapkv 函数 foldl 和 foldr 函数 filter 过滤器函数 array_concat 数组拼接函数 length 和 size 函数 reverse 函数 io库函数 save_txt 和 load_txt 函数 save_var 和 load_var 函数 puts 、 print 、 println 打印函数 parse_xml 、 parse_json 、 load_json 和 load_xml 函数 string库和字符串函数 string.length 成员函数 string.upper 和 string.lower 成员函数 string.substr 成员函数 string.split 、 string.words 和 string.lines 成员函数 split_word 和 split_line 函数 reverse 函数 format 函数 join 函数 操作系统API(os库) time 函数 sleep 函数 shell 函数 execute 函数 getenv 函数 getcwd 、 setcwd 函数 dir 函数 remove 、 rename 、 mkdir 、 rmdir exit 函数 数学函数（math库） add 、 sub 、 mul 、 div 、 dot_mul 、 dot_div 、 dot_pow 、 pow 、 sqrt 、 log 、 log10 sin 、 cos 、 tan 、 sinh 、 cosh 、 tanh 、 sind 、 cosd 、 tand 、 asin 、 acos 、 atan 、 atan2 、 atan2d 、 asinh 、 acosh 、 atanh 绘图函数（fig库） plot 、 imagesc 、 polar 、 polar3d title 、 xlabel 、 ylabel 、 xlim 、 ylim 、 rlim axis 函数 ',title : 'MX脚本语言',flags : 0,children : [{file:'./data/help_script_Preface.htm',name : 'help_script_Preface',body : '前言 EWSL，即EastWave Script Language，是在上海东峻EastWave V3至EastWave V6版本中的数据后处理脚本语言发展而来的一款全新通用脚本语言。EastWave V7不仅仅集成了最新的EWSL脚本语言，而且全新的EastWave架构内核与EWSL的联系更加紧密，从前处理、后处理到界面定义、求解器调度，基本上EastWave的大多数功能都可以通过EWSL进行定义。 新版本EWSL一方面作为EastWave建模的嵌入式编程语言，另一方面由于其高效的核心架构，也可以作为一款通用脚本编程语言，用于数据可视化、文本数据处理、SHELL编程替代以及网络服务器等方面。 如果您在使用中有任何技术问题或者意见，请登陆 上海东峻信息有限公司主页 ，或者投递邮件至 公共邮箱 、 技术支持 。 如果您对上海东峻的产品或者技术服务感兴趣，请联系 市场部门 ，联系电话：021-52385879-0。 ',title : '前言',flags : 0,children : []},{file:'./data/help_script_Introduction.htm',name : 'help_script_Introduction',body : '简介 EWSL是一款面向工程建模与仿真、数值分析等领域的高级程序语言。EWSL主要解决数据可视化、数值计算等与仿真分析密切联系的程序设计问题。其典型用途包括： 自动化数据处理与可视化 数值仿真算法的快速原型 EastWave参数化仿真模型的定义 EastWave插件的定义 运行EWSL解释器 简单例子 约定 ',title : '简介',flags : 0,children : []},{file:'./data/help_script_Getting_Started.htm',name : 'help_script_Getting_Started',body : '入门 第一个程序 和大多数程序设计语言一样，我们还是先给出一个输出 Hello World! 的小程序。我们可以打开交互式运行环境，在命令行提示符 &gt;&gt; 后输入下面的命令： &gt;&gt; print("Hello World!") Hello World!  使用帮助 使用 help 函数可以调取有关对象的帮助信息，例如： &gt;&gt; help(sin) math.sin: 计算数组或数值的正弦值 alias: sin usage: sin(1.3); sin((0:10:180)*3.1415/180); example: PI=3.14159265; param = 30.0; result = sin (param*PI/180); println(result); 算术表达式 MX支持常见的算术表达式用来快速计算一些式子，例如我们要计算$ dfrac{1 + sqrt{5}}{2}$的数值，可以在交互式运行环境中输入： &gt;&gt; (1 + sqrt(5))/2 result: 1.61803 注意： 在算术表达式中，采取常规的中缀模式（即二元运算符处于操作数的中间）。 括号的优先级最高。 支持常见的加减乘除运算( +,-,*,/ )、乘方运算（ ^ ）。 在 math 模块下有一些常用的数学函数。 字符串的打印和连接 MX可以用三种方式定义字符串： 双引号括起来 单引号括起来 三个单引号括起来的多行字符串 例如： a = "abc"; b = ""abc""; c = """ John: What can I do for you? Marry: I need some cofee. Thank you very much. John: That" all right. 注意： 使用单双引号时，注意使用转义字符  对有关字符进行转义。 使用单引号可以不必对双引号进行转义，使用双引号可以不必对单引号进行转义。 使用三个单引号的多行字符串，可以不使用转义字符串，但是中间不可以再出现连续的三个单引号。 下面是转义字符表： 转义字符 含义  t  制表位  b  退格  s  空格  r  回车  n  换行   字符  "  双引号"  "  单引号"  注释 MX使用C++风格的注释，分别支持单行注释符( // )和多行注释符( /* ... */ )两种模式。 例子： println("Hello"); // 这是单行注释 /* 这是多行注释 * 1. 定义一个二元函数f，返回两个参数的和 * 2. 定义一个一元函数g，输入参数为z，返回一个一元函数，参数为x，其行为是返回x+z的值 */ f = function(x,y) { return x + y; } g = function(z) { return function(x) { return x + z; }; } 使用函数 我们可以定义一个函数，将输入的参数加1并且返回： function my_func(x) { return x + 1; } MX中的函数如同普通值（如整数、浮点数等）一样是一等公民，可以赋值给任何一个变量符号。例如： &gt;&gt; f = my_func; &gt;&gt; g = my_func; &gt;&gt; f(10) 11 &gt;&gt; g(20) 21 使用数组 MX可以定义一个数组，数组可以进行简单的四则运算： &gt;&gt; xs = [1,2,3,4]; &gt;&gt; ys = [3,4,5,6]; &gt;&gt; zs = xs + ys [4,6,8,10] &gt;&gt; ws = ys - xs [2,2,2,2] 注意： 使用 ; 可以告诉交互式编程环境不输出当前表达式的值，如果不写 ; ，那么会打印当前表达式的值。 使用变量表 MX可以定义变量表，用来保存复杂的数据： &gt;&gt; student = table { name : "Jack"; gender : "male"; age : 18 }; &gt;&gt; print(student.name) Jack &gt;&gt; print(student.gender) male &gt;&gt; print(student.age) 18 保存和载入数据 MX可以将变量内容保存成外部文件，或者从外部文件中读入数据： &gt;&gt; xs = [1,2,3,4]; &gt;&gt; io.save_var("D: Temp xs.ewd", xs); &gt;&gt; ys = io.load_var("D: Temp xs.ewd") [1,2,3,4] 注意： 如果要保存多个数据可以先将数据装入一个变量表或者数组，然后再保存出去。 MX可以支持普通数组导出为文本格式，或者从文本格式中读入一个数组，使用 io.save_txt 和 io.load_txt 函数： &gt;&gt; xs = [1,2,3,4]; &gt;&gt; io.save_txt("D: Temp xs.txt", xs); &gt;&gt; ys = io.load_txt("D: Temp ys.txt", ys); 注意： 二维以下数值可以用文本格式直接表示，对于维度更高的情况建议使用 io.save_var 和 io.load_var 来实现。 数据的绘图 MX支持绘图功能。例如创建简单的曲线图： &gt;&gt; xs = linspace(0, pi * 2, 361); &gt;&gt; ys1 = cos(xs); &gt;&gt; ys2 = sin(xs); &gt;&gt; myfig = fig.new_figure(); &gt;&gt; fig.plot(xs,ys1); &gt;&gt; fig.plot(xs.ys2); 打开 myfig 节点可以查看： ',title : '入门',flags : 0,children : []},{file:'./data/help_script_Installation.htm',name : 'help_script_Installation',body : '安装 ',title : '安装',flags : 0,children : []},{file:'./data/help_script_Types.htm',name : 'help_script_Types',body : '类型 EWSL是一种动态类型语言，因此一个变量在其生命周期中类型可能会发生变化。此外，部分脚本函数对输入参数进行了隐式类型转换，不要球输入参数的类型是某种唯一确定的类型。 基本类型 EWSL支持以下几种基本数据类型： 空类型 布尔类型 整数类型 双精度浮点数 复数类型 字符串类型 数组类型 整数数组 双精度浮点数组 复数数组 动态类型数组 变量表类型 其他类型 基本类型拥有其独特的类型ID号，使用 typeid(var) 函数来获取变量 var 的类型ID。在交互式编程环境下输入下面的命令会返回相应的类型ID号： &gt;&gt; typeid(true) results: 1 &gt;&gt; typeid(1) results: 2 &gt;&gt; typeid("abc") results: 5 EWSL支持的类型的符号与ID 类型名  类型符号  ID  空类型  nil  0  布尔型  bool  1  整数型  integer  2  浮点型  double  3  复数型  complex  4  字符串  string  5  变量表  variant_table  6  整数数组  array_integer  7  浮点数组  array_double  8  复数数组  array_complex  9  动态类型数组  array_variant  10  其他类型   15  EWSL支持 函数 、 闭包 、 类和对象 等复杂类型，这些类型使用 typeid 函数获取ID，返回15。 普通 变量 可以直接通过赋值行为进行定义，在EWSL中使用等号 = 表示赋值过程： a = 1; // 变量a赋值为一个整数，值为1 b = 2.0; // 变量b赋值为一个浮点数，值为2.0 c = 1+2i; // 变量c赋值为一个复数，值为1+2i d = "hello"; // 变量d赋值为一个字符串，值为"hello" e = false; // 变量e赋值为一个布尔值，值为false（假），另外true表示真 t = table{ x:1; y:2.0; z:"abc" }; // 将变量t赋值为一个变量表，包括三个子变量t.x、t.y、t.z h = [1,2,3,"abc"]; // 变量h赋值为一个动态类型变量 g = integer([1,2,3]); // 变量g赋值为一个整数数组 u = double([1,2,3]); // 变量u赋值为一个浮点数组 v = complex([1,2,3]); // 变量v赋值为一个复数数组 注意事项： 使用方括号 [] 和逗号 , 直接构造的数组是动态类型数组，必须使用相应的类型转换函数才能将其转换为确定的数值类型数组。 变量表的定义要求使用关键词 table 开头，然后用大括号对 {} 将内容括起来，中间的内容必须使用冒号 : 作为子变量定义的符号，并且使用分号 ; 作为不同子变量定义的分隔符。 使用 table() 函数可以创建一个空变量表。 类型说明 空类型NIL 空类型是一种特殊的类型，可以认为是一种只有一种取值，而这个值（ nil ）恰好又等于该类型本身的一种类型。有时空类型可以被称为“底类型”（Bottom Type）。为了区别含义，大写的 NIL 表示空类型的类型，而小写的 nil 表示空类型的数值。  空类型具有一些特殊的性质和用法，例如清除一个变量的内容，可以对这个变量赋值一个 nil 。如： a = [1,2,3,4]; a = nil; // clear a"s content 利用空类型可以参与布尔运算的特点，作为函数参数默认值定义的一种方案。例如： function(a,b,flag) { a = a || 0; // default value is 0 b = b || "xyz"; // default value is a string "xyz" flag = c || true; // default value is true } 利用空类型可以产生特殊的语法规则，避免歧义。例如 max 函数： max(A,nil,0) // the second argument is nil, it means to calculate the maximum along DIM 0 max(A,0) // it means to calculate the max of A and 0  布尔类型 布尔类型是逻辑代数（布尔代数）的取值类型，包括 true 和 false 两种类型，分别对应“真”和“假”的概念。  在布尔代数中主要包括了逻辑或、与、非、异或等运算，一般我们使用逻辑运算符表示： 说明： 利用 关系运算符 可以得到布尔值。 布尔类型是 条件分支结构 和 条件循环结构 必须的数值类型。 逻辑运算符 算符  意义  备注  &&  逻辑与   ||  逻辑或   ^^  逻辑异或   !  逻辑非   例如： b = 0; a = 1 &gt;= b; // evaluate a relation expression to get a boolean value if(a) // if-else structure { println("1&gt;=b"); }else { println("1&lt;b"); } 布尔值类型转换规则： 空值 nil 转换为 false 。 整数、浮点数、复数转换规则：非零数转换为 true ，零转换为 false 。 字符串转换规则：空字符串转换为 false ，非空转换为 true 。 其他类型转换为布尔值的 行为未定义 。 布尔值不能向上转换为其他数值类型。 整数型 整数类型是表达有符号整数的一种方式，使用64bit的内存空间储存一个整数值。整数类型是最基本的算术计算。使用 integer.MAX_VALUE 和 integer.MIN_VALUE 获得整数类型的上界和下界。  双精度浮点数  双精度浮点数是实数的离散表达形式，使用64bit的内存空间储存一个双精度浮点数。浮点数类型支持算术计算。使用 double.MAX_VALUE 和 double.MIN_VALUE 可以获得正浮点数的最大表示和最小表示（注意并不是最大浮点数和最小浮点数）。程序中引用浮点数常量数值时可以使用科学技术法如： +1.500e--3 表示 0.0015 。 复数型 复数类型是由两个双精度浮点数分别表示实部和虚部，使用128bit的内存空间储存一个复数。复数支持算术计算。使用 complex.i_unit 可以获得单位纯虚数。引用复数常量数值时可以用 i 表示虚数，例如： 1+1i 表示复数$1+i$，单位虚数 1i 要在符号 i 前加上数字 1 以区别于普通变量符号 i 。 字符串类型 字符串类型是基本类型之一，EWSL没有提供专门的字符类型，也没有将字符串等同于字符数组类型。字符串类型的常量使用单引号对 "" 、双引号对 "" 或者三个单引号对 """ ... """ 来定义。使用双引号和单引号时需要考虑转义字符，使用  作为转移符号；使用三个单引好时，可以定义多行字符串，程序中的字面字符串将不考虑转义直接转化为常量字符串，但是其中不能再出现三个连续单引号。 双引号和单引好定义字符串： a = "abc" // a word abc b = ""abc"" // a string "abc" (with double quote) c = """ // just a single quote " C风格多行字符串：（双引号可以用单引号替换掉） a = "Johny is a good boy. n" "Marry is a nice girl. n" "Their father is an engineer." 三个单引号定义 """ China is a greate nation. Beijing is the capital of China. Shanghai is another city of China. """ 数组类型 数组类型将一组同类型或不同类型元素按照数组的形式组织起来，并且可以使用下标引用数组中的每个元素。数组类型使用算符 [] 获得数组中的元素或者子数组。当数组变量使用 [] 引用元素或者子数组并且处于赋值符号 = 的左侧，即作为左值引用的时候，相应下标的元素成为左值引用的对象，即可以对数组的元素和子数组进行局部赋值。一些赋值自操作的运算符（诸如 += 、 -= 、 *= 之类）也有类似的作用。例如： a = 1:10; a[5] = 20; a[7] -= 10; /* a = [1,2,3,4,5,20,7,-2,9,10] */ EWSL支持二维数组的直接定义语法，使用逗号 , 表示列分隔， ; 表示行分隔的方式（类似于 Matlab ）来实现，例如： a = [1,2,3; 4,5,6; 7,8,9] 上面的例子定义了一个3x3的二维数组。 注意： EWSL的数组下标从 0 开始索引，不同于 Matlab 。 EWSL的数组下标中可以使用 end 关键词来表示这个维度下标的最后一个索引编号。例如 a = 0:9 则 a[end]==9 。 阅读 数组函数 相关内容。  整数数组 每个元素都是整数的数组。类型名为 array_integer 。 双精度浮点数数组  每个元素都是双精度浮点数。类型名为 array_double 。 复数数组  每个元素都是复数。类型名为 array_complex 。 动态类型数组 每个元素的类型为动态变量类型，即可以是任何类型。类型名为 array_variant 。可以用动态类型数组来表示字符串数组、变量表数组、函数数组、类实例数组等。使用方括号构造算符 [...] 可以直接构造一个动态类型数组，例如 a = [1,2,3,4,"abc"] 构造的是一个动态类型数组，数组中包含了整数和字符串两种类型的数值。 [...] 可以递归调用，即可以定义数组的数组，例如： a = [[1,2,3],[2,3,4]] 变量表类型 变量表类型是一种将键值（key，字符串类型）和一个数值（value，任意类型）关联起来的一种数据类型，非常适合存储具有特定含义的参数集，例如配置文件、字典文件等。 变量表使用 . 和 [] 来索引数据。 a.x 和 a["x"] 的效果是一样的，他们的差别在于：使用 . 要求键值必须是程序字符串的字面值，而使用 [] 时键值可以是字符串变量。 变量表构造方式有两种，一种是调用函数 table(key1,val1,key2,val2,...) ，另一种是利用 table{...} 语法糖，具体例子如下： a = table("name", "John", "age", 18, "height", 180); b = table{ name: "John"; age: 18; height: 180 }; 上面的两个例子构造的 a 和 b 变量表的内容是完全相同的。 其他类型 EWSL支持其他类型，例如函数、闭包、类和对象实例等。 相关阅读 入门 EWSL程序设计阶段 I EWSL程序设计阶段 II ',title : '类型',flags : 0,children : []},{file:'./data/help_script_Variables.htm',name : 'help_script_Variables',body : '变量 变量的概念 在EWSL中，预先定义一个变量后，可以在后续（一定范围内）的程序中通过引用该变量的符号来使用其内部值。在程序代码中 直接定义 （ 间接定义 ）的变量的符号名称必须是一个可见符号的序列，并且符合下列条件： 英文字母、数字、下划线，大部分普通宽字符（包括中文字符）。 开头第一个字符不允许是数字。 大小写敏感。 下划线开头的变量通常为内部使用，在用户的主程序中不应使用此类名称作为重要的变量名字。 变量的求值 求值（Evaluation）是程序语言中的重要概念，是指对一个指定的符号计算其内部的数值的过程。EWSL采用立即求值（Eager Evaluation）策略，即使用符号的时候要求确保该符号的数值已被求值。除了“短路逻辑”（Short-Circuit Logic）的特殊规定以外，表达式、普通语句中的变量符号都是立即求值的。例如，我们打印一个变量的内容时，实际上内部确保这个变量符号的数值已经被计算出来，我们才可以把它的值打印在屏幕上。变量求值过程发生在定义和赋值阶段，因此，一般不需要考虑某个表达式或者语句在运行的时候某个变量符号的值没有被求值的情况。 变量的作用域 在现代程序设计语言中，变量的作用域（Scope）非常重要，EWSL中主要区分两种作用域的变量，一种被称为“全局变量”，另一种被称为“局部变量”。两者的生命周期有所不同。 全局变量，即 global variable ：其生命周期从其定义开始，如果没有显式的清除全局变量的命令，那么它将存在于整个程序的运行周期，直至程序结束为止。 全局变量可以被脚本程序、定义的函数所见。 全局变量存放在全局变量表中，用户可以使用 _G 这一代理符号引用全局变量表。 在仿真计算后处理的结果中，大部分结果都以全局变量的形式存在。 建议：谨慎定义全局变量。 局部变量，即 local variable ：其生命周期从其定义的位置到其所在的语句块结束。 闭包 捕获的局部变量：其生命周期为所有捕获它的闭包的生命周期结束。 补充说明： 函数或者闭包中定义的变量符号，试用的是词法作用域（Lexical Scope），这些变量的意义在函数定义的时候就已经确定下来，有些语言（如早期的LISP语言）采用动态作用域（Dynamic Scope），这种语言的函数中引用的变量符号在调用的地方才确定其含义，可能导致其行为与调用处有关。如果要模拟动态作用域的效果，可以试用 eval 函数，调用一段程序代码的字符串，具体内容参考 eval 和 程序的编译和解释 。 变量的定义 一般来说，用户可以直接使用赋值 = 来定义一个新变量，并且在变量名称符号前加上 global 或者 local 来表示其作用域。例如： a = "def"; // define a variable "a" (maybe local or global which is dependant with a environment variable) local b = 123; // explicitly define a local variable "b" global c = 25.0; // explicitly define a global variable "c" local func = function(x){return x/2;}; // explicitly define a local variable which is binding to a function. 特殊名称的间接定义 EWSL可以定义特殊名称的变量，可以使用反引号对（ `varname` ）来定义一个叫 "varname" 的变量， varname 可以是各种字符串，包括带有空格、使用数字开头等。例如： `1`=2 上面的例子命名了一个叫做 1 的变量，其值为 2 。 全局变量表代理 _G 当一个函数局部定义了一个变量名与全局变量名字相同的时候，就不能直接通过变量的名称来引用全局变量，此时可以使用 _G 的一个全局变量表代理来引用，例如： global a = 1; local a = 2; local b = 3; // add a local variable named "b" _G.b = 4; // add a global variable named "b" println(a); // output 2 which refered to the local variable named "a" println(_G.a); // output 1 which refered to the global variable named "a" 系统常（变）量 EWSL运行时环境在初始化时设置了一个 系统变量表 ，实际上存放了系统公用的一些常量，包括函数等用户不能直接修改的内容。数学常量 pi 、数学函数如 sin 、 cos 等都是系统常量。尽管用户在全局变量表和局部变量表中都看不见它们，但是可以引用它们。注意名字引用的优先次序（不加上 global 和 local 标识符的情况）： 当前代码块中的局部变量 上层代码块中的局部变量 全局变量表中的变量 系统常量 ',title : '变量',flags : 0,children : []},{file:'./data/help_script_Programming_I.htm',name : 'help_script_Programming_I',body : 'EWSL程序设计阶段 I 表达式 表达式是构建EWSL语句的基本单位。我们将一个表达式赋值给一个变量，或者打印这个表达式的值，或者将表达式作为参数传递给某个函数时，也就对这个表达式进行了 求值 的动作。 下面是几个表达式的例子： 算术表达式 x1*y1+x2*y2 逻辑表达式 () 数组引用表达式 a[1:100] .* b[2:101] 字符串构造表达式 "abc".."def" 表达式中引用到一些运算符，分为下列几类： 算术运算符 算符  意义  备注  +  加法   -  减法  二元运算符  -  取负  一元运算符  *  乘法   /  右除   ^  指数    左除   %  取模   ++  自加1  两侧均可放置  --  自减1  关系运算符 算符  意义  备注  &gt;  大于   &lt;  小于   &gt;=  大于等于   &lt;=  小于等于   ==  等于   !=  不等   ===  对象等于  两个变量引用的内存对象是否一致  补充说明： 关系运算不支持复数类型。 逻辑运算符 算符  意义  备注  &&  逻辑与   ||  逻辑或   ^^  逻辑异或   !  逻辑非   位运算符 算符  意义  备注  &  位与   |  位或   ^  位异或   ~  反码   &lt;&lt;  左移位   &gt;&gt;  右移位   数组运算符 算符  意义  备注  .+  加法   .-  减法   .*  乘法   ./  右除   .  左除   .^  指数   []  索引   其他运算符还包括： 其他运算符 算符  意义  备注  =  赋值   +=  自增   -=  自减   *=  自乘   /=  自右除   =  自左除   ^=  自乘方   &=  自位与   | = 自位或   &lt;&lt;=  自左移   &gt;&gt;=  自右移   **  函数复合  注意不要和(^)混淆  ,  逗号  函数传参等  ()  优先求值   其他特殊运算符 问号运算符 ，用于条件表达式，如下所示： ?(cond,expr1,expr2) 说明： 当 cond 为 true 时返回 expr1 ，否则返回 expr2 。 逻辑条件分支运算符 judge(x,y) { cond(x&lt;y) =&gt; print("x&lt;y"); cond(x==y) =&gt; print("x==y"); cond(x&gt;y) =&gt; print("x&gt;y"); default =&gt; print("impossible"); } 算符遵循优先级规则： 对象优先级列表 优先级  算符  16  ++ -- ~ !  14  ^ .^  13  .* ./ . * /  12  %  10  + -  9  &  7  | &lt;&lt; &gt;&gt; 6  :  5  &gt; &lt; &gt;= &lt;= == != ===  4  &&  3  ^^  2  || **  1  ,  0  = += -= *= /= = | = ^=  注意： 其中括号算符作为优先求值的用途，其优先级实际上比上述列表中的所有算符都高，可以用来调整表达式的解析次序。 语句 控制结构 过程式编程的基本程序结构是三类控制结构：顺序结构、分支结构和循环结构。使用控制结构来实现对过程内变量和全局变量或者系统行为的操作。 顺序结构 所谓顺序结构就是一系列普通语句构成的语句序列，依照语句出现的先后顺序运行。下面是一个顺序式结构的例子： a = 10; b = 20; println("a+b=",a+b); 有些语句的顺序可以改变而不影响程序运行的效果，但是更多的时候改变语句顺序会导致程序运行结果变化，更加严重的是出现程序运行错误（如变量没有赋值之类的情况）。  建议： 避免书写过长的程序，一段子程序（或者函数、语句块）如果显著超过一个屏幕能一次容纳的行数（大约40行-60行），会使得理解程序的效率大幅度降低。 子程序内容过长时，可以使用语句块将顺序结构中的部分内容提炼出来，并且通过定义语句块内的局部变量尽量减少整个子程序上下文共享的变量。 谨慎使用全局变量。 谨慎调用系统资源（比如调用一些具有复杂行为的系统API），如果调用它，尽量将其控制在一个较小的局部过程环境中。 输入输出行为（IO）的次序不能随意打乱。 在顺序结构中涉及到的条件分支的情况下，修改程序的顺序结构时要注意判断的结果是否会影响条件。 分支结构 分支结构是实现子程序功能局部跳转的重要方法。 if-else分支 if(...){...}else{...} 语法规则如下： if(condition) { &lt;then-block&gt; }else { &lt;else-block&gt; } 其中 condition 是布尔值，如果为真（ true ）则跳转到 &lt;then-block&gt; 执行内部的语句块，否则跳转到 &lt;else-block&gt; 区块执行。  使用多层 if-else 嵌套时： if(cond1) { &lt;branch-1&gt; }else if(cond2) { &lt;branch-2&gt; }else if(cond3) { &lt;branch-3&gt; }else { &lt;branch-others&gt; } 建议： 建议不要使用复杂嵌套的 if-else 结构，可能使程序员难以理解。 平行分支判断的时候，如果选择分支超过4条建议使用 switch-case 或者 judge-cond 分支。 条件语句（ condition ）引入具有复杂外部行为（如赋值、调用外部过程）时必须非常谨慎小心，特别是使用 &amp;&amp; 和 || 运算符的时候要注意可能的短路逻辑问题。 短路逻辑  使用逻辑运算符的时候，为了提高计算效率，当第一个项被求值并且已经决定该逻辑运算符计算结果的时候，另一个项的求值过程会被忽略的情况。例如： x = 0; y==1; (x &gt;= 0 || (++y)==1 中的 y 的自加过程将被忽略掉。 问号表达式（三目运算符） 问号表达式是一个类似函数形式的表达式，用法如下： x = ?(x%2==0, x/2, x*3+1) 例子表达的意思是：“如果 x 是偶数则将自己减半，如果是奇数则将自己乘以3再加上1”（有一个数学猜想是关于这个表达式，是否对于任何自然数都能陷入到 ...,4,2,1,4,2,1,... 的循环）。  建议 ： 不要在三目表达式中引入过于复杂的计算过程。 switch-case 分支 switch-case 分支用于平行条件分支选择： switch(var) { case(const-val1): &lt;stmt1&gt; case(const-val2): &lt;stmt2&gt; ... default:&lt;stmt_default&gt; } 当变量 var 的取值等于 const-val1 时，运行语句 &lt;stmt1&gt; ；当 var 取值等于 const-val2 的时候，运行语句 &lt;stmt2&gt; ，否则调用默认行为 &lt;stmt_default&gt; 。  switch-case 分支语句要求 case 关键词后的表达式必须是普通常量，所谓普通常量是指直接的布尔值（ true 和 false 两个关键词）、整数、浮点数和字符串常量三种情况。复数、数组类型、变量是不可以作为 case 关键词后的表达式的。通常情况下我们建议仅仅使用整数和字符串两种条件下使用switch-case语句。  注意 ： switch-case 分支语句的分支之间完全隔离，不需要使用 break 关键词跳出，这一点与C语言是完全不同的。 judge-cond 分支 judge-cond 分支用于解决那些需要复杂条件判断，但是不适合使用多层 if-else 也无法使用 switch-case 分支的情况。其语法规定如下： judge(var1,var2,...) // var1, var2, ...可以省略 { cond(pred1) =&gt; &lt;stmt1&gt; cond(pred2) =&gt; &lt;stmt2&gt; default =&gt; &lt;stmt_default&gt; } 当条件 pred1 为真的时候，调用 &lt;stmt1&gt; 语句；当条件 pred2 为真的时候，调用 &lt;stmt2&gt; 语句；如果都不匹配，则调用默认的 &lt;stmt_default&gt; 。  注意 ： judge-cond 分支语句和 switch-case 类似，也不需要使用 break 关键词跳出，这一点与C语言不通。 循环结构 循环结构是一种重复运行一段语句块的程序控制方式。EWSL支持for循环、条件循环方式定义循环结构程序。 for 循环 for循环对指定语句块进行循环执行，条件不满足时退出循环。计数器式的for循环最为经典： for(local i=0; i&lt;10; ++i) { for(local j=0;j&lt;i+1;++j) { print("*"); } print(" n"); } 打印的效果如下： * ** *** **** ***** ****** ******* ******** ********* ********** for 循环常用语数组、变量表的处理。 for_each 基于键值对的循环 遍历变量表时，使用 for_each 会比普通的 for 循环更加方便： t = table{ x:1; y:2; z:3; u:4; v:5; w:6; }; for_each(k,v in t) { print(k,":",v," n"); } for_each 后的括号中， k （可以是任何有效符号名）表示键（key），而 v 表示该变量表中与键值相对应的项目值，即形成了 打印的效果如下： x:1 y:2 z:3 u:4 v:5 w:6 说明： for_each 中 k, 可以省略，遍历时只抓取元素的数值 v 。 while条件循环 使用while条件循环有两种方式，一种是前置条件模式，一种是后置条件模式 do-while ： 前置条件：当 cond 条件满足时循环，否则退出，且进入循环前判断一次。 while(cond) { &lt;loop-stmt&gt; } 后置条件：当 cond 条件满足时继续下一次循环，否则退出，无论是否满足条件都至少运行循环体一次。 do { &lt;loop-stmt&gt; }while(cond) while循环体中用 break 语句可以跳出循环。 函数 EWSL允许用户使用和定义函数。 函数调用 函数调用使用小括号 () ，括号中的是函数的传入参数。例如，我们可以调用数学库中的 linspace 函数和三角函数 math.cosd 、 math.sind ，这三个函数可以在全局名字空间直接使用，而不需要带上库名 math 作为前缀： ang = linspace(0,360,37); // 创建角度列表[0,10,20,...360]一共37个角度，均匀分布 pos = []; for(i=0; i&lt;37; ++i) { pos[i] = table{x:cosd(ang[i]);y:sind(ang[i])}; print("pos[", i, "]: ", pos[i].x, ", ", pos[i].y, " n"); // 打印二维坐标点 } 上面一段程序生成了单位圆上37个等角度均分点（其中0度和360重合）的二维坐标。打印结果如下： pos[0]: 1, 0 pos[1]: 0.984808, 0.173648 pos[2]: 0.939693, 0.34202 pos[3]: 0.866025, 0.5 pos[4]: 0.766044, 0.642788 pos[5]: 0.642788, 0.766044 pos[6]: 0.5, 0.866025 pos[7]: 0.34202, 0.939693 pos[8]: 0.173648, 0.984808 pos[9]: 0, 1 pos[10]: -0.173648, 0.984808 pos[11]: -0.34202, 0.939693 pos[12]: -0.5, 0.866025 pos[13]: -0.642788, 0.766044 pos[14]: -0.766044, 0.642788 pos[15]: -0.866025, 0.5 pos[16]: -0.939693, 0.34202 pos[17]: -0.984808, 0.173648 pos[18]: -1, 0 pos[19]: -0.984808, -0.173648 pos[20]: -0.939693, -0.34202 pos[21]: -0.866025, -0.5 pos[22]: -0.766044, -0.642788 pos[23]: -0.642788, -0.766044 pos[24]: -0.5, -0.866025 pos[25]: -0.34202, -0.939693 pos[26]: -0.173648, -0.984808 pos[27]: 0, -1 pos[28]: 0.173648, -0.984808 pos[29]: 0.34202, -0.939693 pos[30]: 0.5, -0.866025 pos[31]: 0.642788, -0.766044 pos[32]: 0.766044, -0.642788 pos[33]: 0.866025, -0.5 pos[34]: 0.939693, -0.34202 pos[35]: 0.984808, -0.173648 pos[36]: 1, 0 提示：可以尝试使用弧度制和弧度三角函数 sin 、 cos 编写一个类似的程序，看看结果有什么差别。 函数的定义 EWSL允许程序员在代码中直接定义函数。  直接定义函数，使用 def 或者 function 关键词 def 关键词和 function 关键词是等价互换的 使用 @ 替换 function 或者 def 关键词产生相同的效果，更加适合简短的匿名函数定义。 @(x){return x+1;} 与 function(x){return x+1;} 是等价的。 function f(x,y) { return sqrt(x^2+y^2); } 上述代码定义了一个计算二维坐标 (x,y) 距离原点 (0,0) 的欧式距离$r= sqrt{x^2+y^2}$的函数。  函数像值一样可以被复制给一个变量，也可以在变量直接“复制” local myfunc = function(x,sigma) { return exp(-(x/sigma)^2); } local myfunc1 = myfunc; 上述代码定义了一个计算标准高斯分布$f(x, sigma)= exp(-( frac{x}{ sigma})^2)$的函数，并且将其当作值赋值给了变量 myfunc ；然后这个函数作为值又拷贝给了 myfunc1 。 函数的拷贝并没有制作一份内存上的副本，而仅仅是通过一个引用关系共享一个函数实体。在例子中 myfunc 和 myfunc1 所指的函数实际上在内存里是同一份。 扩展阅读： 关于函数式编程，请阅读 函数式编程 相关内容。 内置函数清阅读 函数说明 相关内容。 字符串处理 查看关于 字符串类型 的帮助信息。 字符串的基本定义方法 在EWSL中直接定义字符串的方法是使用双引号 "..." 或者单引号 "..." 将字符串的内容包含起来进行表示。在这种经典定义中，需要使用一些转义字符串来定义那些特殊的符号，例如用 t 表示制表位等，具体的包括了： table 1: 转义字符 转义字符  意义  备注  r  回车   n  换行   t  制表位   f  换页符号   b  退格   s  不可见空白    反斜杠( )   "  单引号  双引号字符串中可以不转义  "  双引号  单引号字符串中可以不转义  多行字符串和免转义特性 使用经典方式定义字符串不适合书写源代码的附加文档、内嵌程序字符串，因为这些内容里包含需要过多的转义字符，并且往往需要多行才能够把内容表达完整。 使用连续三个单引号(```)或者连续三个双引号(""")作为多行字符串的开头，同样的连续字符作为配对的结束即可表达多行免转义字符穿。免转义是绝对的，因此如果在这种多行字符串块中要使用连续单引号或者连续双引号时是不行的，如果需要在内容中书写连续单引好，则使用连续双引号作为字符串标识符（定界符）；反之，则使用连续单引号作为字符串标识符。 字符和子串的索引 使用 [] 算符可以获取字符串的指定位置的字符或者子串，例如： a = "abcdefgh"; b = a[2:4]; // b == "cde" c = a[end]; // c == "h" 字符串可以像数组一样使用子串的左值引用，即子串赋值，例如： a = "abcdefgh"; a[[1,3,5]] = "123"; // change a to "a1c2e3gh" 字符串的连接 使用 .. 运算符作为字符串的连接，该算符将字符串按照从左到右的次序连接起来，对于其他非字符串类型则先尝试转换为字符串后再连接起来。例如： a = []; for(local i=0; i&lt;10; ++i) { a.push("x_"..i.." = "..(i^2)..";"); } 上面的程序构造了10个赋值语句的字面字符串（诸如 "x_0 = 0;" 或者 x_5 = 25; ）。 程序的编译和解释 模块的定义和使用 ',title : 'EWSL程序设计阶段 I',flags : 0,children : []},{file:'./data/help_script_Programming_II.htm',name : 'help_script_Programming_II',body : 'EWSL程序设计阶段 II 面向对象编程 函数式程序设计简介 协程 动态链接库 ',title : 'EWSL程序设计阶段 II',flags : 0,children : [{file:'./data/help_script_Programming_II_OOP.htm',name : 'help_script_Programming_II_OOP',body : '面向对象编程 基本概念 EWSL支持较为简洁的面向对象设计范式。包括支持 类 （class）、 类的继承 、成员变量与方法、类方法等概念。面向对象编程的核心概念是类和对象。其中类可以看成构造对象实例的模板，而对象则是根据类的规则将一组数据和方法组合成起来的一种数据结构。每个类都为各自的类实例定义了一系列的成员对象和方法，相同类的对象实例具有类似的行为特征。面向对象编程比较适合对真实世界行为的模拟和概念抽象，例如动物、人类、汽车、建筑都可以抽象为类的概念。类的概念又衍生出了子类的概念，例如我们可以定义“人”是一个类，那么“男人”就可以定义成一个子类，而“女人”可以定义成另一个子类。在许多时候，类的设计很容让程序员理解代码的含义。合理使用面向对象编程技术有利于提高程序的可读性、封装性和重用能力。 一个简单的类和对象的定义与使用的例子 class Person { self.name = "noname"; self.age = 18; self.height = 175; self.gender = "male"; }; John = Person(); John.name = "John"; John.age = 18; John.height = 180; John.gender = "male"; Marry = Person(); Marry.name = "Marry"; Marry.age = 22; Marry.height = 165; Marry.gender = "female"; 上面的例子定义了一个叫做 Person 的类，并且定义了两个对象实例分别叫做 John 和 Mary 。 定义一个类 class 关键词后跟着类名，如例子中的 Point 。 在类名后跟上大括号对 {} ，大括号之间书写类的定义。 self 关键词表示的是类的对象实例的成员域，并且是动态绑定（即每个对象实例均有一份该名字的成员），并且运行期是可变的(mutable)。 mfun 关键词表示的是类的对象实例的成员域，但是是静态绑定（即每个对象实例均共享同名的成员），在运行期是不可变的(immutable)。 meta 关键词表示类本身成员的定义，必须使用类而不是对象实例来引用（ Point.length 是合法的，而 Point().length 是非法的）。 class Point { self.x = 0; self.y = 0; self.z = 0; // meta-method // it is used as `Point.length(...)` // `Point.length` is immutable (cannot be modified) meta.length = function(p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }; // static-binded member-method // it is used as `obj.length()` // `obj.length` is immutable (cannot be modified) // predicate: (Point().length1 === Point().length1) == true (always) mfun.length1 = function() { return meta.length(this): } // dynamic-binded member-method // it is used as `obj.len()` // `obj.length2` is mutable (can be modified) like `obj.x` self.length2 = function() { return this.length1(); } }; 使用类构造对象实例 定义好类以后，把类当作函数调用运行一次即可得到默认构造的对象 如果希望构造方法多样化，建议在类的元方法中增加专用的构造函数，或者可以考虑使用独立函数进行构造。 对象实例和普通的变量表比较相似，可以使用 [] 也可以使用 . 来引用其内部成员。 p1 = Point(); p2 = Point(); p1.x = 100; p1.y = -50; p1.z = +30; p2["x"] = -100; p2["y"] = -20; p2["z"] = 30; 特殊成员方法的重载 mfun.__fun_call 或者 self.__fun_call 可以定义一个对象当作函数调用时的行为。 mfun.__add 、 mfun.__sub 、 mfun.__mul 、 mfun.__div 可以定义该对象接受算符 + 、 - 、 * 、 / 时的行为。 mfun.__gt 、 mfun.__ge 、 mfun.lt 、 mfun.le 、 mfun.ne 、 mfun.eq 可以定义该对象接受算符 &gt; , &gt;= , &lt; , &lt;= 的行为。 类的继承 当一个类 B 从另一个类 A 继承的时候，类 B 将拥有类 A 的全部特性，一般认为 B 是 A 的子类 可以使用多继承，但是不推荐，对于动态绑定的对象来说，如果出现同名成员方法将会使得对象实例的行为难以理解，应当在不至于产生混淆和歧义的前提下谨慎使用多继承。 class A { self.x = 0; self.y = 0; }; class B { self.func1 = function() { return 0; }; self.func2 = function() { return 1; }; }; class C : A { self.func1x = function() { return this.x; }; self.func1y = function() { return this.y; }; }; class D : B, C { self.g = function() { return "g"; }; self.k = function() { return "k"; }; };  上面提供了一个简单的继承和多继承的例子 作为值的类 作为动态类型的脚本语言，类也是一种特殊的值，与函数类似，可以动态定义和构造和赋值、拷贝。我们可以定义一种函数，其返回值是类，然后再用这个类去定义一系列对象实例。  function make_class(member_name1, member_name2) { local c = class { self[member_name1] = "member1"; self[member_name2] = "member2"; }; return c; };  上面的例子定义了一个可以根据参数来动态创建类的函数。这样的用法相当于创造了一种类模板的概念，即可以使用参数来生成类，再用类生成具体实例对象。这在将数据转换为对象的时候较为有用。 ',title : '面向对象编程',flags : 0,children : []}]},{file:'./data/help_script_Specifications.htm',name : 'help_script_Specifications',body : '函数表 常用函数 数学函数 数组函数 字符串函数 变量表 输入和输出 系统 与几种脚本语言的比较 ',title : '函数说明',flags : 0,children : [{file:'./data/help_script_Specifications_Common.htm',name : 'help_script_Specifications_Common',body : '常用函数 print  打印变量的值  语法： print(arg1,...)  例子： /* example 1: interactive mode */ &gt;&gt; a = 1; &gt;&gt; b = 2; &gt;&gt; print("a = ", a, ", b = ", b, " n") a = 1, b = 2  参考： println puts println  打印变量的值，并且换行  语法： println(arg1,...)  例子： /* example 1 */ a = ["abc", "def", "ghc"] for_each(_,v in a) { println(v); } /* output below: */ abc def ghc  参考： print puts puts  打印变量的值  语法： puts(arg1,...)  例子： /* example 1: interactive mode */ &gt;&gt; a = 1; &gt;&gt; b = 2; &gt;&gt; puts("a = ", a, ", b = ", b, " n") a = 1, b = 2  参考： print puts pcall  保护性调用  语法： succ, ret = pcall(fn, arg1, ...) 调用 fn ，并且将 arg1 等后面的参数传给 fn ，如果运行成功，则返回值 succ 为 true ， ret 为返回结果，否则为 false ， ret 为错误信息。  例子： /* example 1 */ function fn(x) { if(x&gt;=0) { return sqrt(x); } else { throw "negative_is_not_allowed"; } }; // use ";" to screen output "function fn" pcall(fn, 1) // unuse ";" to show the result of pcall pcall(fn, -1) // like above /* output below: */ results: true,1 results: false,negative_is_not_allowed map  映射（高阶函数）  语法： ret = map(f,arr) // directly call, arr can be a variant table. g = map(f) // lifting f to g. The result of calling g(arr) is the same with that of calling map(f, arr). 用法1：直接调用。将函数 f 映射到数组 arr 的每个元素上，计算的结果按照原先的次序重组为新的数组 ret 。 用法2：函数提升。将作用在元素上的函数 f 提升为作用在数组上的函数 g ，调用 g(arr) 与 map(f,arr) 相同。 说明：对变量表有类似作用。  例子： /* example 1 */ add1 = function(x) { return x + 1; } a = 1:10; b = map(add1, a); map(println, b); /* output below: */ 2 3 4 5 6 7 8 9 10 11 /* example 2 */ print_elm = function(e) { print(e," "); } print_arr = function(arr) { map(print_elm)(arr); println(); } print_arr(1:10); /* output below: */ 1 2 3 4 5 6 7 8 9 10   参考： mapkv foldl foldr filter mapkv  带键值映射（高阶函数）  语法： mapkv(f,arr) // Directly call in which arr can be a variant table. mapkv(f) // Lifting f to g. The result of calling g(arr) is the same with that of calling mapkv(f, arr). 用法1：直接调用。将二元函数 f 映射到数组 arr 的每对键值和值上（ f 是二元函数，第一个参数是数组的索引或变量表的键值名称，第二个参数是对应索引或者键值的元素值），计算的结果按照原先的次序重组为新的数组 ret 。 用法2：函数提升。将作用在元素上的函数 f 提升为作用在数组上的函数 g ，调用 g(arr) 与 map(f,arr) 相同。 说明：对变量表有类似作用。 /* example 1 */ a = table{ x:1; y:2; z:3 }; print_kv = function(k,v) { print(k, " =&gt; ", v, " n"); }; mapkv(print_kv, a); /* output below: */ x =&gt; 1 y =&gt; 2 z =&gt; 3   参考： map foldl foldr filter foldl  左折叠   语法： foldl(f,s,arr) foldl(f,s) 用法1：给一个二元函数 f 和一个初始值 s ， arr 是个数组或者变量表，每次从 arr 中取一个元素 x ，计算 s=f(s,x) ，如此重复迭代直至遍历完 arr 的全部元素。 用法2：给一个二元函数 f 和一个初始值 s ，返回一个函数 g ， g(arr) 的效果与 foldl(f,s,arr) 相同。  例子： /* example 1 */ s = foldl(math.add, 0, 1:10); // sum of 1 to 10 p = foldl(math.mul, 1, 1:10); // product of 1 to 10 println(s); println(p); /* output below: */ 55 3628800  参考： map foldr filter foldr  右折叠  语法： foldr(f,s,arr) foldr(f,s) 用法1：给一个二元函数 f 和一个初始值 s ， arr 是个数组或者变量表，每次从 arr 中取一个元素 x ，计算 s=f(x,s) ，如此重复迭代直至遍历完 arr 的全部元素。 用法2：给一个二元函数 f 和一个初始值 s ，返回一个 函数 g ， g(arr) 的效果与 foldl(f,s,arr) 相同。 注意： foldl 和 foldr 对第一个参数（函数）的区别在于结合方向， foldl 是“左结合”，而 foldr 是“右结合”。  例子： /* example 1 */ a = [1,3,5,7,9,7,5,3,1]; s = foldr(function(x,y){return ?(x&lt;y,y,x);}, a[0], a); println(s); /* output below: */ 9  参考： map foldl filter filter  过滤  语法： filter(pred, arr) filter(pred) 用法1：给一个一元谓词函数（返回bool值的函数被称为 谓词 ），和一个数组（或变量表），遍历其中所有元素，将元素传给谓词，如果返回为真加到结果数组中，返回的结果是所有满足谓词条件的元素集合。 用法2： filter(pred)(x) 和 filter(pred,x) 是等价的。  例子： /* example 1 */ local a = filter(function(x){return x&gt;=0;}, (-10):10); for_each(v in a) { print(v, " "); } println(); /* output below: */ 0 1 2 3 4 5 6 7 8 9 10  compose 函数的复合（高阶函数）  语法： compose(f, g) 使用函数的复合可以简单的将两个函数连接成一个新的函数，而新的函数相当于原来两个函数的连续应用 ',title : '常用函数',flags : 0,children : []},{file:'./data/help_script_Specifications_Mathematics.htm',name : 'help_script_Specifications_Mathematics',body : '数学函数 目录 数学常数 算术函数 三角函数 反三角函数 双曲函数 复数相关函数 指数与对数函数 其他常用函数 函数变换 特殊函数 数学常数 pi , math.pi  圆周率$ pi=3.14159 ldots$ math.e  自然对数的底$e= exp(1)=2.7172 ldots$ 算术运算 EWSL提供基本的算术运算函数，通常情况下使用 算术运算符 。 math.add , +  加法  语法： math.add(x,y) // function x + y // operator math.sub , -  减法  语法： math.sub(x,y) // function x - y // operator  math.mul , *  乘法  语法： math.mul(x,y) // function x * y // operator math.div , /  除法  语法： math.div(x,y) // function x / y // operator 注意事项： 两个整数之间除法如果出不进 math.pow , ^  乘方  语法： math.pow(x,n) // function x ^ n // operator 参考： 指数函数 exp 。 math.neg , - （一元算符）  取负  语法： math.neg(x) // function -x // operator math.mod , %  取模  语法： math.mod(a,b) a % b  例子： math.mod( 7, 3) // 1 math.mod(-7, 3) // 2 math.mod( 7,-3) // -2 math.mod(-7,-3) // -1 注意事项： EWSL的取模运算与 Matlab 语言和 GNU Octave 保持一致，符合数学约定，但是与C/C++的约定是不同的。 在数学中，“模”的概念与周期性有关系，因此并不是简单的除法取余。在实数轴上，对一个非零常数取余，得到的是一个周期重复，而不是中心对称的分布。 取模运算中，第二个参数是负数的时候，得到的模值也是负的。 如果需要使用类似C/C++的 fmod 函数，参考 取余 rem 。  参考： rem div math.rem  取余数  语法： math.rem(a,b)  例子： math.rem( 7, 3) // 1 math.rem(-7, 3) // -1 math.rem( 7,-3) // 1 math.rem(-7,-3) // -1 注意事项： 当第二个参数是负数的结果与其正数是相同的。 余数的符号与第一个参数相同。 余数函数关于 0 具有中心对称性，这与除法函数保持一致。 余数函数的行为与C/C++中的 fmod 函数一致。  参考： mod div 三角函数 sin , sind , sindeg  正弦函数  语法： sin(pi/2) // 1 sind(180) // 0 sindeg(30) // 0.5 sin(1+1i) // 1.29846+0.634964i cos , cosd , cosdeg  余弦函数  语法： cos(pi/2) // 0 cosd(180) // -1 cosdeg(60) // 0.5 cos(1+1i) // 0.83373-0.988898i tan , tand , tandeg  正切函数  语法： tan(0) // 0 tand(45) // 1 tandeg(135) // -1 tan(1+1i) // 0.271753+1.08392i cot , cotd , cotdeg  余切函数  语法： cot(0) // 0 cotd(45) // 1 cotdeg(135) // -1 cot(1+1i) // 0.271753+1.08392i 其它三角函数 下列函数存放于 math 变量表中，也可以在全局使用 cot = 1/tan(x) sec = 1/cos(x) csc = 1/sin(x) cotd(x) = cotdeg(x) = cot(deg2rad(x)) secd(x) = secdeg(x) = sec(deg2rad(x)) cscd(x) = cscdeg(x) = csc(deg2rad(x)) 弧度制与角度制的转换 下列函数存放于 math 变量表中，也可以在全局使用 deg2rad(x) = x / 180 * pi rad2deg(x) = x / pi * 180 反三角函数 asin , asind , asindeg  反正弦函数  语法： asin(1) // pi/2 asind(sqrt(2)/2) // 45 asindeg(0.5) // 30 asin(2) // 1.5708-1.31696i asin(-2) // -1.5708+1.31696i acos , acosd , acosdeg  反余弦函数  语法： acos(1) // 0 acosd(sqrt(2)/2) // 45 acosdeg(0.5) // 60 acos(2) // -0+1.31696i acos(-2) // 3.14159+1.31696i 双曲函数 复数相关函数 math.sign  取符号函数、复数单位化  语法： sign(1.5) // 1 sign(0) // 0 sign(-1.5) // -1 sign(1+1i) // 0.7071 + 0.7071i 注意事项： sign 函数对复数的意义相当于取单位复数。 sign 函数不改变输入参数的数值类型。 math.abs  绝对值函数、复数的模  语法： abs(7) // 7 abs(-3) // 3 abs(0) // 0 abs(1+1i) // 1.4142... 注意事项： abs 函数对复数的意义与数学习惯一致。 abs 作用于复数上的返回值类型是浮点数。 math.arg , math.angle  复数的辐角  语法： arg(1) // 0 arg(-1) // pi arg(1i) // pi/2 arg(-1i) // -pi/2 注意事项： 取值范围为弧度制角度$(- pi,+ pi]$，负实数取$- pi$。 math.real , math.imag 复数的实部与虚部  语法： real(1+1i) // 1 imag(1-1i) // -1 math.conj 复数的共轭  语法： conj(1+1i) // 1-1i 指数、对数函数 math.exp  以$e$为底数的指数函数  语法： exp(0) // 1 exp(1) // 2.7172 exp(1i*pi/2) // -1 参考： 乘方 pow math.log  自然对数（以$e$为底数的对数）  语法： log(exp(1)) // 0 log(1+1i) // 0.346574+0.785398i log(-1) // 0 + 3.14159i 注意事项： 对负数的操作将转换为对复数的操作。 复数计算结果取角度时与 arg 函数一致。 参考 俯角函数 arg 、 angle 参考 以10为底的对数 log10 math.log10  对数（以10为底）  数学上保证： $$ log_{10} x = dfrac{ log x}{ log 10} $$  语法： log10(0) // 0 log10(10) // 1 log10(-10) // 1+1.36438i 注意事项： 对负数的操作将转换为对复数的操作。 参考 俯角函数 arg 、 angle 参考 自然对数 log 其他常用数学函数 math.sqrt  平方根函数  语法： sqrt(2) // 1.41421 sqrt(1+1i) // 1.09868+0.45509i 注意事项： 对复数的运算，取角度时与 arg 函数一致。 参考 俯角函数 arg 、 angle 参考 自然对数 log max  取最大值   语法： max(a) // If a is an array, return the maximum of a"s all elements; if a is a scalar, just return itself. max(a,nil,N) // If a is an array, return the maximum of a"s elements in the N-dim; if a is a scalar, just return itself. max(A,B) // If A or B is an array (or both of them are arrays), do element-by-element compare; if A and B are scalars, just return the maximum of A and B max(a,b,c...) //  补充说明： 不支持直接在复数中取最大最小值，参阅 Matlab 关系运算符问题 。 min  取最小值  语法： min(a) // If a is an array, return the minimum of a"s all elements. min(a,nil,N) // If a is an array, return the minimum of a"s elements in the N-dim min(A,B) // If A or B is an array (or both of them are arrays), do element-by-element compare; if A and B are scalars, just return the minimum of A and B 补充说明： 不支持直接在复数中取最大最小值，参阅 Matlab 关系运算符问题 。 sum 求和   语法： sum(a) // If a is an array, return the summation of a"s all elements. sum(a,N) // If a is an array, return the summation of a"s elements in the N-dim. sum(a,b,c,...) // a,b,c,... are scalars and return the summation of them. product 求积  语法： product(a) // If a is an array, return the product of a"s all elements. product(a,N) // If a is an array, return the product of a"s elements in the N-dim. product(a,b,c,...) // a,b,c,... are scalars and return the product of them. 函数变换 傅里叶变换 傅里叶变换原理和快速傅里叶变换的算法参看 傅里叶变换与快速傅里叶变换算法 fft  快速傅里叶变换  语法： fft(X) // N-Point Fast Fourier Transform, N is the length of the first non-singleton dimension. fft(X,N) // N-Point Fast Fourier Transform under the first non-singleton dimension. fft(X,N,DIM) // N-Point Fast Fourier Transform under the dimension DIM.  用法1：N点FFT，对第一个非退化维度进行傅里叶变换，N是该维度的大小。 用法2：N点FFT，对第一个非退化维度进行傅里叶变换，N由用户设定。 用法3：N点FFT，对第DIM维度进行傅里叶变换，如果N是 nil ，则自动根据X数组的DIM维大小来确定。  参考： ifft fftshift ifftshift ifft 快速逆傅里叶变换  语法： ifft(X) // N-Point Fast Fourier Transform, N is the length of the first non-singleton dimension. ifft(X,N) // N-Point Fast Fourier Transform under the first non-singleton dimension. ifft(X,N,DIM) // N-Point Fast Fourier Transform under the dimension DIM.  用法1：N点IFFT，对第一个非退化维度进行逆傅里叶变换，N是该维度的大小。 用法2：N点IFFT，对第一个非退化维度进行逆傅里叶变换，N由用户设定。 用法3：N点IFFT，对第DIM维度进行逆傅里叶变换，如果N是 nil ，则自动根据X数组的DIM维大小来确定。  参考： fft fftshift ifftshift fftshift  快速傅里叶变换的数据移动  语法： fftshift(X) fftshift(X,N) 用法1：对 X 数组的各个维度进行傅里叶变换移位 用法2：对 X 数组的指定第 N 维度进行傅里叶变换移位 具体移位规则如下： 对于偶数长度的维度，将其分割为相等的左右两半部分，将左半部分与右半部分平移交换 对于奇数长度的维度，将其分割为左右两半部分，左部分比右部分 多 1，然后再将左半部分与有半部分平移交换 说明：时域信号傅里叶变换的频域数据对应的频点可以如下计算 // st is time-domain signal series // dt is delta t nt = length(st); df = 1/(dt*nt); left = (nt+1)/2; right = nt - left; f = double([]); f[0:(left-1)] = df * (0:(left-1)); f[left:(nt-1)] = df * (0:(right-1)) + (-df * right)  参考： fft ifft ifftshift ifftshift  快速逆傅里叶变换的数据移动，正好是 fftshift 的逆操作。  语法： ifftshift(X) ifftshift(X,N) 用法1：对 X 数组的各个维度进行逆傅里叶变换移位 用法2：对 X 数组的指定第 N 维度进行逆傅里叶变换移位 具体移位规则如下： 对于偶数长度的维度，将其分割为相等的左右两半部分，将左半部分与右半部分平移交换 对于奇数长度的维度，将其分割为左右两半部分，左部分比右部分 少 1，然后再将左半部分与有半部分平移交换  参考： fft ifft fftshift 特殊函数 fftshift ifftshift 特殊函数 ',title : '数学函数',flags : 0,children : []},{file:'./data/help_script_Specifications_Array.htm',name : 'help_script_Specifications_Array',body : '数组函数 目录 数组的属性 数组的构造函数 向量化 形式的操作 其他 数组的属性 length numel  返回数组元素个数（兼容变量表）  语法： length(A) numel(A) 补充说明： 与 Matlab 的 length 函数行为不同，请阅读 Matlab 兼容性问题 length 函数 。 如果要使用类似 Matlab 的 length 函数，请使用 math.length_ 函数替代。  参考： size size  返回数组的维度信息，包括指定维度的大小  语法： size(A) // Return a dimension size vector [6x1]. size(A,DIM) // Return the size of the dimension DIM of A.  参考： length rows columns rows  返回数组的行数  语法： rows(A) // row(A) == size(A, 0)  参考： length size columns columns  返回数组的列数  语法： columns(A) // columns(A) == size(A, 1)  参考： length rows size 数组的构造函数 a:b , a:step:b  冒号算符，用起止和步长构造等差数列  语法： 1:10 // [1,2,3,...10], when a &lt; b the default step = 1 0:(-10) // [0,-1,...-10], when a &gt; b default step = -1 1:2:10 // [1,3,5,7,9] a:0:b // [], when the step==0 it returns an empty array. 补充说明： a:b 当 a&lt;b 时，默认步长为 1 ，如果 ab 默认步长为 -1 a:0:b 即步长为 0 的时候，返回空数组 输入参数均为整数时，返回的序列为整数序列 不兼容复数类型，除非复数参数的虚部是 0 ，则当做实数处理  参考： linspace linspace  使用端点和点的个数构造等差数列  语法： linspace(0,10,11) // [0,1,2,3,4,5,6,7,8,9,10] linspace(0,10i,11) // [0,1i,2i,3i,4i,5i,6i,7i,8i,9i,10i] linspace(1,2,1) // Error. Invalid number of points. linspace(2,3,0) // [], when the point number is zero it returns an empty array. linspace(a,b,0.5) // Error. Look below. linspace(a,b,-1) // Error. Invalid number of points. 补充说明： 支持复数类型 当点数是 0 的时候，返回空数组 输入端点是整数和浮点数（或者复数的需部为 0 ）时，返回值是浮点数组 输入端点至少一个是复数的时候，返回值是复数数组 当点数是 1 或者是负数的时候，抛出错误。  参考： 冒号算符 : logspace logspace 使用端点和点的个数构造对数数列  语法： logspace(A,B,N) // 10.^linspace(A,B,N) logspace(A,B,0) // [] logspace(A,B,1) // Error. Invalid number of points. logspace(A,B,-2) // Error. Invalid number of points. 补充说明： 支持复数类型 当点数 N 等于 0 的时候，返回空数组 当点数 N 等于 1 或者为负数的时候，抛出错误。  参考： logspace logspace 函数的 MATLAB 兼容性问题 。 zeros  构造零数组  语法： zeros(s1,s2,...,TYPE="double") // Return an array with size [s1,s2,...] and its every elements are zeros. The default type is array_double. zeros([s1,s2,...],TYPE="double") // Like above. 补充说明： 最后一个参数 TYPE 的取值包括： int 或者 integer 、 double 或者 real 、 complex 、 variant 分别对应构造出的数组元素类型。 默认的构造类型是浮点数。  参考： ones eye ones  构造元素全为1的数组  语法： ones(s1,s2,...,TYPE="double") // Return an array with size [s1,s2,...] and its every elements are ones. The default type is array_double. ones([s1,s2,...],TYPE="double") // Like above. 补充说明： 最后一个参数 TYPE 的取值包括： int 或者 integer 、 double 或者 real 、 complex 、 variant 分别对应构造出的数组元素类型。 默认的构造类型是浮点数。  参考： zeros eye eye  构造单位矩阵  语法： eye(s1,s2=s1,TYPE="double") // Return an array with size [s1,s2] and the dianonal elements are ones. The default type is array_double. eye([s1,s2],TYPE="double") // Like above.  补充说明： 最后一个参数 TYPE 的取值包括： int 或者 integer 、 double 或者 real 、 complex 、 variant 分别对应构造出的数组元素类型。 默认的构造类型是浮点数。  语法： eye ones diag diag  构造对角矩阵  语法： diag(V,K=0) // If V is a vector and K is an integer, it returns a K-th diagonal(K=0)/super-diagonal(K&gt;0)/sub-diagonal(K&lt;0) matrix with diangonal elements V. diag(V,[M,N]) // Like below. diag(V,M,N) // If V is a vector and both M and N are positive integers, it returns a [M,N]-sized matrix with pseudo-diagonal. diag(M,K=0) // If M is a matrix (2d-array), it returns its K-th diagonal(K=0)/super-diagonal(K&gt;0)/sub-diagonal(K&lt;0) elements as a column-vector.  例子： /* examples: interactive mode */ println("ex1:", diag([1,2,3])); println("ex2:", diag([1,2,3],1)); println("ex3:", diag([1,2,3],-1)); a = [1,2,3; 3,4,5; 5,6,7]; println(diag(a)); println(diag(a,-1)); /* output below: */ ex1: 1 0 0 0 2 0 0 0 3 ex2: 0 1 0 0 0 0 2 0 0 0 0 3 0 0 0 0 ex3: 0 0 0 0 1 0 0 0 0 2 0 0 0 0 3 0 ex4: 1 4 7 ex5: 3 6  参考： eye 向量化 形式的操作 transpose  转置 ctranspose  共轭转置 flip , fliplr , flipud  数组的翻转 rot90  数组的旋转 cat  数组的拼接  语法： cat(DIM, A, B) // 在第DIM维度上进行矩阵拼接 find 搜索非零元素  语法： find((1:10)&gt;5) // Find all elements of 1:10 that is greater than 5, and it returns the indices of those elements. 搜索数组中的非零元素，返回它们的索引组成的数组。 当输入数组是向量的时候，返回的索引数组保持向量所在的数组维度。 如果没有找到任何非零元素，返回一个空数组。 sort 排序  语法： sort(X) // Take the first non-singleton dimension as DIM parameter, behave the same as sort(X,DIM) sort(X,DIM) // Take the DIM dimension as the sorting dimension. If DIM==-1 then behave the same as sort(X). sort(X,DIM,MODE) // MODE: "ascending" or "descending" sort(X) 方式默认使用第一个非单元素维度（non-singleton dimension）作为排序维度进行排序，默认升序。 sort(X,DIM) 指定 DIM 为排序维度，如果 DIM==-1 则采用 sort(X) 一致的行为，默认升序。 sort(X,DIM,MODE) 基本同上， MODE 参数用来选择序关系， "ascending" 表示升序， "descending" 表示降序。 ',title : '数组函数',flags : 0,children : []},{file:'./data/help_script_Specifications_String.htm',name : 'help_script_Specifications_String',body : '字符串函数 目录 字符串属性 子串与索引 格式化字符串 其他字符串函数 字符串的属性 length  获得字符串中字符的个数，窄字符和宽字符都计算为1个字符。  语法： a = "abc"; length(a) // output: 3 string.is_alphabet  判断字符串是否仅由26个英文字母（包含大小写）构成  语法： a = "abcdEFGH"; string.is_alphabet(a) // output: true b = "def 123" string.is_alphabet(b) // output: false string.is_digit  判断字符串是否仅由0-9这10个数字构成  语法： a = "000325445"; string.is_digit(a) // output: true string.is_alphanum  判断字符串是否仅包含数字和字母 !error-reference: help_script_Specifications_String.function.is_alphanum a = "abc123"; is_alphanum(a) // output: true 子串与索引 substr , string.substr 返回字符串的子串  语法： a = "abcdefghijk"; a.substr(0,5) // output: "abcde" a.substr(-3,2) // output: "ij" a.substr(6) // output: "ghijk"  参考： 字符串的索引 []  字符串的索引，用来返回字符串中的子列或者字符  说明： 字符串可以部分的理解为字符的数组，因此允许字符串使用 [] 索引算符来获取字符串的字符元素或者子列。 字符串和数组一样，从0开始索引。 本质上 [] 接收一个整数或者一个整数数组，返回该整数对应的字符或者整数数组对应的字符按照次序组成的子列（新字符串）。 允许使用 end 关键词表示字符串的最后一个位置  语法： a = "abcdefghijk"; a[3] // output: "d" a[0:5] // output: "abcdef" (6 characters) a[end:1] // output: "kjihgfedcba" (reversing the word) 格式化字符串 format , string.format  格式化字符串  说明： 支持 %d （整数）、 %f （浮点数）、 %e （科学计数法）、 %g （数值自动格式）、 %s （字符串）等C风格的格式化字符串。 整数16进制使用 %x 标志。 支持 %{1} 、 %{2} 等对格式化字符串参数变量的引用， %{1} 表示第1个参数， %{2} 表示第2个参数。 支持符号显示控制、小数位置控制和补零控制等。  语法： format(fmt_str, ...)  例子： /* example 1 */ println(format("x=%d n",123)); println(format("y=%g n",23.3)); println(format("z=%x n",1656)); println(format("w=%s n","hello"); println(format("x+y*x=%{1}+%{2}*%{1}",1,2)); /* output below: */ x=123 y=23.3 z=2fd030 w=hello x+y*x=1+2*1 其他字符串函数 lines , string.lines  将字符串按行分解  语法： str.lines() // call as a member function, str is a string object. lines(str) // call as a common function, str is a string object.  参考： words split words , string.words  将字符串按单词分解  语法： str.words() // call as a member function, str is a string object. words(str) // call as a common function, str is a string object.  参考： lines split split , string.split  按照指定的分隔符参数分解字符串  语法： str.split(sep) // call as a member function, sep is string of separators. split(str,sep) // call as a common function, sep is string of separators.  参考： words lines concat , string.concat  连接字符串  语法： str.concat(s1,...) // call as a member function, concatenation of str, s1 and ... concat(str,s1,...) // call as a common function, concatenation of str, s1 and ... find , string.find  寻找子串 replicate , string.replicate  替换子串 join , string.join  粘合字符串  语法： string.join(sep, str_lst) // str_lst is an array of string (array_variant type) string.escape  将字符串中的特殊字符转换为unicode显式编码  语法： string.escape(str)  参考： unescape string.unescape 将字符串中部分采用unicode显式编码的内容转换为原始的字符  语法： string.unescape(str)  参考： escape upper , string.upper  将字符串转换为大写  语法： str.upper() // call as a member function. upper(str) // call as a common function.  参考： lower lower , string.lower  将字符串转换为小写  语法： str.lower() // call as a member function. lower(str) // call as a common function.  参考： upper reverse , string.reverse 翻转字符串  语法： str.reverse() // call as a member function. reverse(str) // call as a common function.  参考： [] string.toIntArray  将字符串转换为unicode编码的整数序列  语法： str.toIntArray() // call as a member function. string.toIntArray(str) // call as a common function.  参考： fromIntArray string.fromIntArray 将整数序列按照unicode编码规则转换到字符串  语法： string.fromIntArray(arr) // return a string from unicode integer array.  参考： toIntArray ',title : '字符串函数',flags : 0,children : []},{file:'./data/help_script_Specifications_VariantTable.htm',name : 'help_script_Specifications_VariantTable',body : '变量表函数 table.keys  返回变量表的键值  语法： table.keys(t) table.values  返回变量表的元素（允许重复）  语法： table.values(t) table.union  两个变量表按照键值求并，元素以第一个变量表为准  语法： table.union(t1,t2) table.difference  两个变量表按照键值求差，元素以第一个变量表为准  语法： table.difference(t1,t2) table.intersect  两个变量表求交，元素以第一个变量表为准  语法： table.intersect(t1,t2) table.remove_nil  返回一个变量表，该变量表的内容是输入参数的变量表移除 nil 元素和对应的键值的结果  语法： table.remove_nil(t) ',title : '变量表函数',flags : 0,children : []},{file:'./data/help_script_Specifications_IO.htm',name : 'help_script_Specifications_IO',body : 'IO函数 IO函数为用户提供了操作控制台输入输出、文件读写和数据文件的读写等接口。  标准输入与输出 io.stdin 标准输入流 io.stdout 标准输出流 io.stderr 标准错误流 文件的读写 io.open 打开一个文件或支持流的设备，返回一个IO流   语法： stream = io.open(filename, MODE) // MODE = io.ReadMode | io.WriteMode | io.ReadWriteMode | io.AppendMode IO模式 table 1: IO模式 模式符号  说明  io.ReadMode  只读模式  io.WriteMode  只写模式  io.ReadWriteMode  读写模式  io.AppendMode  追加模式  io.close 关闭一个流  io.read 从一个流中读取数据，具体参数决定返回值的类型 io.readln 从一个流中读取一行或多行，返回这一行的字符串，如果是多行，返回由每一行字符串组成的数组（可以选择去掉或保留换行符） io.write 向一个流中写入数据，参数决定写入的方式 io.writeln 向一个流中写入一行或者多行的内容，自动在每一行内容结束后加入一个换行符 io.is_eof 判断一个流是否处于结束位置  io.seek 设定流的位置 定位方式 table 2: 定位模式 模式符号  说明  io.AbsoluteSeek  绝对定位（从开头计算）  io.RelativeSeek  相对定位（从当前位置计算）  io.SeekFromEnd  从流的尾部定位  数据文件的读写 io.load 载入数据文件  语法： data = io.load(filename, OPTIONS, arg1, ... ) var = io.load(filename, PARSER, arg1, ... ) 说明： 第一个参数是文件名 第二个参数是选项或者内容解析器，该参数可以是用户定义的一个解析器函数 解析器函数将一个文件流或者字符串转换为一个数据变量，即可以 my_parser(stream, arg1, ...) ，也可以 my_parser(string_content, arg1, ...) 可以利用 正则表达式 匹配方式来获得一个数据结构 第三个参数为附加参数 当第二个参数是选项时，附加参数有不同的含义 当第二个参数是解析器时，这些附加参数作为解析器的传入参数 参看 读写模式选项和解析器 io.save 写入数据文件  数据读写模式常量和解析器 table 3: 读写模式选项和解析器 模式符号  说明  "-auto"  自动判断，默认值  "-mat"  载入一个数组，自动识别是文本或二进制  "-text"  载入的数据作为一个字符串，自动判断编码格式，建议UTF8或本地编码格式  "-text:codepage"  载入的数据作为一个字符串，根据用户选择 codepage 确定编码格式  "-var"  载入一个EWSL的变量数据，二进制格式  "-fig", "-figure" 载入一个EWSL的数据图，二进制格式  "-json"  载入一个JSON数据表，返回一个变量表  "-xml"  载入一个XML数据表，返回一个变量表  "-csv"  载入一个CSV数据表，返回一个二维数组  "-image"  载入位图数据（png/bmp/jpg/gif等），返回一个整数二维数组  "-png"  指定png格式数据，返回同上  "-bmp"  指定bmp格式数据，返回同上  "-jpg", "-jpeg"  指定jpeg格式数据，返回同上  解析器  io.json_parser Json解析器  io.xml_parser  XML解析器  io.array_parser 文本数组解析器  io.csv_parser  CSV数据解析器  交互处理 io.interact_line 输入一个行处理器（line_handler），产生一个和输入流的交互行为   语法： io.interactive_line(line_handler = print, stream = stdin, cr = " r n") 说明： line_handler 默认是打印函数，即输入一行后自动打印该行内容 读入每一行时保留行末的换行符，交给 line_handler ，即允许在 line_handler 中分析具体的行末符 stream 默认为标准输入流 cr 为指定换行符，默认是 " r n" ',title : 'IO函数',flags : 0,children : []},{file:'./data/help_script_Specifications_System.htm',name : 'help_script_Specifications_System',body : '系统函数 ',title : '系统函数',flags : 0,children : []},{file:'./data/help_script_Specifications_Plot.htm',name : 'help_script_Specifications_Plot',body : '绘图函数 EWSL提供了数据可视化功能，基本的绘图功能放在 fig 模块中。 目录 基本绘图 绘图的创建与管理 fig.new_figure fig.get_figure fig.set_figure 曲线图 极坐标图 球坐标图 二维图像 表面图 等值线 高级 多重画布 序列图（动态图） 绘制子图 属性 坐标系 坐标轴 图例 颜色表 线条类型 基本绘图 fig.new_figure 创建新的绘图，并作为当前绘图对象  语法： fig.new_figure() fig.get_figure 取得绘图对象  语法： fig.get_figure() fig.set_figure 设置当前绘图对象  语法： fig.set_figure(f) fig.plot 绘制曲线图  语法： fig.plot(x,y) fig.plot(x,y,PROPERTY_TABLE)  参考： 参考 !error-reference: help_script_Specifications_Plot.property 。 fig.polar fig.polar_deg 绘制二维极坐标曲线图  语法： fig.polar(theta,rho) fig.polar(theta,rho,PROPERTY_TABLE) fig.polar_deg(theta,rho) fig.polar_deg(theta,rho,PROPERTY_TABLE) 参考 !error-reference: help_script_Specifications_Plot.property 。 fig.polar3 fig.spherical fig.polar3_deg fig.spherical_deg 绘制三维球坐标图  语法： fig.polar3(theta,phi,rho) fig.polar3(theta,phi,rho,PROPERTY_TABLE) fig.polar3_deg(theta,phi,rho) fig.polar3_deg(theta,phi,rho,PROPERTY_TABLE) fig.spherical(theta,phi,rho) fig.spherical(theta,phi,rho,PROPERTY_TABLE) fig.spherical_deg(theta,phi,rho) fig.spherical_deg(theta,phi,rho,PROPERTY_TABLE) 参考 !error-reference: help_script_Specifications_Plot.property 。 fig.imagesc 绘制二维图像  语法：  fig.surface 绘制曲面  语法： fig.surface(X,Y,Z) fig.surface(X,Y,Z,COLOR) fig.surface(X,Y,Z,VALUE,RENDER_OPTION) fig.surface(MODEL) X 、 Y 、 Z 均为数组 X 和 Y 是向量（至多只有一个维度的大小大于1）时按照 X 和 Y 构造的网格绘图， Z 的大小为 X.length() * Y.length() X 和 Y 是二维数组时，其大小要求和 Z 匹配，则构造四边形网格进行绘图 fig.surface(MODEL) 使用定义的模型进行渲染 fig.surface(X,Y,Z,COLOR) ， COLOR 是一个颜色（3维向量，或者颜色字符串） fig.surface(X,Y,Z,VALUE,RENDER_OPTION) ， VALUE 表示在表面上的取值， RENDER_OPTION 是选项字符串，可以是"-vertex"、"-edge-x"、"-edge-y"或"-facet"中的一种情况，它们分别对应在顶点上渲染、在X网格的棱边上渲染、在Y网格的棱边上渲染、在面上渲染。 fig.surface(MODEL) ， MODEL 是表面建模工具生成的模型对象。 fig.contour 等值线  语法： fig.contour(X,Y,Z,n) fig.contour(X,Y,Z,V) fig.contour(X,Y,Z,n,CMAP) fig.contour(X,Y,Z,v,CMAP) X 、 Y 、 Z 均为数组 X 和 Y 是向量（至多只有一个维度的大小大于1）时按照 X 和 Y 构造的网格绘图， Z 的大小为 X.length() * Y.length() X 和 Y 是二维数组时，其大小要求和 Z 匹配，则构造四边形网格进行绘图 fig.contour(X,Y,Z,n) 表示在 Z 的取值范围上分割为 n 个点作为等值线的参考值 fig.contour(X,Y,Z,v) 表示非均匀等值线的参考值 CMAP 表示颜色表，参考 !error-reference: ?.colormap 高级 fig.canvas(name) 设定当前画布的名称，并且结束当前画布的绘制 fig.series_beg fig.series_add fig.series_end 序列图  语法： fig.series_beg(name,time_delta) // time_delta: default value = 0.1 (sec) fig.series_add() ... /* plot procedure */ fig.series_end() fig.subplot 绘制子图 fig.subplot(ROW,COL) // Create a new layout fig.subplot(ROW,COL,ind) // Select/Create current subplot fig.subplot(ROW,COL,RANGE) // Select/Create current subplot which covers a continuous range of indices fig.subplot("position", POSITION) // Create a subplot which position is indicated by `POSITION` fig.subplot(ROW,COL) 创建布局，网格的大小为 ROW 行、 COL 列。 fig.subplot(ROW,COL,ind) 选择当前布局下的一个一个网格位置（按从左到右，再从上到下的顺序索引）创建或者选择绘图。 fig.subplot(ROW,COL,RANGE) 选择布局下的指定网格坐标的一段范围， RANGE 为一个向量，包含两个值，表示左上角的网格索引和右下角的网格索引。 fig.subplot("position", POSITION) 直接指定绘图所在的位置，坐标范围为一个向量，包括四个值 [x,y,width,height] ， x 和 y 表示所处整个画布内的相对坐标（0-1之间），而 width 和 height 表示长度和高度。 ',title : '绘图',flags : 0,children : []},{file:'./data/help_script_Specifications_Module.htm',name : 'help_script_Specifications_Module',body : '1. 日志库 2. 正则表达式 ',title : '其他模块',flags : 0,children : [{file:'./data/help_script_Specifications_Module_Logger.htm',name : 'help_script_Specifications_Module_Logger',body : '日志模块函数 语法： ```block:example **例子：**  日志的打印和输出 logger.log_message 输出普通消息  语法： logger.log_message(msg) logger.log_warning 输出警告  语法： logger.log_warning(msg) logger.log_error 输出错误消息  语法： logger.log_error(msg) logger.log_fatal 输出致命错误消息  语法： logger.log_fatal(msg) logger.print 打印无标签普通消息  语法： logger.print(msg) logger.println 换行打印无标签普通消息  语法： logger.println(msg) 日志系统的状态 logger.cache 获得或者设置日志目标的缓存状态  语法： logger.cache() logger.cache(flag) logger.flush 强制刷新缓存（强制输出）  语法： logger.flush() logger.target 获得或者设置新的日志目标状态  语法： logger.target() logger.target(type) // type: "null" (Null Object), "console" (Console), "file" (To a file) logger.target("file", fn) // fn is the target filename. ',title : '日志库',flags : 0,children : []},{file:'./data/help_script_Specifications_Module_Regex.htm',name : 'help_script_Specifications_Module_Regex',body : '正则表达式库函数 正则表达式介绍请阅读 正则表达式库 。  库函数 regex.compile 将正则表达式编译成一个正则表达式对象  语法： regex.compile(re_str) // Compile a regular expression object. regex.compile(re_str, flag) // Compile a regular expression object with user"s flag. regex.create 创建一个正则表达式对象，允许用户加载预定义子串。  语法： regex.create() // Create a regular expression object. regex.create(re_str) // Create a regular expression object defined by a string. regex.match 使用正则表达式进行字符串匹配  语法： regex.match(re_str, str) // Return a match-object if it matches, or it returns nil value. regex.match(re_str, str, flag) // Like above and it does with user"s flag. regex.search 使用正则表达式进行匹配搜索  语法： regex.search(re_str, str) // Return a match-object if it matches, or it returns nil value. regex.search(re_str, str, flag) // Like above and it does with user"s flag. regex.replace 使用正则表达式进行替换  语法： regex.replace(re_str1, re_str2, str) // Replace pattern re_str1 by re_str2 in str. regex.replace(re_str1, re_str2, str, count, flag) // Replace pattern re_str1 by re_str2 in str with options flag and count restriction (default 0 means no-restriction). 正则表达式对象成员 使用 regex.create 函数和 regex.compile 函数创建的正则表达式对象 regex_object 可以使用一系列成员函数。正则表达式匹配行为在 regex_object.compile 函数运行时确定，匹配、搜索和替换过程不再接受传入的标志参数。  regex_object.prepare 加载具名预定义子串模式  语法： regex_object.prepare(re_name, re_str) regex_object.compile 自编译   语法： regex_object.compile() regex_object.compile(flag) regex_object.match 匹配字符串   语法： regex_object.match(str) // If it matches, it returns a match-object. If it does not match, it returns a nil value. regex_object.search 搜索  语法： regex_object.search(str) // If it matches at a position, it returns a match-object. If it does not match, it returns a nil value. regex_object.replace 替换   语法： result, real_count = regex_object.replace(str, pattern) // Search the target string "str" from the leftmost and if it matches the regular expression it will be replaced by the pattern "pattern" result, real_count = regex_object.replace(str, pattern, count) // Search the target string "str" from the leftmost and if it matches the regular expression it will be replaced by the pattern "pattern" with count restriction (0 means no restriction as default) result, real_count = regex_object.replace(str, callback, count=0) // Search the target string "str" from the leftmost and if it matches the regular expression call `callback(match_object)` and take the result as replacement. Count restriction is also be taked if count &gt; 0. 匹配对象成员 匹配、搜索函数返回一个匹配对象（ Match Object ），使用匹配对象可以进行子串匹配、迭代匹配等操作。  match_object.next 定位到下一个匹配位置   语法： match_object.next() // Go next position. If it goes next successly it returns true. If it goes the end it returns false.  match_object.sub 获得子串匹配的结果（返回匹配结果字符串的数组）   语法： match_object.sub() // Return all top-level indexed matched substrings. match_object.sub(n1,...) // Return custom-selected-level indexed matched substrings. (n1,...) indicates the indexed substring"s (indexed bracket"s) depth and position. match_object.group 获得所有匹配子串的信息（包括所有层次的被索引的匹配结果），以及根据该结果返回按照给定次序重组的结果  语法： match_object.group() // Return all matched sub-strings. match_object.group(i1,i2,...) // Regroup by [i1,i2,...] from the matched sub-strings. match_object.replace  语法： match_object.replace(pattern) // Replace the matched result by pattern and return the substituted result. ',title : '正则表达式',flags : 0,children : []}]},{file:'./data/help_script_Specifications_Comparisons.htm',name : 'help_script_Specifications_Comparisons',body : '和其他语言的比较 ',title : '和其他语言的比较',flags : 0,children : []}]},{file:'./data/help_script_Modules.htm',name : 'help_script_Modules',body : '1. 日志库 2. 正则表达式 ',title : '模块',flags : 0,children : [{file:'./data/help_script_Modules_Logger.htm',name : 'help_script_Modules_Logger',body : '日志库 脚本语言对日志功能的支持。使用 logger 可以查询日志库的函数，可以阅读 日志库函数表 。  运行时环境中的日志 在一个独立的脚本运行时环境中，都内置了一个小型日志系统。用户可以设定当前运行时环境的日志输出目标和设定输出信息级别标识。 打印和输出日志 使用 logger.log_message 输出普通级别的日志消息 使用 logger.log_warning 输出警告级别的日志消息 使用 logger.log_error 输出错误级别的日志消息 使用 logger.log_fatal 输出致命错误级别的日志消息 使用 logger.print 和 logger.println 打印无标识的日志消息 设定日志输出目标 使用 logger.target 函数设定输出目标 logger.target() // Just return the current target. logger.target("null") // Return the current target and set the logger target to a null object. (Just discard all messages.) logger.target("console") // Return the current target and set the logger target to the current console output. (io.stdout for common and warning messages and io.stderr for error message.) logger.target("file", fn, AppendModeFlag = true) // Return the current target and set the logger target to an user file named fn. If AppendModeFlag==true the file target will use AppendMode (default: true). 日志的缓存 脚本程序中输出的消息不一定是立即打印出来，有可能预先被缓存起来然后再输出。可以通过设置参数或者强制刷新来控制缓存行为。 使用 logger.cache 获取和设定缓存模式 使用 logger.flush 将缓存的消息立即输出 ',title : '日志库',flags : 0,children : []},{file:'./data/help_script_Modules_Regex.htm',name : 'help_script_Modules_Regex',body : '正则表达式 EastWave V7脚本语言提供了正则表达式（Regular Expression）工具库。 正则表达式基本概念 正则表达式使用一个字符串来描述一个句法规则，基于该句法规则匹配目标文本中的内容字符串。使用正则表达式可以较为方便的从目标文本中匹配或者抓取到需要的内容。  正则表达式提供了一系列具有逻辑结构含义的“元字符”(meta-characters)，使用元字符和普通字符共同构成一个匹配规则。  正则表达式的符号包括： table 1: 正则表达式元字符表 元字符  说明    转义字符  ^  匹配输入字符串的开始位置  $  匹配输入字符串的结束位置  *  匹配前面的子表达式任意次数  +  匹配前面子表达式一次或多次  ?  匹配前面表达式零次或一次  ? 前是元字符时，表示 非贪婪模式 ，即尽可能少的匹配，例如 "o+?" 匹配 "oooo" 时，会优先匹配单个 "o" 。  {n}  n 是一个正整数，精确匹配 n 次  {n,m}  n 和 m 都是正整数，且 n&lt;=m ，匹配次数大等于 n 小于等于 m  .  匹配除了换行符（ r n ）之外的任意字符  [xyz]  匹配字符集合( xyz )中的任意一个字符  [^xyz]  负匹配 字符集合( xyz )中的任意一个字符  [a-z]  匹配字符范围 a 到 z 之间的任意字符  [^a-z]  负匹配 字符范围 a 到 z 之间的任意字符  (pattern)  (...) 符号中间是一个子串模式。该子串模式将在 匹配对象(Match Object ) 中中被索引。  (?:pattern)  (?:...) 在 () 中以 ?: 开头。该子串模式不会在 匹配对象(Match Object ) 中被索引。  b  匹配单词的边界  B  负 匹配单词的边界  cx  控制符匹配， x 指明具体的控制符。例如： cM 表示一个回车符（ Ctrl-M ）， x 要求是26个英文字母（大小写均可）。  d  匹配一个数字字符，等同于 [0-9] 。  D  负匹配一个数字字符，等同于 [^0-9] 。  f  匹配换页符。  n  匹配换行符。  r  匹配回车符。  t  匹配制表符。  v  匹配垂直制表符。  s  匹配任何不可见字符，等价于 [ f n r t v] （注意空格）。  S  负匹配任何不可见字符，等价于 [^ f n r t v] （注意空格）。  w  匹配任何单词，单词可用字符在Unicode范围内理解。  W  负匹配任何单词，单词可用字符在Unicode范围内理解。  xn  匹配 n ，其中 n 为十六进制转义值。例如： x41 匹配 "A" 。  un  匹配 n ，其中 n 为Unicode字符的编码，例如： u00A9 表示: ©  k  反向引用 前面某个被索引的子串模式的匹配结果  `pre`   引用预定义名为 pre 的匹配子串（ 具名子串 ）  ${k.m}  引用同一级别的第 k 个子串（从 1 开始索引）， .m 表示第 m 次匹配。参考 子串引用 ，一般用于替换  说明： 负匹配：表示对后面的匹配规则取逻辑非，即将原匹配规则匹配的字符串认为是不匹配，而原匹配规则不匹配的认为是匹配。 边界匹配：表示这个匹配位置恰好是一个单词的边界（首部或者尾部，而非中间），例如 "ion b" 可以匹配 "lion" 但是不可以匹配 "ionization" 。 k 不支持八进制转义字符，使用十六进制转义字符替代。 贪婪匹配和非贪婪匹配策略 正则表达式默认使用贪婪匹配策略，即使用 + 、 * 以及一个 ? 时，尽可能匹配多的字符（并且消耗掉），也可以理解为左侧匹配（消耗）字符后直到不匹配的位置交给右侧的规则。 在匹配多字符匹配的元字符后加上一个问号 ? 实际上会使得问号左侧的匹配规则能够满足最基本的匹配要求的前提下优先考虑问号右侧的匹配规则。 使用 k （k是正整数编号）反向引用子串匹配结果 用来指定当前的位置采用和指定位置子串的匹配结果一致的内容 并不是模式重复，而是模式匹配的结果重复 正则表达式库的用法 EWSL的regex库提供了几个标准函数（ 库函数具体用法 ）：  table 2: EWSL-Regex库函数 函数名  用法  说明  regex.create  regex.create() , regex.create(re_str,flag=0)  创建一个正则表达式，允许后续使用 prepare 预定义具名子串模式  regex.compile  regex.compile(re_str,flag=0)  直接编译一个正则表达式  regex.match  regex.match(re_str,str,flag=0)  直接使用一个正则表达式进行匹配，返回 匹配对象  regex.search  regex.search(re_str,str,flag=0)  直接使用一个正则表达式进行搜索，返回 匹配对象  regex.replace  regex.replace(re_str1,re_str2,str,count=0,flag=0)  直接使用正则表达式进行搜索替换  正则表达式对象接口： table 3: EWSL-Regex 对象接口 reobj 表示一个由regex.compile产生的正则表达式对象  函数名  用法  说明  reobj.prepare  reobj.prepare(name, patter)  预处理：增加预定义子串匹配模式  reobj.compile  reobj.compile(flag=0)  自编译  reobj.match  reobj.match(target_str)  返回整体匹配结果的匹配对象  reobj.search  reobj.search(target_str)  返回用于递进搜索的匹配对象  reobj.replace  reobj.replace(target_str, pattern, count=0)  替换  reobj.match 和 reobj.search 函数返回的是 匹配对象 。 对于较为复杂的正则表达式，可以利用 reobj.prepare 将一些复杂的子串匹配模式用名字定义起来，然后再行引用。EWSL的具名子串支持递归引用。典型的预定义字符串例如： table 4: EWSL-Regex 预定义子串的例子 名称  正则表达式（未转义）  说明  id  ( w([ w d_]*))  变量名：采用英文字母（或Unicode符号）开头的，后续允许英文字母（或Unicode符号）、数字和下划线组成的连续子串  int  ([ + -]0|[1-9][0-9]*)  整数：符号开头，接一个 1-9 的数字，后面跟着不定数量的 0-9 数字  匹配对象 匹配对象是一种引用匹配结果的方式，使用面向对象封装。对于使用 match 函数返回的匹配对象，使用子串引用方式来处理结果。见 例子1 。  table 5: Match Object接口 mobj 是一个匹配对象  函数名  说明  mobj.sub()  索引匹配的子串， mobj.sub(k,m)  mobj.next()  移动到下一个匹配位置，配合 search 和 replace 使用。  mobj.start  起始位置  mobj.end  终止位置  mobj.result  匹配的结果  mobj.regex  原始的正则表达式字符串  mobj.sub 函数返回子串匹配的情况。 mobj.sub() 返回最外层的所有子串组成的数组。 mobj.sub(n) 返回最外层第 n 个括号中的所有匹配子串组成的数组。 mobj.sub(n,m) 返回最外层 n 个括号中第 m 个括号中的所有匹配子串组成的数组。 mobj.sub(n,m,p) 返回最外层第 n 个括号中第 m 个括号中第 p 个括号中所有匹配子串组成的数组。 上述规则可以依次类推。 最后一层括号由于内部没有更多子串，返回的是空数组，而不会报错。 最后一层括号中增加括号深度时，会报错。 (...)* 这种情况时可能匹配结果为空数组。 (...)* (...)+ (...)? 的情况返回的匹配数量是不确定的，并且结果会堆叠在同一层级上，如果要将这种重复模式分级，额外再套一层括号如（ ((...)*) ）。 (...) 1 这种用法将返回一个匹配，如果要将反向引用 1 加入到引用列表中，额外加上括号（ (...)( 1) ）。 mobj.next 将 mobj 移动到下一个匹配点，这时候 mobj.start 和 mobj.end 这两个数值会随之更新到下一个匹配位置，如果原始字符串是 str ，那么 str[mobj.start:mobj.end] 可以得到匹配的子串内容。 例子 简单分词 将如右侧类似的句子 "This is John"s family." 分词。（要求去除空格和单引号的子串引用） str = "This is John"s family."; re = regex.compile("(( w+)(?:[ s.,"]*))+"); obj = re.match(str); obj.sub() // =&gt; array(1x5):["This ", "is ", "John"", "s ", "family."] obj.sub(0) // =&gt; array(1): ["This"] obj.sub(1) // =&gt; array(1): ["is"] obj.sub(2) // =&gt; array(1): ["John"] obj.sub(3) // =&gt; array(1): ["s"] obj.sub(4) // =&gt; array(1): ["family"] 电话号码分析 电话号码为三位或者四位数字开头（区号）加一个连接符 - ，然后再跟着8位数字 电话号码之间有不确定的空白字符连接 str = "010-12342222 021-34432223 025-34334223 0519-22234444"; re = regex.create("([0-9]{3,4}-[0-9]{8} s*)+"); obj = re.match(str); obj.sub() // =&gt; array(1x4): [ "010-12342222 ", "021-34432223 ", "025-34334223 ", "0519-22234444" ] 参考 正则表达式函数表 ',title : '正则表达式',flags : 0,children : []}]},{file:'./data/help_script_Appendix.htm',name : 'help_script_Appendix',body : 'empty page ',title : '附录',flags : 0,children : []},{file:'./data/help_script_Indices.htm',name : 'help_script_Indices',body : 'empty page ',title : '索引',flags : 0,children : []}]},{file:'./data/help_advanced.htm',name : 'help_advanced',body : '1. 插件 2. 脚本开发 ',title : '高阶教程',flags : 0,children : [{file:'./data/help_advanced_plugins.htm',name : 'help_advanced_plugins',body : 'empty page ',title : '插件',flags : 0,children : []},{file:'./data/help_advanced_scripting.htm',name : 'help_advanced_scripting',body : 'empty page ',title : '脚本开发',flags : 0,children : []}]},{file:'./data/help_faq.htm',name : 'help_faq',body : '1. 重大故障 2. 界面相关 3. 前处理相关 4. 后处理相关 5. 跨平台相关 6. 知识相关 7. 完整实例 FAQ ',title : '常见问题',flags : 0,children : [{file:'./data/help_faq_magnitude.htm',name : 'help_faq_magnitude',body : '重大故障 FAQ Q: 为什么我的软件打不开？  A: 如果您是我们的正式客户，请确认硬件狗或者License验证无误，硬件狗是否到期。如果您是我们的试用客户，请确认注册码仍然在试用期内。   Q: 为什么计算的时候系统很卡？  A: 很可能您的电脑物理内存耗尽了。Windows操作系统会将一部分磁盘空间作为内存使用（交换空间），当物理内存不够时，操作系统会将程序的内存分配到磁盘的交换空间。 解决的方案包括： 在计算前，关闭不必要的程序； 减少计算规模（网格数量）； 检查监视器，特别是频域记录器的频点是否过多（全局参数中：最小、最大频率和频率间隔所决定的频点数量是频域记录器频率默认值）； 增加内存； 使用计算服务器。   Q: 为什么有时候我的自定义脚本运行不正常？  A: 可能性很多，如是否有语法错误、使用了并不存在的变量等等。有一种情况较为特殊，即操作系统行尾符问题。 有时候在多个编辑器之间保存/打开文件时容易引发，建议用 notepad++ 或类似软件将行尾符号全部转换为 Dos/Windows 格式。   Q: 计算一次生成的结果文件很大，可能比计算机内存还大怎么办？ A: 解决的方案包括： 改善您的硬件，增大内存，并且更换固态硬盘（将系统交换文件放在固态硬盘上）； 在工程文件中找到“xxx模式” &gt; “其他” &gt; “输出”，将保存文件的方式改成“分开保存”，这样每个记录器将以一份独立的结果文件保存出去。 &nbsp;&nbsp;特别注意 当一个独立的频域记录器记录了太多的频点，软件并不会自动分割，因此建议用户手动将该记录器分拆为若干独立的记录器，分别负责一小段频率的记录。 ',title : '重大故障',flags : 0,children : []},{file:'./data/help_faq_ui.htm',name : 'help_faq_ui',body : '界面相关 FAQ Q: 物体被挡住了，怎么办？  A: 请将包围该物体的材料颜色修改为半透明。   Q: 我想截图，可是如何隐藏坐标轴？  A: 去掉主菜单“查看” &gt; “显示选项” &gt; “参考线”的勾选。   Q: 打开工程以后，模型的（材料）颜色显示异常（如全黑）？  A: 可能是显示驱动程序存在BUG，可以关闭该工程，然后再打开，通常可以恢复。   Q: 为什么点击物体时，物体会突然放大到区域外？  A: 这是Intel集成核芯图形单元的驱动程序问题，如果使用的是Intel Core i5 2xxx/3xxx处理器，可能会发生此类问题，请将显卡驱动更新到2015年2月以后的版本。   Q: EastWave 中打开旧版本工程时为什么不显示模型？  A: 可以检查文档变量表，看看是否存在PI、C0等新版本中新增的系统常量、系统变量。   Q: 我修改了变量，但是模型的尺寸没有发生改变？  A: 可能使用了较为复杂的物体（元件），为了提高显示性能，没有立即刷新显示状态，请打开它，然后选择修改按钮，软件在关闭对话框后会进行刷新。   ',title : '界面相关',flags : 0,children : []},{file:'./data/help_faq_forehead.htm',name : 'help_faq_forehead',body : '前处理相关 FAQ Q: 我在记录器（或激励源）中建立了一个中文名称的记录（或激励源），算出结果后为什么是一串奇怪的字符串？  A: 在脚本/变量系统中，不允许使用英文、数字和下划线（_）之外的字符来命名变量，因此软件会自动将记录器（激励源）的中文名称转换为一串特定字符串。 建议用户在定义记录器（激励源）时用变量定义的要求来定义名称。   Q: 我能否用多个实时场观察器观察一个计算任务？  A: 可以。您可以使用两种方式，一种方式是在一个 EastWave 界面中打开多个实时场观察器，另一种方式是在不同的 EastWave 界面中打开。 两种方法都只需要选择主菜单文件&gt;&gt;新建&gt;&gt;实时场观察器，并按照任务（进度条）窗口中的“主机IP“一栏填写IP地址和端口号， 通常本地计算机的IP地址为127.0.0.1，端口为10034以上的某一个号。需要注意同一台计算机上不同任务的端口号是不同的。   Q: 我的金属薄板为什么对电磁波完全透射？  A: 当金属薄板非常薄的时候，应当用强制网格面，将该平板的网格强制为磁场面，例如XOY面对应的磁场应当是Hz；YOZ面对应的磁场为Hx；XOZ面对应的磁场为Hy。   Q: 为什么我增加了一个时域记录器以后，计算速度降低了很多？  A: 时域记录的记录间隔设得太少会显著降低计算效率。解决方案：适度增加时域记录器的记录间隔。   Q: 为什么我使用布洛赫（Bloch）边界条件时总是报错而不进入计算？  A: 很可能是没有将精度设置中的数值类型修改为复数类型。 请打开“工程管理窗口”下面计算模式节点（显示为当前计算模式的名称，如“自定义模式”） &gt; “其他” &gt; “精度”，弹出对话框后， 将下拉菜单中的“浮点型”或“双精度”修改为“复数浮点型”或者“复数双精度”。   Q: 为什么使用手性材料（或者其他复杂材料）时激励源似乎没有产生信号/能量，实时场看上去恒等于0？  A: 可能是由于采用的复杂材料对网格的要求比普通材料高很多导致当光源波前传播至该种材料网格时导致发散将区域其他地方的场消除所致。  解决方法包括： 将计算精度由“单精度”改成“双精度”； 将网格改细； 将网格设置中的DELTA_T参数（时间步长）改到比默认设置的1/2或更小。   ',title : '前处理相关',flags : 0,children : []},{file:'./data/help_faq_afterproc.htm',name : 'help_faq_afterproc',body : '后处理相关 FAQ Q: 为什么我的后处理结果图不显示数据？  A: 很可能你的数据已经发散。计算发散将导致记录器出现 NAN（Not-A-Number）或者 INF（INFinity）数据，建议检查网格设置。  造成发散的情况包括： 某个局部的网格剖分得不够细； 金属（如PEC）插入了吸收边界； 波端口附近有共形网格等。  Q: 为什么我的后处理结果图很模糊？  A: 你的监视器记录的区域网格不够密，请加密网格（可以使用非均匀网格加密局部空间，具体参考帮助文档有关章节）。   ',title : '后处理相关',flags : 0,children : []},{file:'./data/help_faq_platform.htm',name : 'help_faq_platform',body : '平台相关 FAQ Q: 在Windows中建立的工程导入到Linux平台进行计算时不能正常计算怎么办？  A: 这个问题多数是因为两个操作系统平台的宽字符编码方案不同所致。使用简体中文 Windows 一般采用 GB2312/GBK 编码字符集， Linux上多数使用 Unicode 字符集，如果在后处理中涉及中文字符串（特别是文件名相关的），则很可能出现问题。 因此，我们建议在跨平台计算中避免使用中文字符以及其他宽字符。   ',title : '跨平台相关',flags : 0,children : []},{file:'./data/help_faq_knowledge.htm',name : 'help_faq_knowledge',body : '知识相关 FAQ Q: 您好！我不懂FDTD的原理，请问有什么参考书？  A: 可以参考葛德彪等人著《电磁波时域有限差分方法》一书，如果您能够并且愿意阅读英文资料， 可参考 Taflove 的《Computational Electromagnetics: The Finite-Difference Time-Domain Method》。   ',title : '知识相关',flags : 0,children : []},{file:'./data/help_faq_case.htm',name : 'help_faq_case',body : 'empty page ',title : '完整实例 FAQ',flags : 0,children : []}]},{file:'./data/help_res.htm',name : 'help_res',body : '1. 公司介绍 2. 更新日志 3. 发行说明 4. 系统要求 5. 服务 6. 联系我们 ',title : '资源支持',flags : 0,children : [{file:'./data/help_res_corporation.htm',name : 'help_res_corporation',body : '公司介绍 公司简介 东峻信息科技有限公司是中国第一家自主研制商业化电磁波/光电三维电磁场仿真软件的民营企业，也是集产品研发、市场销售、技术服务为一体的高新企业。 基于多年的独立研发，在电磁波（天线阵/雷达、天线罩、电磁隐身、电磁兼容、微波暗室、电磁环境、移动通讯）和光电（激光、LED、超构材料、光子晶体、光通讯器件） 等仿真技术方面取得突破性进展，相对国际软件在大体系和电磁波/光电材料的仿真形成独特优势，走出了差异化竞争的发展路线，产品主要销往军工科研院所、企业、大学等单位， 并出口部分产品模块到国外。同时，我们为航天、航空、中电、船舶、兵器部等部门研究所提供不同领域的技术服务和个性化的解决方案。 公司已取得6项软件著作权与多项发明专利，获得“软件产品企业”资质与ISO9001质量体系认证认可，具备国家三级保密资质，同时获得省千人计划、国家创新基金（中小企业）、 留学人才创业等项目支持，并在中国科技创业计划大赛企业组获奖。   公司技术实力雄厚，拥有一批资深的高素质研发及技术工程人员，公司创始人蒋寻涯博士曾长期在美国国家实验室、硅谷光电公司和麻省理工学院进行研究工作， 具有十多年的研发及工程经验，公司组建了专业而经验丰富的研发团队、技术服务团队和销售服务团队（硕士以上学位占70%）。 公司总部位于上海，目前在宁波设有分支机构，为客户提供快捷服务。   作为一个本土企业和长期深耕中国电磁波/光电市场的研发型企业，东峻公司积累了大量的研发经验和市场经验，通过和其他硬件设备厂商合作，为用户提供快速、高质量、个性化的服务。 为保证软件和服务质量，东峻在过程中严格遵循ISO9001标准和国家保密规定。公司引入国际上大型企业先进的开发模式和管理理念，大幅度提高软件产品和服务品质。 公司定期组织赞助和参加国内外电磁波/光电会议，也组织科研专家和资深工程师来公司研讨和交流，不断追踪国际前沿问题。 公司秉承“专业、联合、创新、诚信”的经营理念，以“技术领先”、“客户为中心”、“品牌发展”为战略，为“中国制造”向“中国创造”的跨越建好“梯子”， 为中国的电磁波/光电产业的大发展贡献自己的力量，力争在五年内成为国际一流的电磁波/光电仿真软件和服务提供商。 产品专业化 目前公司主打产品是 EastWave（东峻电磁光电软件）软件系统，可广泛用于电磁波系统（如天线阵/雷达、天线罩、RCS/隐身、电磁兼容、微波暗室、电磁环境、移动通讯等） 和光电系统（如激光、LED、光纤、超构材料、光子晶体、光通讯器件等）的设计和仿真，是相关行业工程设计和参数优化、科学研究的必备工具。 EastWave 主要采用FDTD和PO等方法，在材料建模、电大或超大（千倍波长）系统仿真等方面具有明显的优势，使大型天线罩、整机整舰RCS、大型天线阵、大平台电磁兼容、微波暗室、 超构材料、激光、LED、非线性等国际难题成为“可严格仿真的”。同时，基于明显的速度优势和混合寻优算法，EastWave可对大中型体系进行“多参量寻优”计算，快速发现最优解。 针对国内客户需要，EastWave 创新性地设立了天线阵、天线罩、RCS等十一个计算模式，操作实现“傻瓜化”，用户可以快速上手。   在电磁领域东峻科技追求为客户提供全面专业的解决方案，具体提供业界最前沿的解决方案如下： 天线罩、“天线阵+天线罩的一体化”设计与优化。 天线阵（相控阵）的设计与优化。 雷达散射截面（RCS）的计算和优化。 RCS热点成像和隐身效果分析。 大平台的电磁兼容（EMC）设计与优化。 微波暗室优化设计与承建。 吸波材料设计与优化仿真。 电磁覆盖设计与优化。 服务特色化 本公司秉承“专业、联合、创新、诚信”的经营理念，提供优质的售前、售中、售后服务。作为拥有独立知识产权、中国首家自主研发电磁波/光电三维仿真软件的本土公司， 东峻科技可以方便快捷的解决工程师、老师和学生软件在安装和使用过程中复杂的技术问题。   由于研发团队就在国内，可以及时提供解决方案和技术咨询服务： 自主可控： 无技术封锁，合作研究，全力支持中国军工企业发展，并支持二次开发。 快速响应： 多层次、全方位、高效率的解决方案和技术咨询服务，沟通零成本。 个性服务： 根据客户需求，提供不同方式合作模式。 免费培训： 免费上门对客户进行技术培训。 ',title : '公司介绍',flags : 0,children : []},{file:'./data/help_res_add.htm',name : 'help_res_add',body : '更新日志 EastWave 7 有哪些变化？ xxxx xxxx xxxx xxxx EastWave 6.0 有哪些变化？ 计算模式 天线阵的多阵列模式 天线罩机扫计算模式 非均匀FDTD网格 新版非均匀网格生成策略 优化物体的边界网格控制 曲面薄板修补功能 后处理增强 频域远场外推智能数据（延迟外推） 时域信号（记录）智能数据 绘图曲线标注功能（最大值、最小值、峰宽） 界面新功能 更加现代的对话框风格 屏幕取点、测量（坐标、长度、角度）功能 新的2D网格预览功能 改进3D网格预览功能，支持查看电场、磁场网格（按Yee元胞方式） 模型切片功能 变量表窗口增加求值结果的预览 物体元件、记录器、激励源、材料 新的管形元件 新增参数扫描体 集总端口新增频域记录 斜面激励源、口径场 斜面记录器 材料支持单位制 EastWave 5.1 with update 1 有哪些变化？ 新增“工作平面”，用于定义局部坐标系，可以在定义部分激励源、记录器时引用，部分计算模式也增加了相关支持 部分计算模式开始支持多扫描面设定 新增“馈线”元件，可一次性建立细导线+集总端口的模型，且可使用斜线 建模中支持交互式取点功能 新增“[时域]截面极值记录器”和“口径场”激励源 后处理结果显示功能的调整和改进 如支持截面场嵌入到3D模型坐标系中统一显示 方向图和模型同时显示时可调节相对位置 优化表面场记录器 优化时域记录器显示动态图时的播放功能 脚本语言强化（参看2016年新版《EastWave 5.1 脚本语言说明文档》） 导入IGS/STP格式时允许设定导入精度 新增PO脚本建模 新增PO自定义前、后处理脚本功能 新增PO直接导入方向图计算反射面天线远场的功能 EastWave 5.1 有哪些新变化？ 新增工程模板功能，可根据经验创建特定领域的工程模板，减少重复性建模工作 新增“天线罩（功率传输系数，频率响应）”计算模式 新增内置函数、用户自定义函数和函数库功能 新增“超薄介质”，可提高多层薄板型天线罩的计算速度 提供“有耗材料”、“有耗材类（损耗角正切）”两种材料设置方式 大幅改进阵列的控制方式，支持用脚本控制阵列的数量和排列方式；支持用脚本调整馈源阵列各单元的幅度和相位；支持按数组输入多边形曲线柱的顶点位置 优化建模交互操作，表格控件支持内容的复制、粘贴，支持窗口快照到剪贴板的功能 优化图数据的预览方式 EastWave 5.0 有哪些新变化？ 全新设计的界面风格，更专业，更人性化，显著提升工程人员的使用体验 大幅度完善CAD建模功能，简化建模步骤 特别新增内置天线罩物体模型，简化天线罩设计的难度 新增馈源阵列功能，强化天线阵相关计算模式，使之更稳定、更高效 增加PO方法计算反射面天线远场的计算模式，支持独创的加速计算功能，可增速10倍以上 在PO方法中引入大面元积分算法，显著改善双站RCS的积分性能 在PO方法中采用改进的消隐算法计算RCS，进一步提升计算性能 丰富帮助手册和案例文档的内容，改善新手快速入门体验 ',title : '更新日志',flags : 0,children : []},{file:'./data/help_res_illustrate.htm',name : 'help_res_illustrate',body : '发行说明 系统平台 Microsoft Windows 2000/XP/Vista/Windows 7 32-bit or 64-bit和Linux系统。 Intel/AMD CPU主频不低于1GHz。 内存不低于256MB，磁盘空间不低于1GB。 并行技术：支持多操作环境下的多种并行技术（MPI和Windows多线程等）； 同时可根据用户需求实现不同的并行方式，如单机多核并行、多机多核并行等。 计算模式 EastWave 提供两种电磁波仿真算法：时域有限差分法（FDTD）和物理光学法（PO）。 FDTD算法：全波算法，是 EastWave 主要采用的算法，主要适用于整个电磁波、光波波段的电磁及电磁兼容仿真计算，特别适用于各种电大尺寸目标的精确求解。对于2D平面的仿真模拟，两个偏振模式可以同时进行，一次计算即可得到两个偏振模式的结果。 PO算法：高频算法，主要用于结构、材料较为简单的超电大尺寸物体的快速求解。 EastWave 还可进行FDTD+PO混合仿真计算，可仿真超电大体系的电磁参数，如大型反射面天线、航空母舰的RCS等。 EastWave 目前共有14种计算模式（含自定义），请参看 计算模式 。 核心功能 EastWave 支持CAD建模功能，包括3D模型创建、编辑导入和坐标变换等。EastWave支持STL、IGS、STP等模型格式导入。请参看 几何元件 。 EastWave 支持多种色散、非色散、各向异性、非线性、增益、空间相关等材料模型，且支持材料库管理功能。请参看 材料元件 。 EastWave 支持多种激励源定义，支持文本格式作为激励源数据导入。请参看 激励源模块 。 EastWave 的脚本语言支持对计算结果进行数学、绘图处理。请参看 监视器模块 、 数据后处理 、 EastWave 脚本语言 。 版本说明 EastWave 7 版本对外发布的版本包括： xxxx版（面向xxxx）、xxxx版（面向xxxx），xxxx种版本的部分功能有差异列举如下： 模块  xxxx版 xxxx版 xxxx版 计算模式 自定义模式  √ 自动计算透反率模式   √ 天线罩(功率传输系数，扫频/扫角，相扫） √ 天线罩（功率传输系数，快速扫角，相扫）  √ 天线罩（功率传输系数，快速扫角，机扫）  √ 天线罩（瞄准线误差，快速扫角，相扫）   √ 建模 天线罩（全部）   √ 多层物体  √ 参数多边形曲线柱体  激励源 馈源阵列  √ 等效同轴波导  √ √ √ ',title : '发行说明',flags : 0,children : []},{file:'./data/help_res_require.htm',name : 'help_res_require',body : '系统要求 基本配置： Microsoft Windows 2000/XP/Vista/Windows 7 32-bit or 64-bit；Linux； 采用x86/x86-64架构的 Intel/AMD CPU，主频不低于1GHz； 内存不低于512MB； 磁盘空间不低于1GB。 推荐配置： Microsoft Windows 7/8/10 64-bit； Intel Core i5/i7 处理器（四核以上，建议第四代酷睿核心以上），主频3GHz以上； 内存8GB以上，建议组建双通道或多通道； 应用程序空间不低于1GB，另有专用计算分区20GB以上。 配置512MB以上显存的独立显卡，可以显著提高操作大量几何单元的显示速度。 高性能计算服务器配置建议： Microsoft Windows Server 2008/2012 64-bit； Intel Xeon系列CPU，6核以上，主频3GHz以上； 双路以上服务器架构，建议四路或以上； 内存64GB以上，建议组成3通道或4通道； 使用大容量高速固态硬盘存放计算结果，可大大提高时域截面场的记录速度； 使用多达1TB以上的空间用于保存每次记录结果。 ',title : '系统要求',flags : 0,children : []},{file:'./data/help_res_maintenance.htm',name : 'help_res_maintenance',body : 'EastWave 7 服务 技术服务 项目服务  项目服务包括仿真、验证计算、优化设计和疑难问题查找分析，根据用户的日程和预算（需求、工作量、资源消耗）等制定计划，由我公司自身工程师提供专业服务。 解决方案  上海东峻基于卓越的优化设计能力，与国内外硬件商、器件商和承建商联合，可提供用户全面高水平的解决方案。 联合申报国家项目和发表科技论文  基于客户单位的研发背景，可与东峻公司的优势相结合，寻找研发热点问题、联合申报国家各级项目，并发表高水平科技论文。 售前售后服务 内容  售前：技术性咨询、案例分析和讲座 售后：安装调试、技术培训、答疑解惑 特点  自助可控：无技术封锁，不受制于人，全面合作，方式灵活，支持二次开发； 快速响应：研发和技术服务团队就在身边，快速响应客户需求，沟通零成本； 信息全面：多层次、全方位、高效率咨询； 个性服务：根据客户需求，提供不同合作模式； 定期培训：提供软件培训和专业案例培训，定期举行培训服务。 ',title : '服务',flags : 0,children : []},{file:'./data/help_res_contact.htm',name : 'help_res_contact',body : '联系我们 公司信息 上海东峻信息科技有限公司  地 址： 上海市长宁区长宁路855号9B室  邮 编： 200050  总 机： 021-52385879  传 真： 021-52385879-0  线上交流 网站： http://www.eastfdtd.com  东峻科技的官方网站，用于展示有关东峻科技及其产品EastWave的全部内容， 主要包括公司介绍、市场活动及招聘，产品介绍、更新及使用下载，以及公司研究成果及经典案例等。 微信平台： “东峻科技EW”  官方微信主要用于推送最新案例、技术突破和疑难解答等，可及时与用户进行互动交流。 此外，还可以查看公司的招聘及市场活动、软件 EastWave 的更新、经典案例等。 论坛： 《微波仿真论坛》东峻科技企业板块  主要用于行业相关研究及案例的分享。 官方群： 东峻科技QQ官方群（49420005/110622281）  官方群是公司内部与用户直接交流的平台，主要用于解答用户疑问，分享研究成果和发送公司最新进展和论文奖励信息等。 部门联系人 部门  联系人 联系方式 技术支持部 姚工 固话: 021-52385879-802 邮箱: support@eastfdtd.com 市场部  赵工 固话: 021-52385879-810 / 15901773309 邮箱: market@eastfdtd.com 人力资源部 陈女士 固话: 021-52385879-803 邮箱: hr@eastfdtd.com 发表论文奖励 凡购买东峻科技公司软件产品 EastWave 的正式用户，在国内外学术期刊发表学术文章并注明软件贡献， 且用户为第一作者或老师是第一作者均可获得该项奖励，提交材料详细内容与相应负责人联系。 联系人 联系方式 王工 固话: 021-52385879-808 邮箱: market@eastfdtd.com   ',title : '联系我们',flags : 0,children : []}]},{file:'./data/help_common_ref.htm',name : 'help_common_ref',body : '1. 名词约定 2. 时域有限差分法 3. 物理光学方法 4. 坐标变换的数学原理 5. 导入模型文件说明 6. 文档使用指引 ',title : '通用参考',flags : 0,children : [{file:'./data/help_common_ref_noun.htm',name : 'help_common_ref_noun',body : '名词约定 在此对软件工作界面和帮助文档中所用的一些约定名词作统一的解释，如无特别说明，名词的意义与本约定保持一致。   宽度A、宽度B 以轴向为参考方向，按 X &gt; Y &gt; Z &gt; X 的轮换顺序，“宽度A”表示轴向下一个轴方向上的宽度，“宽度B”表示轴向下下一个轴方向上的宽度。 例如，假设一个棱锥截头体的轴向为“坐标轴Y”，则“宽度A”表示Z方向上的宽度，“宽度B”表示X方向上的宽度。 &nbsp;&nbsp;注意 使用工作平面，定义局部坐标系后，将全局的X,Y,Z坐标轴理解为该局部坐标系的X"(U),Y"(V),Z"(N)坐标轴。 θ、φ 在标准球坐标系中，θ表示坐标系中的一点P与原点之间的连线和Z轴正方向之间的夹角，φ表示P点在XOY面上的投影与原点之间的连线和X轴正方向的夹角。 频率、频率序列、频率范围 频率：表示一个频率单值； 频率序列：表示一组频率值，通过 EastWave 中任意定义数组的方式来生成，如(下限:间隔:上限),linspace(下限,上限,个数),array(元素1,元素2,...,元素n)； 频率范围：表示一组频率值，通过 EastWave 中的 range 函数给出下限和上限来生成，用法 range(下限,上限)。  ',title : '名词约定',flags : 0,children : []},{file:'./data/help_common_ref_fdtd.htm',name : 'help_common_ref_fdtd',body : '1. FDTD原理 2. Lorentz 材料模型相关公式推导 ',title : '时域有限差分法',flags : 0,children : [{file:'./data/help_common_ref_fdtd_FDTD_method.htm',name : 'help_common_ref_fdtd_FDTD_method',body : 'FDTD 原理 基本原理 EastWave 软件采用时域有限差分法（ FDTD ）对电磁波进行仿真和模拟， FDTD 方法自 1966 年首次提出后，得到迅速发展和广泛应用，当前已经在许多领域取得诸多研究成果和应用价值。该方法是直接由时域麦克斯韦方程组对电磁场进行计算模拟的数值分析方法，由麦克斯韦方程组可推导出 [1] ： $$ frac{ partial{ vec{E}}}{ partial{t}}= frac{1}{ varepsilon} vec{ nabla} times vec{H}- frac{ sigma_e}{ varepsilon} vec{E} tag{1-1a}$$ $$ frac{ partial{ vec{B}}}{ partial{t}}=- vec{ nabla} times vec{E}- vec{J_m} tag{1-1b}$$ 上式中 $ varepsilon$, $ sigma_e$ 分别是介质的介电系数，电导率（这里都是绝对系数而非相对系数），$ varepsilon$, $ sigma_e$ 的值与空间位置有关。 将上面两个式子在直角坐标系下展开得到： $$ frac{ partial{E_z}}{ partial{y}}- frac{ partial{E_y}}{ partial{z}}=- mu frac{ partial{H_x}}{ partial{t}}- sigma_m H_x tag{1-2a} $$ $$ frac{ partial{E_x}}{ partial{z}}- frac{ partial{E_z}}{ partial{x}}=- mu frac{ partial{H_y}}{ partial{t}}- sigma_m H_y tag{1-2b} $$ $$ frac{ partial{E_y}}{ partial{x}}- frac{ partial{E_x}}{ partial{y}}=- mu frac{ partial{H_z}}{ partial{t}}- sigma_m H_z tag{1-2c} $$ FDTD 离散化采用正交网格的 Yee 元胞，其空间排布如下所示： image 1: Yee 元胞场量分布 由图可见每一个磁场分量由四个电场分量环绕；同样，每一个电场分量由四个磁场分量环绕。此外，电场和磁场在时间顺序上交替抽样，抽样时间间隔彼此相差半个时间步，使麦克斯韦旋度方程离散以后构成显式差分方程，从而可以在时间上迭代求解。因此，由给定相应的电磁场问题的初始值和边界条件， FDTD 方法就可以逐步推进的求解空间电磁场。 差分形式 若设观察点 $(x, y, z)$ 为 $Ex$ 的节点$(i+1/2, j, k)$，以及时刻 $t=(n+1/2)Δt$，于是，公式 $1-2$ 可以离散化为如下形式： $$ begin{equation} begin{split} E_x^{n+1}(m)&= C_A(m) cdot E_x^n(m) &+ C_B(m) cdot [ frac{H_z^{n+ frac{1}{2}}(i+ frac{1}{2},j+ frac{1}{2},k)-H_z^{n+ frac{1}{2}}(i+ frac{1}{2},j- frac{1}{2},k)}{ Delta y} &- frac{H_y^{n+ frac{1}{2}}(i+ frac{1}{2},j,k+ frac{1}{2})-H_y^{n+ frac{1}{2}}(i+ frac{1}{2},j,k- frac{1}{2})}{ Delta z}] end{split} end{equation} tag{1-3} $$ 式中两个系数 $C_A(m)$ 和 $C_B(m)$ 分别为： $$ C_A(m)= frac{1- frac{ sigma_e(m) Delta t}{2 varepsilon(m)}}{1+ frac{ sigma_e(m) Delta t}{2 varepsilon(m)}} tag{1-4a}$$ $$ C_B(m)= frac{ frac{ Delta t}{ varepsilon(m)}}{1+ frac{ sigma_e(m) Delta t}{2 varepsilon(m)}} tag{1-4b}$$ 上式中标号 $ m = (i+1/2, j, k)$ 。另外两个电场分量离散形式如下： $$ begin{split} E_y^{n+1}(m)&= C_A(m) cdot E_y^n(m) &+ C_B(m) cdot [ frac{H_x^{n+ frac{1}{2}}(i,j+ frac{1}{2},k+ frac{1}{2})-H_x^{n+ frac{1}{2}}(i,j+ frac{1}{2},k- frac{1}{2})}{ Delta y} &- frac{H_z^{n+ frac{1}{2}}(i+ frac{1}{2},j+frac{1}{2},k)-H_z^{n+ frac{1}{2}}(i- frac{1}{2},j+ frac{1}{2},k)}{ Delta z}] end{split} tag{1-5a} $$ 其中: $ m=(i,j+1/2,k) $ $$ begin{split} E_z^{n+1}(m)&= C_A(m) cdot E_z^n(m) &+ C_B(m) cdot [ frac{H_y^{n+ frac{1}{2}}(i+ frac{1}{2},j+ frac{1}{2},k)-H_y^{n+ frac{1}{2}}(i- frac{1}{2},j,k+ frac{1}{2})}{ Delta y} &- frac{H_x^{n+ frac{1}{2}}(i,j+ frac{1}{2},k+frac{1}{2})-H_x^{n+ frac{1}{2}}(i,j- frac{1}{2},k+ frac{1}{2})}{ Delta z}] end{split} tag{1-5b} $$ 其中： $ m=(i,j,k+1/2) $ 离散磁场时，设观察点 $ (x, y, z)$ 为Hx的节点，即 $(i, j+1/2, k+1/2)$ 和时刻 $t=nΔt$，于是可以得到： $$ begin{split} H_x^{n+ frac{1}{2}}(m)&= C_P(m) cdot H_x^{N- frac{1}{2}}(m) &- C_Q(m) cdot [ frac{E_z^{n+ frac{1}{2}}(i,j+1,k+ frac{1}{2})-E_z^{n+ frac{1}{2}}(i,j,k+ frac{1}{2})}{ Delta y} &- frac{E_y^{n+ frac{1}{2}}(i,j+ frac{1}{2},k+1)-E_y^{n+ frac{1}{2}}(i,j+ frac{1}{2},k)}{ Delta z}] end{split} tag{1-6a} $$ 其中：$ m=(i,j+1/2,k+1/2)$ $$ begin{split} H_y^{n+ frac{1}{2}}(m)&= C_P(m) cdot H_y^{N- frac{1}{2}}(m) &- C_Q(m) cdot [ frac{E_x^{n+ frac{1}{2}}(i+ frac{1}{2},j,k+1)-E_x^{n+ frac{1}{2}}(i+ frac{1}{2},j,k)}{ Delta z} &- frac{E_z^{n+ frac{1}{2}}(i+1,j,k+ frac{1}{2})-E_z^{n+ frac{1}{2}}(i,j,k+ frac{1}{2})}{ Delta x}] end{split} tag{1-6b} $$ 其中：$ m=(i+1/2,j,k+1/2)$ $$ begin{split} H_z^{n+ frac{1}{2}}(m)&= C_P(m) cdot H_z^{N- frac{1}{2}}(m) &- C_Q(m) cdot [ frac{E_y^{n+ frac{1}{2}}(i+1,j+ frac{1}{2},k)-E_y^{n+ frac{1}{2}}(i,j+ frac{1}{2},k)}{ Delta x} &- frac{E_x^{n+ frac{1}{2}}(i+ frac{1}{2},j+1,k)-E_x^{n+ frac{1}{2}}(i+ frac{1}{2},j,k)}{ Delta y}] end{split} tag{1-6c} $$ 其中：$ m=(i+1/2,j+1/2,k)$ 式中系数$C_P(m)$ 和 $C_Q(m) $ 分别为： $$ C_P(m)= frac{1- frac{ sigma_m(m) Delta t}{2 mu(m)}}{1+ frac{ sigma_m(m) Delta t}{2 mu(m)}} tag{1-7a}$$ $$ C_Q(m)= frac{ frac{ Delta t}{ mu(m)}}{1+ frac{ sigma_m(m) Delta t}{2 mu(m)}} tag{1-7b}$$ 其中上角标 $ n-1/2 $ , $ n$ , $ n+1/2 $ , $ n+1 $ 表示时间步数，系数中的标号 $ m $ 代表一组整数或者半整数， $ Delta t$ 是时间步长，$ Delta x$, $ Delta y$, $ Delta z$ 表示相邻网格点分别在 $x$, $y$, $z$ 方向的间距。根据上述 FDTD 差分方程组即可得出计算电磁场的时域推进计算方法。 迭代稳定性要求和边界条件 FDTD 是一种显式格式差分算法，所以时间和空间步长应该遵守一定的规则，否则会发生稳定性问题 [2] 。在 FDTD 计算中，空间步长通常不应小于参考波长的 1/12 ，在三维情况下时间步长和空间步长需要满足如下方程： $$ c Delta t leq frac{1}{ sqrt{ frac{1}{ Delta x^2}+ frac{1}{ Delta y^2}+ frac{1}{ Delta z^2}}} tag{1-8} $$ 上述条件称为 Courant 稳定条件，为了能模拟开域的电磁散射过程，在计算区域的截断边界处必须给出适当的边界条件。 EastWave 内置了开放边界（包含 PML （完全匹配吸收层）、 UPML （单轴完全匹配吸收层）和 CPML （卷积式完美吸收边界）、周期边界、布洛赫边界、 PEC 边界和 PMC 边界。常用的开放边界条件使用 PML 技术吸收边界电磁场，这是一种基于吸收层的技术，该技术可以使以任意入射角和任意频率入射的平面波，投射到边界表面的反射系数的理论值都是零 [2] 。 UPML 适用于色散介质以及边界处介质不连续的情况，周期边界常用于周期性结构情况。 PEC 边界和 PMC 边界适用于某些特定情况，如 PEC 边界可以用于模拟微波暗室中被吸波材料覆盖的边墙。 参考文献 [1] 葛德彪，闫玉波. 电磁波时域限差分方法. 西安：西安电子科技大学出版社. [2] Allen Taflove.et.al, Computational Electrodynamics: The Finite-Difference Time-Domain Method. Artech House. ',title : 'FDTD原理',flags : 0,children : []},{file:'./data/help_common_ref_fdtd_Lorentz_material_equation.htm',name : 'help_common_ref_fdtd_Lorentz_material_equation',body : 'Lorentz 材料模型相关公式推导 洛伦兹(Lorentz)色散模型涵盖了所有电磁色散模型。从该模型中可以衍生出各种色散模型： Drude 色散模型推导过程 采用自由电子气模型描述金属内部自由电子的运动规律，运动方程如下： $$ m_e ddot{x} + m_e gamma dot{x} = e E_0 exp(-i omega t) tag{2-1}$$ 式中 $ gamma$ 为阻尼系数，$m_e$ 为电子的质量，$e$ 为电子电量，$ E_0 exp(-i omega t)$ 为外加光强大小，求解该方程得到 $x$ 的表达式： $$ x=- frac{e}{m_e( omega^2+i gamma omega)} tag{2-2} $$ 利用 $ p=nex= varepsilon_0 chi E$，得到： $$ chi= frac{nex}{ varepsilon_0 E}=- frac{ne^2}{m_e varepsilon_0} cdot frac{1}{ omega^2+i gamma omega} tag{2-3}$$ 令 $ omega^2= ne^2 /m_e varepsilon_0$ 则可以得到： $$ varepsilon =1+ chi=1- frac{ omega_p^2}{ omega^2+i gamma omega} tag{2-4}$$ 在自由电子气模型中，当$ omega gg omega_p $时，$ varepsilon rightarrow 1 $，这实际上忽略了电子能带间跃迁对金属介电系数的影响，为了考虑这一影响（高频电磁波受电子能带间跃迁影响导致$ varepsilon_ infty neq 1$），对 Drude 模型做如下修正： $$ varepsilon = varepsilon_ infty - frac{ omega_p^2}{ omega^2+i gamma omega} tag{2-5}$$ $ varepsilon_ infty$ 为当$ omega gg omega_p $时金属介电系数的值。令 $ gamma = omega_c $，则有： $$ varepsilon = varepsilon_ infty - frac{ omega_p^2}{ omega^2+i omega_c omega} tag{2-6}$$ Lorentz 模型推导过程 采用阻尼谐振子近似描述介质内部束缚电子的运动过程，束缚电子的运动方程如下： $$ m_e ddot{x} +m_e omega_c cdot{x}+ m_e omega_a^2 x = e E_0 exp(-i omega t) tag{2-7}$$ 其中$ omega_a $为振子的谐振角频率，$ omega_c $为束缚电子运动的阻尼系数，求解上述方程得到 $ chi$ 的表达式： $$ x= frac{e}{m} cdot frac{1}{ omega_a^2- omega^2-i omega omega_c} E_0 exp(-i omega t) tag{2-8}$$ 利用$ p=nex= varepsilon_0 chi E$，得到极化率 $ chi$ 的表达式： $$ chi= frac{nex}{ varepsilon_0 E}= frac{ne^2}{m_e varepsilon_0} cdot frac{1}{ omega_a^2- omega^2-i omega omega_c} tag{2-9} $$ 令 $ omega^2= ne^2 /m_e varepsilon_0$ ，则可以得到： $$ varepsilon( omega)=1+ chi = 1+ frac{ omega_p^2}{ omega_a^2- omega^2-i omega omega_c} tag{2-10} $$ 上述推导过程适用于低频情况，对于高频情况（考虑电子能带间跃迁的影响使得$ varepsilon_ infty neq 1$），需要对 Lorentz 模型做如下修正： $$ varepsilon( omega)= varepsilon_ infty + frac{ omega_p^2}{ omega_a^2- omega^2-i omega omega_c} tag{2-11} $$ 其中$ varepsilon_ infty $为材料相对介电常数的高频极限。 ',title : 'Lorentz 材料模型相关公式推导',flags : 0,children : []}]},{file:'./data/help_common_ref_po.htm',name : 'help_common_ref_po',body : '1. PO原理 2. PO应用 ',title : '物理光学方法',flags : 0,children : [{file:'./data/help_common_ref_po_PO_method.htm',name : 'help_common_ref_po_PO_method',body : '基本原理 用物理光学方法计算一个散射体的远场（如 RCS ）时，需要以下几个假定： 照射到物体表面的电磁波波长较物体中主要散射结构的尺度要小，并且不处于谐振区。 物体表面一部分被照射，另一部分没有被照射到，只有被照射到的区域产生表面电流。 物体表面区域的任何一个局部都可以近似地看成是一个切平面。 在满足上述假定的条件下，可以从 Stratton–Chu 方程推出物理光学的基本公式。对于物体表面是理想电导体 PEC （Perfect Electric Conductor）时，散射体表面满足条件： $$ hat{ vec{n}} times vec{E}= vec{0} tag{1-1} $$ $$ hat{ vec{n}} times vec{H}= 2 hat { vec{n}} times { vec{H^i}} tag{1-2} $$ 上式中 $ vec{H^i}$ 表示入射场的磁场分量，表示照射表面的法向量。 已知物体表面电流分布 $ vec{J}( vec{r"})$ （源）的情况下，将所有面元在观察点 $ vec{r}$ 处的磁矢势积分： $$ vec{A}( vec{r})= mu int_S vec{J}( vec{r"}) G( vec{r}, vec{r"})ds" tag{1-3} $$ 进一步可算出 $ vec{r}$ 磁场： $$ begin{split} vec{H}( vec{r})&= frac{1}{ mu} vec{ nabla} times vec{A} &=[( hat{ vec{n}} times vec{H^i}) times hat{ vec{R}}](ik+ frac{1}{R}) cdot frac{e^{ikR}}{2 pi R} ds" end{split} tag{1-4} $$ 而电场的计算方式类似磁场。该方程称为物理光学积分公式，适用于近场和远场。上式中 $ hat{ vec{R}}$ 表示散射方位的单位向量。 对于远场散射问题，只有传播波分量，远区电场表达式和磁场表达可以进一步简化为： $$ vec{E}( vec{r})= frac{ik}{2 pi} sqrt{ frac{ mu}{ varepsilon}} int_S [ hat{ vec{R}} times hat{ vec{R}} times ( hat{ vec{n}} times vec{H^i}) cdot frac{e^{-ikR}}{R} ] ds" tag{1-5} $$ $$ vec{H}( vec{r})= - frac{ik}{2 pi} sqrt{ frac{ mu}{ varepsilon}} int_S [ hat{ vec{R}} times ( hat{ vec{n}} times vec{H^i}) cdot frac{e^{-ikR}}{R}] ds" tag{1-6} $$ 使用物理光学方法可以计算出电大尺寸圆形平板的后向 RCS ： $$ sigma= frac{ pi a^2}{ tan^2 theta} [J_1 ( frac{4 pi a sin theta }{ lambda}) ]^2 tag{1-7} $$ 圆盘的参数和坐标如下： image 1: 圆形平板的参数和坐标 上式中 $J_1(x)$ 为一阶 Bessel 函数。当 $x rightarrow 0 $ 时，$J_1(x) rightarrow x/2$ 可得： $$ sigma|_{ theta=0} = 4 pi frac{A^2}{ lambda^2} tag{1-8} $$  详细了解相关内容请参考《电磁散射的计算和测量》 [1] 。 参考文献 [1] 何国瑜、卢才成、洪家才、邓晖 编著，《电磁场散射的计算和测量》，北京航空航天大学出版社，2006年12月第1版，第224页–第226页 ',title : 'PO原理',flags : 0,children : []},{file:'./data/help_common_ref_po_PO_applicantion.htm',name : 'help_common_ref_po_PO_applicantion',body : '应用 由于 PO 是一种高频电磁波快速估算算法，适合计算电大物体的散射场，因此常应用于以下领域： 舰船、飞机的雷达目标 RCS 口面天线的远场 EastWave 提供了几种计算模式可支持这些应用场景的仿真，请用户参考第三章功能介绍。 雷达目标的 RCS 雷达目标的雷达散射截面（ RCS ）反映了目标物体在远区雷达照射的情况下的截面尺度，单位为 $m^2$ 或 dB$m^2$。 RCS 定义为平面波入射时，一个单位距离下某个角度的散射场能量面密度和入射能量面密度之比。 雷达目标的 RCS 计算包括两种主要模式： 1. 单站 RCS 2. 双站 RCS 其中，单站 RCS 模式指的是由同一位置（同一雷达）发射并接收雷达波信号后所测量的 RCS 值，在这种情况下发射站和接收站位置完全重合，该模式也叫背向散射 RCS 。而双站 RCS 模式则考虑接收站位置和接收站不相同时计算的 RCS 。 反射面天线 反射面天线是最常见的口面场天线，可以使用口径积分即物理光学方法计算其远场场量。 最简单的反射面是抛物面，也有一些为达到特殊目的而构造的非抛物型反射面，如作为近场反射用的双曲反射面等。其中最基本的反射面天线是 “卡塞格伦天线” ： image 1: 卡塞格伦天线示意图 ',title : 'PO应用',flags : 0,children : []}]},{file:'./data/help_common_ref_Coordinate_transformation.htm',name : 'help_common_ref_Coordinate_transformation',body : '坐标变换 一般来说物体坐标系有两个，一个是 “局部坐标系” ，另一个是 “全局坐标系” 。 所谓 “局部坐标系” 是指物体内部的每个部分（如组物体中的每个子物体）相对于该物体的坐标系，所有子物体之间的拓扑关系在子坐标系内不变。 所谓 “全局坐标系” 是指物体相对于其他物体共享的全局坐标系。 由于对一个空间向量的几何变换可以用一个 4x4 矩阵来表述，而物体的全部变换可以由一组左乘矩阵和一组右乘矩阵确定： $$ R"=M_1^L cdot M_2^L cdot ldots cdot M_n^L cdot R odot M_1^R odot M_2^R odot ldots odot M_n^R tag{3-1} $$  根据普遍约定，左乘矩阵 $M^L$ 表示在全局坐标系中的变换，右乘矩阵 $M^R$ 表示在局部坐标系中的变换。根据这样的约定，当用户设定了一个组，且组内物体的变换均为局部坐标变换，并且用户对整个组进行全局坐标变换，则进行全局坐标变换后组内物体的相对位置是不会发生变化的。 一个向量被一个矩阵左乘等于其的转置右乘该矩阵的转置后再转置，左乘矩阵与等价的右乘矩阵互为转置： $$ M_1 cdot R =(R^T odot M_1^T)^T tag{3-2} $$ 右乘和左乘不同，左乘和矩阵乘法相同，而右乘则是向量的转置与右矩阵相乘，右乘具有“穿透”特性，例如两个右乘乘子 $M_1$ 和 $M_2$ ： $$ begin{split} V^T odot M_1 odot M_2 &= (M_1^T cdot V)^T odot M_2 &= (M_2^T cdot (M_1^T cdot V)^T)^T &= (M_1^T cdot M_2^T cdot V)^T end{split} tag{3-3} $$ 从上式可以看出，如果将一个向量变换为另一个向量采取全左乘和全右乘的差别在于，先右乘等价于后左乘，后右乘等于先左乘。 例如某物体在全局变换下：(1) 沿着 Z 轴移动 50 ；(2) 绕着 Y 轴（逆时针）旋转 90 度。 其操作完全用右乘来描述时应将顺序颠倒：(1) 绕着 Y 轴（逆时针）旋转 90 度；(2) 沿着 Z 轴移动 50 ，反之亦然。 以一个局部坐标系 3D 模型为例，我们构建了一个由红、绿、蓝分别标识的 U , V , N 局部坐标轴，然后设置其局部坐标变换： image 1: 坐标变换设置 我们设置为（局部坐标系下）：(1) 先按 N 移动 50 ；(2) 再绕 V 轴（逆时针）旋转 15 度；(3) 最后绕 N 轴（逆时针）旋转 45 度，其效果如下图： image 2: 模型效果：红色对应 u，绿色对应 v,蓝色对应 n 其效果等价于（全局坐标系下）：(1) 先绕 Z 轴（逆时针）旋转 45 度；(2) 再绕 Y 轴（逆时针）旋转 15 度；(3) 最后沿着 Z 轴移动 50 。 注意 选用局部坐标变换时， X 对应 U ， Y 对应 V ， Z 对应 N 。 局部坐标变换时，任何一步都紧盯住当前局部坐标系 （U, V, N） 三个轴进行操作。 用户可以在界面从工程模板中新建文件，并选择 “电磁波工程（局部坐标系变换）” 的工程模板，对其中物体节点中的 “坐标系统” 对象进行各种坐标变换操作，以便于用户理解。 ',title : '坐标变换的数学原理',flags : 0,children : []},{file:'./data/help_common_ref_model.htm',name : 'help_common_ref_model',body : 'empty page ',title : '导入模型文件说明',flags : 0,children : []},{file:'./data/help_common_ref_system.htm',name : 'help_common_ref_system',body : '文档使用指引 EastWave 7 文档及使用对象 EastWave 7 主要的配套文档包括： 文档名称 介绍 读者对象 概览 提供 EastWave 7 的简单介绍，包括产品架构（模块及功能）、功能特性、产品优势亮点、应用场景。 初学者 安装部署 提供 EastWave 7 的安装指南，包括产品的安装、配置许可证、卸载。 所有人员 快速入门 介绍计算模式实例的创建，供初学者快速入门。 初学者 操作指南 提供完整的产品功能及操作指导。 仿真用户 完整实例 提供本产品在典型场景下的应用。 仿真用户 计算模式 参考指南 详细介绍了 EastWave 7 的各种计算模式。 仿真用户 模型编辑器 参考指南 详细介绍了 EastWave 7 的建模工具。 仿真用户 仿真分析 参考指南 详细介绍了 EastWave 7 的仿真设置以及配置。 仿真用户 EastWave 脚本语言 参考指南 详细介绍了 EastWave 7 脚本语言，提供高级用户更多自定义功能。 高级仿真用户 高阶教程 介绍了脚本开发以及插件的使用教程，扩展 EastWave 7 的特殊功能。 高级仿真用户 常见问题 包括典型问题及处理方法、常见FAQ等。 所有人员 通用参考 提供名词约定、FDTD 简介、PO 简介、坐标变换原理等内容。 所有人员 内部文档 仅对内部人员开发的帮助文档。 内部人员 EastWave 7 文档系统说明 EastWave 7 帮助系统是基于 HTML 开发的一套系统，该帮助系统的一切内容都通过 Web浏览器 展示。你可以通过 在线 或 离线 的方式访问该帮助系统。 &nbsp;&nbsp;注意 若使用的浏览器版本过旧，会导致 EastWave 帮助文档的部分内容显示效果不佳。为了更好的浏览体验，请你升级浏览器版本。推荐使用 Chrome 或 FireFox 浏览器。 ',title : '文档使用指引',flags : 0,children : []}]},{file:'./data/help_internal_doc.htm',name : 'help_internal_doc',body : '1. Markdown语法说明 2. 图表库(帮助系统)说明 3. MathJax语法说明 4. 计算模式 5. 窗口管理器 6. 基础库说明 7. 命名规范 8. mathlib 9. 测试说明 ',title : '内部文档',flags : 0,children : [{file:'./data/help_internal_doc_markdown.htm',name : 'help_internal_doc_markdown',body : '1. 概述 1.1. 段落和换行 1.2. 前置行转义 1.3. 语义块 1.4. 引用 2. 区块元素 2.1. 标题 2.2. 引用代码 2.3. 内容引用 2.4. 列表 2.5. 表格 2.6. 块引用 3. 区段元素 3.1. 字体效果 3.2. 超链接、图片、锚定义 3.2.1. 超链接 3.2.2. 图片 3.2.3. 锚定义 3.2.4. 模板文件定义 4. html版帮助系统说明 1. 概述 Markdown的目标是实现易读易写。 在主流Markdown的基础上进行大量的扩展改进， 语法严格化，并根据我们的需求扩展出多种语法， 实现多页面统一生成，跨页面引用等。  Markdown兼容HTML，优先使用HTML解释器对整个文件进行解释。 对非HTML的内容，再使用Markdwon解释器进行处理。  如果某段内容，希望直接使用Markdown语法处理， 可以在行都使用 "`" 加上一个空格来实现，加上这个后，本行后续的内容直接当使用Markdown解释器处理。 如果是多行内容，可以使用块定义并设置markdown的标识来处理。  ` 这里的内容使用markdown来处理 ```markdown 这里一大段的内容使用markdown来处理 ```  1.1. 段落和换行 一个Markdown段落，由一个或多个连续的文本行组成， 两个或以上的空行，代表新的段落的开始。 行尾两个或以上的空格，表示换行。 1.2. 前置行转义 前置行转义 符号 作用 # 标题 `  代表后续的内容，直接使用markdown解释器处理 &gt; 代表后续的内容为引用 * 无序列表  + 有序列表  前置转义符，后面必须有空格，无空格的情况不认为是前置转义符。  其中，除了"#"以外的其他行转义符，可以嵌套使用。  后续的行，根据开始内容，做不同的处理： 以两个空格开始，认为是跟上面行转义内容的延续  以同类转义符开始，认为是新的同级别的项 其他情况，转义结束 示例： 下面是一个列表 ` * 列表内容中有html特殊字符&lt;hello&gt;哦 * 列表的第二项 * 这是第二项里的一个子列表 前面有四个空格，这是子列表第二项内容的延续 * 这是子列表的第二项 前面有两个空格，这是顶层列表的第二项的延续内容 * 列表第三项 &gt; 前面有两个空格，这是第三项内容的延续，这里是一个引用 第三项引用的内容里又使用了列表 * 引用里又使用了列表 * 引用里的列表第二项  效果：  下面是一个列表 列表内容中有html特殊字符&lt;hello&gt;哦 列表的第二项 这是第二项里的一个子列表 前面有四个空格，这是子列表第二项内容的延续 这是子列表的第二项 前面有两个空格，这是顶层列表的第二项的延续内容 列表第三项 前面有两个空格，这是第三项内容的延续，这里是一个引用  第三项引用的内容里又使用了列表 引用里又使用了列表 引用里的列表第二项  1.3. 语义块 使用下列方式，可以定义语义块 ```[type[`endtag]] content ```[endtag] 其中：type指定语义块的类型，endtag为结束标识。 type目前定义有 markdown、rawtext、htmtext、block和code等。 对于未定义的type，使用code解释，认为是代码块 1.4. 引用 引用，可用来定义包括超链接，图片引用，表格引用等内容。 具体有下面三种方式： [type](params) [type-def:name](params) [type-ref](name) 其中，type是引用的类型，params是参数。 目前已经定义的type有link、image、anchor和block， 以后可能会引入其他的引用类型。 带 -def 的为预先定义，不产生真正的内容，但可以被 -ref 引用。  具体语法见  3.2. 超链接、图片、锚定义 。 3.2.1. 超链接 3.2.2. 图片 3.2.3. 锚定义 引用类型说明 类型 作用 link 超链接 image 图片 anchor 位置锚 block 内容块 topic 目录索引 template 模板文件 2. 区块元素 2.1. 标题 有两种方式实现标题。 第一种方式: 在标题的后续一行，使用6个或以上的"="、"-"或"."， 这种方式下构造出来的标题，会自动生成索引。 第二种方式: 是在行的内容，使用一个或多个#号加一个空格开始时， 这行的内容会自己作为标题，#的个数为标题的级别。   标题效果： #The largest heading ##The second largest heading ###The thrid heading ####The fourth heading #####The fifth heading ######The smallest heading  2.2. 引用代码 行内引用 `代码` 或 ```代码``` 多行引用，请直接使用特殊的语义块，type为代码的语言，如c++、ewsl等。   2.3. 内容引用 在行的最前面使用 &gt;  引用其他内容: &gt; 下面又再引用其他内容 &gt; hello world * 引用里的一个列表的第一项 * 第二项 下面再次再次引用其他内容 &gt; hello, world! 第二层引用结束 第一层引用结束   效果:  引用其他内容: 下面又再引用其他内容 hello  world 引用里的一个列表的第一项 第二项 下面再次再次引用其他内容 hello, world! 第二层引用结束 第一层引用结束     2.4. 列表 列表1  George Washington John Adams Thomas Jefferson 列表2  Make my changes Fix bug Improve formatting Make the heading bigger Push my commits to Github Open a pull request Describe my changes Mention all the members of my team Ask for feedbackk  有序列表 item1 item2 item3 有序列表嵌套无序列表 item1 item1.1 item1.2 item2.1 item2.2 item3 2.5. 表格 定义：  | name | value | | n1 | v1 | | n2 |(2) v2 | | v3 |  效果：  name value n1 v1 n2 v2 v3 注意：如果表格中有 | 字符，需要转义，使用 | 代替。  2.6. 块引用 定义：  ```block:table1 | name | value | | n1 | v1 | | n2 |(2) v2 | | v3 | ``` ```block:table2 | name | value | | n1 | v1 | | n2 |(2) [block-ref](table1) | | v3 | ``` 引用：  [block-ref](table2) 效果：  name value n1 v1 n2 name value n1 v1 n2 v2 v3 v3 3. 区段元素 3.1. 字体效果 table 1: 字体效果表 名称 语法 效果 bold **text** text italicized *text* text misstaken ~~text~~ text important **_text_** _text_ 3.2. 超链接、图片、锚定义 table 2: 定义表 名称 语法 link [link](url,text,title) image [image](url,alt.text,anchor) anchor [anchor](anchor,text,title) 预先定义一些引用: [type-def:name](arg_list)  使用预先定义的引用： [type-ref](name)  3.2.1. 超链接 直接定义链接： [link]("http://www.eastwave.com.cn","EastWave","go to EastWave homepage")  预定链接并引用： [link-def:.mylink]("mylink.url","mylink.text","mylink.title") [link-ref](mylink) 自动生成的预定义链接: 每个章节都生自动生成一个预定义链接，名字的规则为 简称用 _ 连接起来。比如本页面是 help_doc_markdown 。 每个章节的内容的标题索引，名字为 本页面的名称+.header_标题的编号 ，比如这里是 help_doc_mardown.header_3_2_1 。 引用已有的链接：  link: [link-ref](".header_2")  效果: 2. 区块元素  3.2.2. 图片 image: [image]("image.url","alt.text")  3.2.3. 锚定义 定义方式: [anchor](".myposition") 使用 . 开头，前面会自动加上本页面的名称。 要引用上面这个位置，可这样 [link]("?help_internal_doc_markdown.myposition") 3.2.4. 模板文件定义 定义方式: [template](etching_example.ewp2) 效果： etching_example.ewp2 4. html版帮助系统说明 source目录为源目录，web目录为目标目录。 source目录下， 每一个目录为一个子章节， 目录组织即为帮助内容的章节组织。 目录的名称为内部简称，采用prefix.name的方式命名。 其中prefix为前缀，仅用于排序，无其他意义。 name为该章节的内部简称。 每个目录下，有config.ewsl文件， 这个用于配置该章节的信息，目前仅包括该章节的全称。 此外，还有很多的内容文件，命名规则为 prefix.content.ext。 其中prefix为前缀，仅用于排序，无其他意义。 处理时，按prefix排序，依次生成帮助内容，最后合并为一个文件。 ext为扩展名，扩展名其中txt时，使用Markdown处理该文件。 扩展名为htm时，不做任何处理，直接嵌入。 web/help目录为目标目录，生成的文件， 全部入在data目录下，其他文件为帮助框架文件， 需要考虑浏览器兼容问题。 这里的index.htm文件，是总的框架文件，这个文件， 可以有多个实现，应对不同的浏览器，或是采用不同的风格。 最终，我们希望实现为无刷新的版本。  修改source后，需要执行一次 ewx_help ，重新生成帮助文件。 这个动作，在使用我们自定义的httpserver服务器的情况， 可以在某个动态网页上加出这个功能。 有些浏览器，没有权限直接访问本地文件， 这情况下，可以使用ewsl库创建的httpserver。 使用 ewx_ewsl.exe httpserver.ewsl 的方式来启动， 启动后可以通过http://localhost或http://127.0.0.1来访问生成的帮助文档。 httpserver.ewsl的内容 local s=net.httpserver(); local t=table(); // http setting t.port=80; // https setting //t.ssl_port=443; //t.ssl_cert="ssl_cert.pem"; //t.ssl_key="ssl_key.pem"; // no cache, for test t.maxage=0; s(t); 使用ewsl来定义动态网页 // 文件开头 #function(session,request,response); global server; // 可以使用response.buffer.write来输出 // 可以使用response.redirect来重定向到其他文件 // 一般的情况下，这个动态页面，返回一个json文件，其他功能使用前端脚本实现。 // ewsl的table，只要不存在特殊类型的数据如函数等，可使用to_json函数转换为json格式。  示例：reload.ewsl，功能为重新生成help文档，然后再重定向到help/index.htm。 // file reload.ewsl #function(session,request,response); global server; util.htmlgen("source","web/help") response.redirect("help/index.htm"); 使用动态网页加上我们的ewsl库，可以实现很多功能。 动态报告生成系统 在线题库系统 license的internet认证功能 试用版验证码自动计算功能 任务管理系统  ',title : 'Markdown语法说明',flags : 0,children : []},{file:'./data/help_internal_doc_chart.htm',name : 'help_internal_doc_chart',body : '图表库 使用帮助系统提供的 chart 图表库，可绘制多种类型的图表。 如何使用图表 在 markdown 文本文件中只需引入以下代码即可生成一个类型为 line 的图表： ```chart { type: "line", labels: ["物品 A", "物品 B", "物品 C", "物品 D", "物品 E", "物品 F"], datasets: [{label: "城市 A", data: [1000, 500, 300, 500, 200, 300]},{label: "城市 B", data: [500, 400, 700, 2000, 240, 500]}] } ``` 参数说明： 参数 说明 类型 备注 type 图表类型 String 包括 line bar horizontalBar radar pie doughnut polarArea bubble scatter labels 数据标签 Array - datasets 数据系列 Array - beginAtZeroX 强制 X 轴从0开始 Bool 默认值为 false beginAtZeroY 强制 Y 轴从0开始 Bool 默认值为 false tension 贝塞尔曲线张力设置，设为0时，没有曲线张力 Number 默认值为 0.0 ，只针对 line 类型图表 width 图表宽度(百分比)，取值范围 0-100 Int 默认值为 80 height 图表高度(百分比)，取值范围 0-100 Int 默认值为 60 完整 Demo 创建一个类型为 line ，贝塞尔曲线张力为 0.4 的图表 ```chart { type: "line", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A", data: [1000, 500, 300, 500, 200, 300]},{label: "城市B", data: [500, 400, 700, 2000, 240, 500]}], tension: 0.4 } ```  创建一个类型为 line ，自定义背景颜色，贝塞尔曲线张力为默认值 0.0 ，Y 轴从0开始的图表 ```chart { type: "line", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A", data: [1000, 500, 300, 500, 200, 300], backgroundColor: "rgba(255,0,0,0.2)"}, {label: "城市B", data: [500, 400, 700, 2000, 240, 500], backgroundColor: "rgba(0,0,255,0.2)"}], beginAtZeroY: true } ```  创建一个类型为 bar 的图表 ```chart { type: "bar", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A",data: [1000, 500, 300, 500, 200, 300]},{label: "城市B",data: [500, 400, 700, 2000, 240, 500]}] } ```  创建一个类型为 horizontalBar ，高度为 50% ，宽度为 50% 的图表 ```chart { type: "horizontalBar", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A",data: [1000, 500, 300, 500, 200, 300]},{label: "城市B",data: [500, 400, 700, 2000, 240, 500]}], width: 50, height: 50 } ```  创建一个类型为 radar 图表 ```chart { type: "radar", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A",data: [1000, 500, 300, 500, 200, 300]},{label: "城市B",data: [500, 400, 700, 2000, 240, 500]}] } ```  创建一个类型为 pie 图表 ```chart { type: "pie", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A",data: [1000, 500, 300, 500, 200, 300]},{label: "城市B",data: [500, 400, 700, 2000, 240, 500]}] } ```  创建一个类型为 doughnut 图表 ```chart { type: "doughnut", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A",data: [1000, 500, 300, 500, 200, 300]},{label: "城市B",data: [500, 400, 700, 2000, 240, 500]}] } ```  创建一个类型为 polarArea 图表 ```chart { type: "polarArea", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A",data: [1000, 500, 300, 500, 200, 300]},{label: "城市B",data: [500, 400, 700, 2000, 240, 500]}] } ```  创建一个类型为 bubble 图表 ```chart { type: "bubble", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A",data: [{x:0,y:0,r:1}, {x:0,y:1,r:2}, {x:0,y:2,r:3}, {x:0,y:3,r:4}, {x:0,y:4,r:5}, {x:0,y:5,r:6}]}, {label: "城市B",data: [{x:2,y:0,r:1}, {x:2,y:1,r:2}, {x:2,y:2,r:10}, {x:2,y:3,r:4}, {x:2,y:4,r:20}, {x:2,y:5,r:6}]}, {label: "城市C",data: [{x:5,y:0,r:1}, {x:5,y:1,r:2}, {x:5,y:2,r:3}, {x:5,y:3,r:4}, {x:5,y:4,r:5}, {x:5,y:5,r:6}]}] } ```  创建一个类型为 scatter 的图表 ```chart { type: "scatter", labels: ["物品A", "物品B", "物品C", "物品D", "物品E", "物品F"], datasets: [{label: "城市A",data: [{x:0,y:0}, {x:0,y:1}, {x:0,y:2}, {x:0,y:3}, {x:0,y:4}, {x:0,y:5}]}, {label: "城市B",data: [{x:2,y:0}, {x:2,y:1}, {x:2,y:20}, {x:2,y:3}, {x:2,y:40}, {x:2,y:5}]}, {label: "城市C",data: [{x:5,y:0}, {x:5,y:1}, {x:5,y:2}, {x:5,y:3}, {x:5,y:4}, {x:5,y:5}]}] } ```  ',title : '图表库(帮助系统)说明',flags : 0,children : []},{file:'./data/help_internal_doc_mathjax.htm',name : 'help_internal_doc_mathjax',body : '1. 简介 2. 基本语法 2.1. 公式编辑 2.2. 分组 2.3. 公式中插入文字 2.4. 空格 2.5. 分段和对齐 2.6. 注释 2.7. 转义字符 3. 上下标 4. 括号 4.1. 常用括号 4.2. 定界符 5. 公式格式 5.1. 字体 5.2. 尺寸 6. 数学表达式 6.1. 分式 6.2. 向量 6.3. 矩阵和行列式 6.4. 方程组 6.5. 分段函数 6.6. 排列组合式 7. 数学运算 7.1. 基本数学运算符 7.2. 常用数学运算符 7.3. 特殊数学运算符 7.4. 常用数学函数 8. 希腊字母 9. 其它 9.1. 省略号  MathJax语法 1. 简介 　　MathJax是一个JavaScript引擎，用来显示网络上的数学公式。它支持大部分的主流的浏览器，使用MathJax显示数学公式是基于文本的，而非图片。这意味着公式和页面上的文字一样是可以被搜索的。 MathJax允许页面作者使用TeX、LaTeX符号和 MathML 或者 AsciiMath 去书写公式。 MathJax甚至可以将Tex格式转化为MathML格式，使其可以被原生支持MathML格式的浏览器更多的渲染。转化为MathML格式后你可以复制粘贴它们到其他程序中。 2. 基本语法 2.1. 公式编辑 正文(inline)中的公式用 $...$ 定义。 例如： $ sum_{i=0}^N int_{a}^{b}g(t,i) text{d}t$ 显示为$ sum_{i=0}^N int_{a}^{b}g(t,i) text{d}t$ 单独显示公式用 $$...$$ 定义，此时公式居中并放大显示。 $$ sum_{i=0}^N int_{a}^{b}g(t,i) text{d}t$$ 显示为 $$ sum_{i=0}^N int_{a}^{b}g(t,i) text{d}t $$ 2.2. 分组 使用 {} 将具有相同等级的内容扩入其中，成组处理 例子： 10^{10} 呈现为：$10^{10}$，而 10^10 呈现为：$10^10$ 2.3. 公式中插入文字 语法： text{} 例子： text{插入文字} 呈现为：$ text{插入文字}$ 2.4. 空格 LaTeX语法本身会忽略空格的存在 小空格 : a b 呈现为 $a b$ 4格空格 : a quad b 呈现为$a quad b$ 6格空格： a qquad b 呈现为$a qquad b$ 2.5. 分段和对齐 分段符号  对齐符号 &amp; 例如： begin{aligned} f(x) &amp;= (x+y)^2 &amp;= x^2+2xy + y^2 end{aligned} 呈现为： $$ begin{aligned} f(x) &= (x+y)^2 &= x^2+2xy + y^2 end{aligned} $$ 关于公式对齐的详细设置方法，请见后面的“方程组”这一节。 2.6. 注释 　　百分号 % 后的内容为注释内容。 2.7. 转义字符 　　这些字符是LATEX 的保留字符： # $ % ^ &amp; _ { } ~  前面加反斜线输出保留字符： # % _ { } ~ &amp; $ 反斜线 比较特殊: $ backslash$ 3. 上下标 符号 命令 符号 命令 符号 命令 $x_i^2$ x_i^2 $x^{y^z}$ x^{y^z}  ${x^y}^z$ {x^y}^z $ bar{a}$ bar{a} $ hat{a}$ hat{a}  $ tilde{a}$ tilde{a} $ dot{a}$ dot{a} $ grave{a}$ grave{a}  $ acute{a}$ acute{a} $ overline{ overline{a}}$ overline{ overline{a}} $ overrightarrow{xy}$ overrightarrow{xy}  $ overleftarrow{xy}$ overleftarrow{xy} $ widehat{xy}$ widehat{xy} $ overline{xy}$ overline{xy}  $ underline{xy}$ underline{xy} 补充： 上括号：$ overbrace{1+2+ cdots+100}$，命令为 overbrace{1+2+ cdots+100} ； $ begin{matrix} 5050 overbrace{ 1+2+ cdots+100 } end{matrix}$，命令为 begin{matrix} 5050 overbrace{ 1+2+ cdots+100 } end{matrix} 。 下括号：$ underbrace{a+b+ cdots+z}$，命令为 underbrace{a+b+ cdots+z} ； $ begin{matrix} underbrace{ a+b+ cdots+z } 26 end{matrix}$，命令为 begin{matrix} underbrace{ a+b+ cdots+z } 26 end{matrix} 。 4. 括号 4.1. 常用括号 () 表示为：$()$  [] 表示为：$[]$  { } 表示为：$ { }$  | | 表示为：$ | |$  lceil rceil 表示为：$ lceil rceil$  lfloor rfloor 表示为：$ lfloor rfloor$ 4.2. 定界符 　　嵌套多个式子时，外层括号不会自动变大，公式整体显得很不协调，可通过在括号外加一个 left... right 进行大小的控制。  例如：  $ text{未加定界符：}( frac{x}{y}) text{加定界符:} left( frac{x}{y} right)$  加定界符的命令： left( frac{x}{y} right) 5. 公式格式 5.1. 字体 typewriter字体： mathtt{} blackboard bold字体： mathtt{} boldface字体： mathsf{} Roman字体： mathrm{} calligraphic字体： mathcal{} script字体： mathscr{} Fraktur字体： mathfrak{} 例如： $$ begin{array}{l} %左对齐设置 "typewriter" font:: mathtt{ABCDEF} "blackboard bold":: mathbb{ABCDEF} boldface: mathsf{ABCDEF} Roman font: mathrm{ABCDEF} "calligraphic" letters: mathcal{ABCDEFGH} script letters: mathscr{ABCDEFGH} "Fraktur" (old German style) letters: mathfrak{ABCDEFGH} end{array} $$ 呈现为： $$ begin{array}{l} %左对齐设置 "typewriter" font:: mathtt{ABCDEF} "blackboard bold":: mathbb{ABCDEF} boldface: mathsf{ABCDEF} Roman font: mathrm{ABCDEF} "calligraphic" letters: mathcal{ABCDEFGH} script letters: mathscr{ABCDEFGH} "Fraktur" (old German style) letters: mathfrak{ABCDEFGH} end{array} $$ 5.2. 尺寸 tiny{smallest} ： $ tiny{smallest}$  scriptsize{very small} ：$ scriptsize{very small}$  small{small} ： $ small{small}$  normalsize{normal} ： $ normalsize{normal}$  large{large} ： $ large{large}$  Large{Large} ： $ Large{Large}$  LARGE{LARGE} ： $ LARGE{LARGE}$  huge{huge} ： $ huge{huge}$  Huge{Huge} ： $ Huge{Huge}$  6. 数学表达式 6.1. 分式 基本语法： 方法1： frac ab 或 frac{a}{b} 表示$ frac ab$ 方法2： {a+1 over b+1 } 表示${a+1 over b+1 }$ 6.2. 向量 vec{A} 表示向量$ vec{A}$ 6.3. 矩阵和行列式 基本语法：起始标记 begin{matrix} ... end{matrix} 。 例如： $$ begin{matrix} 1&amp;0&amp;0 0&amp;1&amp;0 &amp;0&amp;1 end{matrix} $$ 呈现为： $$ begin{matrix} 1&0&0 0&1&0 0&0&1 end{matrix} $$ 矩阵边框： pmatrix : 小括号边框 bmatrix : 中括号边框 Bmatrix : 大括号边框 vmatrix : 单竖线边框 Vmatrix : 多竖线边框 在起始、结束标记处用上面的词替换 matrix 。例子： $$ begin{bmatrix} {a_{11}}&amp;{a_{12}}&amp;{ cdots}&amp;{a_{1n}} {a_{21}}&amp;{a_{22}}&amp;{ cdots}&amp;{a_{2n}} { vdots}&amp;{ vdots}&amp;{ ddots}&amp;{ vdots} {a_{m1}}&amp;{a_{m2}}&amp;{ cdots}&amp;{a_{mn}} end{bmatrix} $$ 呈现为： $$ begin{bmatrix} {a_{11}}&{a_{12}}&{ cdots}&{a_{1n}} {a_{21}}&{a_{22}}&{ cdots}&{a_{2n}} { vdots}&{ vdots}&{ ddots}&{ vdots} {a_{m1}}&{a_{m2}}&{ cdots}&{a_{mn}} end{bmatrix} $$ 矩阵嵌套的例子： $$ A= begin{pmatrix} begin{matrix} 1 &amp; 0 0 &amp; 1 end{matrix} &amp; text{ Large{0}} Large{0} &amp; begin{matrix} 1 &amp; 0 0 &amp; 1 end{matrix} end{pmatrix} $$ 呈现为： $$ A= begin{pmatrix} begin{matrix} 1 & 0 0 & 1 end{matrix} & Large{0} Large{0} & begin{matrix} 1 & 0 0 & 1 end{matrix} end{pmatrix} $$ 阵列 需要array环境：起始、结束处以 array 声明 对齐方式：在 array 后以 {} 逐行统一声明 左对齐： l ；居中： c ；右对齐： r 竖直线：在声明对齐方式时，插入|建立竖直线 插入水平线： hline 例如： $$ left( begin{array}{ccc|c} 1 &amp; 1 &amp; 1 &amp; 1 hline 1 &amp; 1 &amp; 1 &amp; 1 1 &amp; 1 &amp; 1 &amp; 1 end{array} right) $$ 呈现为： $$ left( begin{array}{ccc|c} 1 & 1 & 1 & 1 hline 1 & 1 & 1 & 1 1 & 1 & 1 & 1 end{array} right) $$ 6.4. 方程组 基本语法： 方法1：采用 begin{cases}… end{cases} 方法2：采用 begin{array}… end{array} 和 left {… right. 如果想把等号对齐，采用 begin{aligned}... end{aligned} 和 left {… right. 公式编号：采用 tag 。仅适用于方法1 例1（方法1）： $$ begin{cases} a_1x+b_1y+c_1z=d_1 a_2x+b_2y+c_2z=d_2 a_3x+b_3y+c_3z=d_3 tag{1.1} end{cases} $$ 呈现为： $$ begin{cases} a_1x+b_1y+c_1z=d_1 a_2x+b_2y+c_2z=d_2 a_3x+b_3y+c_3z=d_3 tag{1.1} end{cases} $$ 例2（方法2）： left { begin{array}{l} a_1x+b_1y+c_1z=d_1 a_2x+b_2y+c_2z=d_2 a_3x+b_3y+c_3z=d_3 end{array} right. $$ left { begin{array}{l} a_1x+b_1y+c_1z=d_1 a_2x+b_2y+c_2z=d_2 a_3x+b_3y+c_3z=d_3 end{array} right. $$ 例3（等号自动对齐）： $$ left { begin{aligned} a_1x+b_1y+c_1z &amp;= d_1+e_1 a_2x+b_2y &amp;= d_2 a_3x+b_3y+c_3z &amp;= d_3 end{aligned} right. $$ 呈现为： $$ left { begin{aligned} a_1x+b_1y+c_1z &= d_1+e_1 a_2x+b_2y &= d_2 a_3x+b_3y+c_3z &= d_3 end{aligned} right. $$ 例4（等号对齐，且等号两边式子左对齐）： $$ left { begin{array}{ll} a_1x+b_1y+c_1z &amp;=d_1+e_1 a_2x+b_2y &amp;=d_2 a_3x+b_3y+c_3z &amp;=d_3 end{array} right. $$ 呈现为： $$ left { begin{array}{ll} a_1x+b_1y+c_1z &=d_1+e_1 a_2x+b_2y &=d_2 a_3x+b_3y+c_3z &=d_3 end{array} right. $$ 6.5. 分段函数 基本语法： 方法1：采用 begin{cases}… end{cases} ，用  来换行，用 &amp; 来对齐。 方法2：采用采用 begin{array}… end{array} ， right. 表示省略右括号， left. 表示省略左括号 扩大行间距：可以用 [2ex] 代替  。注： ex 是指字母 x 的高度， [2ex] 就表示两倍的字母 x 的高度。 例1： $$f(n) = begin{cases} n/2, &amp; text{if $n$ is even} 3n+1, &amp; text{if $n$ is odd} end{cases}$$ 呈现为： $$f(n) = begin{cases} n/2, & text{if $n$ is even} 3n+1, & text{if $n$ is odd} end{cases}$$ 例2： $$ left. begin{array}{l} text{if $n$ is even:}&amp;n/2 text{if $n$ is odd:}&amp;3n+1 end{array} right } =f(n) $$ 呈现为： $$ left. begin{array}{l} text{if $n$ is even:}&n/2 text{if $n$ is odd:}&3n+1 end{array} right } =f(n) $$ 例3（扩大行间距）： $$ f(n) = begin{cases} frac{n}{2}, &amp; text{if $n$ is even} [2ex] 3n+1, &amp; text{if $n$ is odd} end{cases} $$ 呈现为： $$ f(n) = begin{cases} frac{n}{2}, & text{if $n$ is even} [2ex] 3n+1, & text{if $n$ is odd} end{cases} $$ 6.6. 排列组合式 　　组合数：$n choose m$或者$ binom{n}{m}$或者$C_n^m$ 7. 数学运算 7.1. 基本数学运算符 符号 命令 符号 命令 符号 命令 $+$ + $-$ - $/$ / $ div$ div $ cdot$ cdot $ times$ time $ ast$ * 或 ast $ pm$ pm $ mp$ mp $=$ = $ neq$ neq $ approx$ approx $ leq$ leq $ geq$ geq $ cong$ cong $ sim$ sim $ ll$ ll $ gg$ gg $ leftarrow$ leftarrow $ Leftarrow$ Leftarrow $ rightarrow$ rightarrow $ Rightarrow$ Rightarrow $ longleftarrow$ longleftarrow $ Longleftarrow$ Longleftarrow $ longrightarrow$ longrightarrow $ Longrightarrow$ Longrightarrow $ leftrightarrow$ leftrightarrow $ longleftrightarrow$ longleftrightarrow $ Leftrightarrow$ Leftrightarrow $ Longleftrightarrow$ Longleftrightarrow 7.2. 常用数学运算符 求和 　　符号：$ sum$，命令为： sum ； 符号：$ sum_{i=1}^n$，命令为： sum_{i=1}^n 求积 　　符号：$ prod$，命令为： prod ； 符号：$ prod_{i=1}^N$，命令为： prod_{i=1}^N 求极限 　　符号：$ lim_{x to infty}$ ，命令为： lim_{x to infty} 导数和微分 　　符号：$f"(x)$，命令为： f"(x) 或 f^ prime (x) ；  　　符号：$f""(x)$，命令为： f""(x) ；  　　符号：$ dot{f}(x)$，命令为： dot{f}(x) ；  　　符号：$ ddot{f}(x)$，命令为： ddot{f}(x) ；  　　符号：$ frac{ partial{y}}{ partial{x}}$，命令为： frac{ partial{y}}{ partial{x}} 积分 　　单积分符号：$ int_0^ infty{f(x)dx}$，命令为 int_0^ infty{f(x)dx} ；  　　双重积分符号：$ iint_{a}^{b}{f(x)} , dx ,dy$，命令为 iint_{a}^{b}{f(x)} , dx ,dy ；  　　三重积分符号：$ iiint_{a}^{b} {f(x)} , dx ,dy ,dz$，命令为 iiint_{a}^{b} {f(x)} , dx ,dy ,dz ；  　　闭合曲线、曲面积分符号：$ oint_{C} x^3 , dx + 4y^2 , dy$，命令为 oint_{C} x^3 , dx + 4y^2 , dy 7.3. 特殊数学运算符 符号 命令 符号 命令 $ infty$ infty $ partial$ partial $ cup$ cup $ cap$ cap $ subset$ subset $ supset$ subset $ subseteq$ subseteq $ supseteq$ subseteq $ in$ in $ notin$ notin $ varnothing$ varnothing $ forall$ forall $ exists$ exists $ supset$ subset $ Delta$ Delta $ nabla$ nabla 7.4. 常用数学函数 函数 符号 命令 根号 $ sqrt{x}, sqrt[a]{x}$ sqrt{x}， sqrt[a]{x} 对数 $ log_ax, ln x, lg x$ log_ax， ln x ， lg x e指数函数 $ exp(x)$ exp(x) 正弦函数 $ sin x$ sin x 余弦函数 $ cos 30^ circ$ cos 30^ circ 正切函数 $ tan x$  tan x 余切函数 $ cot x$  cot x 正割函数 $ sec x$  sec x 余割函数 $ csc x$  csc x 双曲正弦函数 $ sinh x$  sinh x 双曲余弦函数 $ cosh x$  cosh x 双曲正切函数 $ tanh x$  tanh x 双曲余切函数 $ coth x$  coth x 反正弦函数 $ arcsin x$  arcsin x 反余弦函数 $ arccos x$  arccos x 反正切函数 $ arctan x$  arctan x 取复数辐角 $ arg x$  arg x 求方阵的行列式 $ det A$  det A 求最小值 $ min A$  min A 求最大值 $ max A$  max A 弧度 $ deg$  deg 角度 $ circ$  circ 8. 希腊字母 字母 命令 字母 命令 $ alpha$ aplha $ beta$  beta $ gamma$  gamma  $ delta$  delta  $ epsilon$ epsilon $ zeta$ zeta $ eta$ eta $ theta$ theta $ phi$ phi $ psi$ psi $ omega$ omega $ lambda$ lambda $ mu$ mu $ nu$ nu $ xi$ xi $ omicron$ omicron $ pi$ pi $ rho$ rho $ sigma$ sigma $ tau$ tau $ upsilon$ upsilon $ iota$ iota $ chi$ chi $ kappa$ kappa 若需要大写希腊字母，将命令首字母大写即可； 若需要斜体希腊字母，将命令前加上 var 前缀即可。 9. 其它 9.1. 省略号 横省略号 : cdots 竖省略号 : vdots 斜省略号 : ddots 与文本底线对齐的省略号： ldots 例如： a ldots b : $a ldots b$ a cdots b : $a cdots b$ begin{pmatrix} a vdots b end{pmatrix} 呈现为： $$ begin{pmatrix} a vdots b end{pmatrix} $$ begin{pmatrix} a &amp; &amp; &amp; ddots&amp; &amp; &amp;b end{pmatrix} 呈现为： $$ begin{pmatrix} a & & & ddots& & &b end{pmatrix} $$ ',title : 'MathJax语法说明',flags : 0,children : []},{file:'./data/help_internal_doc_workmode.htm',name : 'help_internal_doc_workmode',body : '计算模式构建指南 概念 计算模式是仿真流程模式的抽象。通过定义计算模式，可以省去用户建立激励源、监视器、部分模型和后处理的工作。更为关键的在于计算模式可以针对领域特定问题定义参数集合，从而减少用户解读工程模型和后处理结果的工作量。 建模的层次 整个EastWave仿真建模体系分为三个层次： 仿真模型(Model) 负责细节的定义 负责基本仿真参数的定义 负责将用户变量表转换为一般元件参数 仿真模型的元件参数、结果的含义一般具有数学意义和物理意义而不具有工程学含义（即领域术语） 仿真模型在默认的计算模式和调度器下经过求解器运行得到原始的结果输出 物理级仿真 (Physical Simulation) 仿真原语 (Simulation Semantics) 计算模式(Workmode) 对仿真模型的修饰和提升 计算模式自身的基本参数和最终输出结果是领域术语 将计算模式自身的基本参数转化为仿真模型的参数，包括添加隐藏元件 具有操纵多次重复计算过程的能力 具有根据需要改变仿真模型中元件参数更新逻辑的能力 计算模式对仿真模型计算的原始输出数据进行进一步加工，得到具有工程学意义的结果 计算模式不应当修改用户变量表，用户变量表中定义的变量可以在计算模式用户参数中使用 工程级仿真 (Engineering Simulation) 领域原语 (Domain Semantics) 调度器(Dispatcher) 调度器是对计算模式任务计算过程的组织 调度器一般包括默认调度器（计算一次结束）、参数扫描调度器和参数寻优调度器三种，允许编写更为复杂的调度逻辑 调度器可以多层嵌套 调度器不能使用用户变量表的内容，但可以修改用户变量表的内容 调度器需要解决多次计算的结果综合的问题 智能级仿真 (Intelligent Simulation) 任务原语 (Task Semantics) 箭头图： Run Solver Model[2] --------------------------&gt; Simple/Multiple Results | Task Semantics | /| Modify User Vars /| | | | Lifting with a Dispatcher | Filter/Regroup by Dispatcher | | | Run Solver | Model[1] --------------------------&gt; Result interpreted by Workmode | Domain Semantics | /| Use User Vars /| | | | Decorate with a Workmode | Postprocess by workmode | | | Run Solver | Model[0] --------------------------&gt; Result interpreted by Math/Physics | Simulation Semantics | Use User Vars 运行原理 求解器读取一个工程文档后，按照下面的次序进行工作（注意并行时多节点的行为）： 读取用户变量表，进行解析求值 依次读取调度器堆栈的栈顶，根据调度器的内部逻辑对用户变量表进行修改（如查询某个指定的变量修改其数值） 处理完所有的调度器的操作后进入核心计算模式 [A] 主节点执行计算模式初始化函数 wmbase.init0() [B] 主节点更新 sddata.ndoc （如无则设定为0），执行计算模式 wmbase.nextp() 函数，如果返回为 true 则进入计算循环[C]，否则跳出计算循环[G]，并所有节点同步 sddata 变量表 [C] 每个节点执行 wmbase.update() 函数，将 wmuser 的参数转换到 wmdata 中 [D] 每个节点执行 wmbase.check() 函数，一般检测 wmdata 中的参数 [E] 每个节点执行求解计算过程 [F] 每个节点执行计算模式后处理 wmbase.postp() 函数 [G] 全部节点跳出循环（由主节点通知其他节点是否要跳出循环或是继续下一次计算） [H] 主节点执行 wmbase.fini0() 函数 执行当前调度器内部的后处理，判断是否要进行下一轮计算模式或者下一次的内部调度器计算计算，如果不需要则退出到外面一层调度器依次判断 结束全部计算过程 计算模式部分用伪代码表述： wmbase.init0(); while(wmbase.nextp()) { wmbase.update(); wmbase.check(); wmbase.process(); wmbase.postp(); } wmbase.fini0(); 参数更新逻辑 进入求解计算过程时，有一个参数解析过程（每个非从节点都会运行），见下表： table 1: 阶段说明 阶段(phase)  说明  param  更新参数  border  更新边界（类型）  freq  更新频率  model  加载模型  bbox  更新物体包围框  cbox  更新可见元件包围框  fbox  更新计算区域（第1次）  pml  更新吸收边界  meshpos  更新网格（即同时第二次更新fbox）  time  更新时间参数  solver  更新求解器参数  可用变量的说明 在计算模式的编写过程中用到的一些变量的说明： table 2: 计算模式脚本变量说明 td  文档参数、建模方法集合  config  配置信息  wmbase  计算模式通用过程与方法集合  wmuser  计算模式用户参数集合  wmdata  计算模式用户数据集合  result  计算模式生成的计算结果  sddata  并行节点之间的共享数据  dparam  模型文档参数，在前处理中可用  eparam  引擎参数，在后处理中可用  svdata  求解器数据集，用于跨调度器传送数据（如向上传送数据时将自动传入 sddata 中  计算模式参数定义规范 规格说明是对计算模式的参数集、参数约束情况以及部分运行逻辑的说明和解释（建议对复杂以及可能产生误解的一些问题予以说明），一般写在计算模式程序的最顶部。 wmuser 和 wmdata 传送数据时按照约定的规则可以减少重复代码的编写，并且有利于计算模式规格定义信息的突出。在 wmbase.definition() 函数中定义计算模式变量的名称和默认值，并且自动包含了默认类型信息。在 wmbase.transfer(ar) 和 wmbase.init0() 两个函数中采用简单的名称构造法，因此大部分普通计算模式不需要对这两个过程进行额外的编写工作。另一方面，计算模式的界面对话框会调用 wmbase.transfer(ar) 函数进行参数同步工作。具体的规则如下： 在构造 wmbase 时，使用 wmbase = wmutil.create_workmode_basic() 或者其他类似的初始化函数。 计算模式规格变量表 ：即在 wmbase.definition() 函数中返回一个变量表，建议使用 table { ... } 的方式表达，并且对齐代码，每一行一个参数，并且附加注释（如果有必要）。 wmbase.transfer(ar) 的默认行为是根据 计算模式规格变量表 根据嵌套的情况构建名字，例如参数 param1.freq ，在 wmuser 中的索引名称是 "param1.freq" ，因此引用方式为 wmuser["param1.freq"] 。 wmdata 中保存的是已经被求值的各个用户参数，根据用户参数计算出来的一些衍生参数（为了方便后续重复利用）。 wmbase.update(dp) 过程负责将 wmuser 中的原始用户参数转换为计算模式处理过程中的内部数据，因此为了方便表述，建议采用规整的写法，并且尽量和 计算模式规格变量表 中的变量保持对应关系；一些衍生参数的处理注意保持逻辑的清晰性，例如可以使用 switch-case 语句。 例子与解释 计算模式规格说明信息的参考格式： /* EastWave V7 RCS 计算模式 * 规格设计：戴炜锋 * 设计日期：2018/09/07 * 修改时期：----/--/-- * 模式名称：雷达散射截面计算模式（单站） * 备注信息：单站RCS计算（脉冲模式） * 帮助文档： * *************************************** * ... （略） */ 典型的计算模式规格定义如下： function wmbase.definition() { return table { freq : table { mode : 0; // 0: 单值，1: 线性步进，2: 均匀采样，3: 列表 value : "1.0"; min : "0.9"; max : "1.1"; count : "21"; step : "0.01"; }; angle : table { mode : 1; // 0: Theta扫描，1: Phi扫描 scsmode : 0; // 0: ISO，1: HCS，2: GCS theta : "90"; phi : "0:5:180"; }; misc : table { accuracy : "1.0e-3"; // 脉冲式计算的场收敛条件 customsignal : false; // 自定义高斯信号 gaussianfreq : "1.0"; // 高斯脉冲的中心频率 bandwidth : "0.2"; // 高斯脉冲的带宽 ff_distance : "1.0e+8"; // 远场距离，一般不影响计算结果，不在界面中体现 add_space_src : "0.25"; // 平面波距离BBOX的距离 add_space_mon : "0.25"; // 远场监视器距离平面波盒子的距离 add_space_cal : "0.25"; // 计算区域边界和远场监视器盒子的距离 }; }; } wmbase.update(dp) 函数中对原始参数求值的例子： dp.eval 的用法： dp.eval(param_name, typename) ，第一个参数表示参数的名称，第二个参数表示求值的类型，要求是强类型求值。 wmdata.angle = table { mode : dp.eval("angle.mode", "integer" ); scsmode : dp.eval("angle.scsmode", "integer" ); theta : dp.eval("angle.theta", "array_double"); phi : dp.eval("angle.phi", "array_double"); }; 补充说明 wmutil 是针对计算模式某些较为通用的需求提供的辅助工具集，通过 #import wmutil 的方式调用。 在 wmbase.hook0() 函数运行阶段中，如果在较早的阶段直接指定了后续某个阶段的属性变量表，则计算模式内部的机制会跳过内部更新机制而直接采用预设的数值。利用该方法可以减少重复性工作（例如提前设定 dparam.meshpos 可以避免进行非均匀网格划分）。 ',title : '计算模式',flags : 0,children : []},{file:'./data/help_internal_doc_wm.htm',name : 'help_internal_doc_wm',body : '1. 概述 1.1. Event 1.2. Plugin 1.3. ui库 2. ui库 2.1. ui.evt库 2.2. ui.res库 2.3. ui.window库 2.4. WndProperty的属性及方法 2.5. KMaker窗口控件布局生成器的属性及方法 2.6. WndModel窗口对象属性及方法 2.7. 示例代码 3. 技巧及进阶 3.1. props 3.2. toolbox 3.3. smartdata 3.4. wizard 1. 概述 窗口管理器，是一个通用的多文档编辑器管理器，类似MVC框架。抽像出Event和Plugin的概念， 对不同的功能进行组织，并映射到ewsl的ui库。 1.1. Event 窗口管理器，抽像出Event的概念，Event大概可分为以下几大类： EvtCommand 一般用于关联按扭、菜单或工具条等，在控件触发时，要触发这个关联的Event。 EvtProxy 一般用于关联用户可编辑控件，用于控件的状态的交互， 最其中的交互是transfer_data，可以通过EvtProxy把值传送到控件，也可以从控件传送到EvtProxy。 EvtGroup 组，用于代表一组Event，可以用EvtGroup来生成菜单和工具条等。 EvtOptionData，下拉框等控件选项定义。 WndModel 窗口对象。 Plugin 插件对象。  跟Event关联的内容，有EvtListener和Validator。 EvtListener用于监听Event，Validator用于绑定到控件，负责具体的控件和Event之间的交互。 在脚本中，一般不需要直接使用到这两方面的内容，而是通过Event间接与控件进行交互。 如果想要控件的状态变化时触动某个动作，可以往名称为 sync_handler 的Event中注册触发函数。 例子：在 time.policy 改变时，修改 time.dt_reference 控件的状态 local ec=...; // ec为WndModel关联的evtmgr，构造方式要看具体环境 local fn1=function(e) { local v=ec["time.policy"].value; ec["time.dt_reference"].set("FLAG_ENABLE",v==1); }; ec["sync_handler"].add(fn1,"time.policy");  1.2. Plugin Plugin是一种特殊的Event。 窗口管理器，按功能进行划分，抽象为不同的Plugin来实现。 不同的Plugin，可以动态注册到窗口管理器中，注册后即可以使用Plugin的功能。 比如，有菜单管理器Plugin，有工具条管理器Plugin，有历史打开文件Plugin等。 只要是功能独立，即使功能很小，一般也建议抽象成Plugin来实现。 在Plugin系统的基础上，我们抽象出编辑器Plugin，编辑器认为是在主Canvas中打开文件并处理的Plugin。 编辑器Plugin，目前包括： ewsl后处理交互编辑器 peditor模型文档编辑器 fieldviewer实时场观察器 texteditor文本文件编辑器 html浏览器 1.3. ui库 ui库，把窗口管理器中各方面的内容，基于ewsl扩展出相应的脚本接口， 达到使用ewsl来定义界面相关的对象及交互的目的，降低维护扩展的难度。 ui库内容： 名称 作用 ui.evt Event库 ui.res 界面资源库 ui.window 窗口库 ui库相关对象 名称 作用 WndModel 窗口对象  KMaker 窗口控件布局生成器 EvtManager Event管理器 WndProperty 窗口属性对象 DToolBox toolbox对象 2. ui库 2.1. ui.evt库 每个WndModel，都有一个自己的evtmgr，ui.evt是全局的Event管理器。 使用evtmgr时，可以通过Event的id来引用预定义的Event，比如 ui.evt["Open"] 或 model.evtmgr["event_id"] 。 窗口管理器，内置了很多Event，另外，用户也可以使用外置脚本来定义自己的Event， 或是修改已经定义好的Event。比如文件菜单，对应的Event为"File"，类型为EvtGroup， 可以通过修改"File"这个Event来修改"File"菜单。 具体可参考 ui/scripting/evt_manger.ewsl。 另外，也可以修改功能对应的快捷键等内容，修改后一般立即生效。 通过ewsl来定义Event(下面假设ec为对应的evtmgr) ec.wm_var 定义EvtProxy  ec.wm_cmd 定义EvtCommand  ec.gp_beg/ec.gp_end 定义EvtGroup或EvtOptionData等 ec.gp_new 跟 ec.gp_beg 功能类似，但会先清空原有的内容 定义EvtProxy时，数据会关联到evtmgr的数据集中 evtmgr.get_data 获取关联的数据集 evtmgr.set_data 设置关联的数据集（必须是table） 默认会关联到model.data local evtmgr=ui.evt; local data=table(); local olddata=evtmgr.set_data(data); evtmgr.wm_var("var.x","x","1"); evtmgr.set_data(olddata); data.x="..."; // model.transfer_data(+1); 可以把data.x传送到var.x关联的控件  通过ewsl，也可以直接调用这些Event， 比如要通过ewsl来触发打开这个动作，这个动作对应的Event的id为"Open"， 可以 ui.evt["Open"].cmd_execute() 这样来触发。 一般较具体的功能，在窗口管理器中，也可能是由某个预定义的事件来提供。 比如通用的对话框 Dialog.Msgs 弹出简单的消息窗口的功能 Dialog.File 弹出文件对话框 Dialog.Text 弹出文本对话框 local ec=...; //定义一个EvtGroup ec.gp_new("tb.Search"); ec.gp_add("Find"); ec.gp_add("Replace"); ec.gp_end(); //定义EvtProxy ec.wm_var("workmode.id","id",0); // 定义名称为`workmode.id`的EvtProxy，初始值为0，短名称为id，可以使用model.data.id访问。 ec.wm_var("workmode.figure","figure"); // 定义名称为```workmode.figure```的EvtProxy，初始值为nil，短名称为figure。 // 定义一个EvtCommand ec.wm_cmd("my_button").do_cmd_execute=function(param,model,evtmgr) { // model和evtmgr是创建这个Event时关联的WndModel和EvtManager // param.model是触发这个事件时对应的WndModel model.transfer_data(-1); ui.evt["Dialog.Msgs"].std_execute( table{ title: "message" content: "workmode.id is "..model.data.id; } ); local f=create_figure(model.data.id); model.data.figure=f; model.transfer_data(+1); };  2.2. ui.res库 用来定义和加载资源文件，比如图像等。工具图标等，都是通过这个库来定义， 系统会直接使用同名称的图标资源，对于没定义图标的情况，将使用默认图标。 同一个名称的资源，可以包括多个不同大小的图像资源，在需要使用图像资源时， 优先选择同样大小的图像，如果没有，则自动使用较大的图像进行缩放生成， 如果没有较大的，就使用小的进行放大，完全没有就使用默认图标。  具体用法比较简单，可以参考系统默认的资源配置脚本。注意，这是配置脚本， 可以利用脚本再加一些特殊的约定，动态加载资源。  系统默认的资源配置脚本： app:/scripting/ui/res_manager.ewsl ，可以修改这个文件来定制图标等。 2.3. ui.window库 这个库，目前只定义了一个函数，用来创建WndModel对象。 名称 作用 ui.window.create 创建窗口对象 ui.window.create函数，参数可以是窗口的创建函数，table、toolbox或文件名。 当参数是table或toolbox时，必须定义入口函数wnd_create。   2.4. WndProperty的属性及方法 名称 作用 sv 保存窗口属性对象 name 关联的Event名称 label 标签 flags 状态标识 nvalue 值(整数) svalue 值（字符串） align 水平对齐 valign 垂直对齐 hint 提示信息 另外：其他还有很多属性，不同的窗口定义， 需要不同的专有属性，通用属性， 在不同类型的窗口定义中， 也可能有不同的意义，具体见窗口类型的说明表。 2.5. KMaker窗口控件布局生成器的属性及方法 名称 作用 ld 载入窗口属性对象 win 定义生成窗口 end 完成窗口定义 add 添加窗口，相当于win(...).end() row 相当于 win("row",...) col 相当于 win("col",...) add_item 添加预定义内容 其中，win/end两个接口，必须匹配。 如果end函数可以带一个字符串作为参数， 这情况下，表示前面的内容为预定义内容， 后面可以使用add_item来添加预定内容。 另外，KMaker窗口生成器，继承了所有的窗口对象的属性和方法。 2.6. WndModel窗口对象属性及方法 名称 作用 maker 关联的KMaker对象 evtmgr 局部Event表 context 用户数据 data 默认关联的数据集 transfer_data 数据传输函数 show 显示窗口（非模式对话框） show_modal 显示窗口（模式对话框） end_modal 结束模式对话框 close 关闭窗口 2.7. 示例代码 表达式解释器的窗口代码 local t=table(); t.wnd_create=function(ctx) { local km=ctx.maker; km.ld(0).width(280).sv(1); km.ld(0).width( 96).sv(2); km.win("dialog" ,km.label(_hT("expr")).flags(km.IWND_NO_RESIZABLE|km.IWND_NO_CLOSE|km.IWND_AUTO_FIT).sprops("icon","Find")); km.win("col"); km.win("row"); km.add("textctrl" ,km.ld(1).name("expr.expression").height(120).flags(km.IWND_MULTILINE).hint(_hT("expression"))); km.add("textctrl" ,km.ld(1).name("expr.result").flags(km.IWND_READONLY).hint(_hT("result"))); km.end(); km.win("row"); km.add("button" ,km.ld(2).name(_kT("Ok#button"))); km.add("button" ,km.ld(2).name(_kT("Cancel#button"))); km.end(); km.end(); km.end(); }; return t;  搜索窗口的ewsl代码 local t=table(); t.wnd_create=function(ctx) { local km=ctx.maker; km.width(280).sv(1); km.width( 96).sv(2); km.win("col" ,km.ld(0).label(_hT("search_flags")).flags(km.IWND_EXPAND)); km.add("checkbox" ,km.ld(0).name("search.case").label(_hT("match case"))); km.add("checkbox" ,km.ld(0).name("search.word").label(_hT("match word"))); km.add("checkbox" ,km.ld(0).name("search.regexp").label(_hT("regexp"))); //km.add("checkbox" ,km.ld(0).name("search.posix").label(_hT("posix"))); km.end("flags"); km.win("dialog" ,km.label(_hT("find and replace")).flags(km.IWND_NO_RESIZABLE|km.IWND_NO_CLOSE|km.IWND_AUTO_FIT).sprops("icon","Find")); km.win("col"); km.win("row"); km.add("textctrl" ,km.ld(1).name("search.text_old").hint(_hT("find what?"))); km.add("textctrl" ,km.ld(1).name("search.text_new").hint(_hT("replace with?"))); km.add_item("flags"); km.end(); km.win("row"); km.add("button" ,km.ld(2).name("Find#button")); km.add("button" ,km.ld(2).name("Replace#button")); km.add("button" ,km.ld(2).name("ReplaceAll#button")); km.end(); km.end(); km.end(); }; return t;  例子：动态创建窗口，并立即弹出 ui.window.create(function(model) { local ec=model.evtmgr; // 这里定义关联的Event local km=model.maker; km.win("dialog",...); // 这里定义窗口内容 km.end(); }).show_modal();  3. 技巧及进阶 可以灵活应用所有的ewsl脚本技巧， 来简化窗口的定义，避免重复的内容。 目前已经定义出props库，来简化这个工作。 对于经常要使用的较类似的窗口布局和行为， 可抽象成窗口模板，目前已经抽象出toolbox， 并在toolbox的基础上扩展出了smartdata和wizard。 可以根据具体的需要，在toolbox的基础上扩展出具体的窗口模板。 现在来说，smartdata是参考旧框架的smartdata实现的，但是， smartdata可以有更多的形式，以后来说， 应该定义出多种具有不同针对性的smartdata。 3.1. props 在KMaker的基础上，扩展出一些较高级的接口， 用来简化窗口的定义，并对风格进行整体控制。 例子：使用props库来定义Cube的界面 property.createpage=function(ctx) { local km=props.bind(ctx); km.new_page("center_width",0); km.vec3("center"); km.vec3("width"); km.end_page("page0"); km.new_page("corner_corner",1); km.vec3("lo_corner"); km.vec3("hi_corner"); km.end_page("page1"); km.new_page("corner_width",2); km.vec3("lo_corner"); km.dataview("vector3_list"); km.end_page("page2"); km.new_book("book#cube"); km.add_item("page0"); km.add_item("page1"); km.add_item("page2"); km.end_book("book0"); km.new_container(); km.combo_book("cube_type","book#cube"); km.add_item("book0"); km.end_container(); };  3.2. toolbox toolbox，是一种轻量化的工具扩展， 可认为是一个独立的功能模块，类似微信或支付宝的小程序。  可以完全使用脚本来定义界面及交互逻辑 可以作为一个变量保存到变量表中，也可保存到文件中 定义时不需要界面 在界面上可以打开，打开后可以根据设定的逻辑进行交互操作 工具箱的交互操作中，可以动态调用绘图库绘图并展现在界面中，甚至可以构造另一个工具箱并打开 一个toolbox对象，可能关键到特定类型的窗口控件， 也可以通过 ui.window.create_by_toolbox 函数来创建WndModel对象。 在交互式后处理窗口中，可以通过触发。 toolbox的入口函数为成员函数 wnd_create ，默认实现： // toolbox的内部数据为context context.wnd_create=function(model) { this.evt_init(model); this.dlg_init(model); }; 这个实现中，抽象出了 evt_init 函数和 dlg_init 函数。 evt_init 函数用于构造这个toolbox用到的Event。 dlg_init 函数用于构造界面和布局。 3.3. smartdata smartdata是一种特殊的toolbox，继承所有toolbox的特点， 所有的内容，通过外置脚本文件 app:/scripting/data/helper/smartdata.ewsl实现， 定义了专有 evt_init 函数和 dlg_init 函数。 smartdata抽象出操作的概念，smartdata可认为是内部数据和多个操作的集合 smartdata可以有多种实现形式，目前参考旧版的界面和逻辑实现了一种smartdata toolbox.smartdata示例 #import toolbox; local tb=toolbox.new_smartdata(); tb.title="Smartdata#sample"; local op; op=tb.add_operation("figure1"); op.add_param("x").type("string").value("0:100").unit("mm"); op.add_param("y").type("string").value("x*2").label("f(x)").unit("mm"); op.add_param("title").type("string").value("figure"); op.add_param("xlabel").type("string").value("x"); op.add_param("ylabel").type("string").value("y"); op.add_param("type").type("integer").value(0).optdata(["plot","polar"]); op.do_execute=function(idata,pdata) { local x=eval2(pdata.x); local f=eval2("return function(x){"..pdata.y.." nreturn temp;}"); local y=eval2( """ #function(x,f) local y=zeros(x.length(),1); for(local i=0;i&lt;x.length();i++) y[i]=f(x[i]); return y; """,x,f); local g=fig.new_figure(); if(pdata.type==0) { fig.plot(x,y); } else { fig.polar(x,y); } fig.title(pdata.title); fig.xlabel(pdata.xlabel); fig.ylabel(pdata.ylabel); return g; }; op=tb.add_operation("figure2"); op.add_param("x").type("string").value("linspace(-1,1,100)"); op.add_param("y").type("string").value("linspace(-1,1,100)"); op.add_param("z").type("string").value("sin(x*3)*sin(y*5)").label("f(x,y)"); op.do_execute=function(idata,pdata) { local x=eval2(pdata.x); local y=eval2("#function(x) n"..pdata.y,x); local f=eval2("return function(x,y){"..pdata.z.." nreturn temp;}"); local z=eval2( """ #function(x,y,f) local z=zeros(x.length(),y.length()); for(local i=0;i&lt;x.length();i++) for(local j=0;j&lt;y.length();j++) z[i,j]=f(x[i],y[j]); return z; """,x,y,f); local g=fig.new_figure(); fig.imagesc(x,y,z); return g; }; return tb;  3.4. wizard wizard是一种特殊的toolbox，继承所有toolbox的特点， 所有的内容，通过外置脚本文件 app:/scripting/data/helper/wizard.ewsl实现， 定义了专有 evt_init 函数和 dlg_init 函数。 evt_init 用于定义专有的Event，比如btn.prev和btn.next， 用户需要定义自己的Event，使用 do_evt_init 函数来定义。 向导完成时，会自动调用 on_done 函数。 可重新定义这个函数，来实现专有的向导完成动作。 可以使用 new_page 来创建页面。page有以下函数和成员 page.evt_init 函数可以用来定义本页面的局部事件，一般不需要使用。 page.dlg_init 函数用来定义本页面的界面。 page.on_next 函数用来定义next的行为， 返回nil代表向导结束了， 返回具体的page则会转到具体的page， 抛出异常则认为参数有问题，留在原页面。 page.on_next 函数，默认行为为 return this.next page.next 和 page.children 成员，均为nil代表这个页面是最终页，有非空则不是。 默认实现下， page.next 即为下一页。 当next为nil但children不为空时，这个函数必须重新定义， 根据用户选择的参数在children数组中选择下一页。 另外，还有函数 add_page ，相当于创建一个page并添加到最后页。 对于某一页面要根据用户的参数来选择下一页的情况，比如选择计算模式后，跳到不同的下一页，一般这样实现。 // define workmode1 // define workmode2 // define workmode3 page.children=[workmode1,workmode2,workmode3]; page.on_next=function(){return children[model.data.workmode_id];} wizard示例1：toolbox.wizard #import toolbox; local tb=toolbox.new_wizard(); tb.do_evt_init=function(model) { local ec=model.evtmgr; ec.wm_var("myexpr.x","x","1"); ec.wm_var("myexpr.y","y","1"); ec.wm_var("myexpr.z","z","2"); }; local page1=tb.add_page("aa"); page1.dlg_init=function(model) { local km=model.maker; km.win("container",km.page(this.name).nvalue(this.index)); km.win("row"); km.add("label",km.label("input x")); km.add("expression",km.name("myexpr.x")); km.end(); km.end(); }; local page2=tb.add_page("bb"); page2.dlg_init=function(model) { local km=model.maker; km.win("container",km.page(this.name).nvalue(this.index)); km.win("row"); km.add("label",km.label("input y")); km.add("expression",km.name("myexpr.y")); km.end(); km.end(); }; page2.on_next=function(model) { model.data.z=string(eval2("("..model.data.x..")+("..model.data.y..")")); return this.next; }; local page3=tb.add_page("cc"); page3.dlg_init=function(model) { local km=model.maker; km.win("container",km.page(this.name).nvalue(this.index)); km.win("row"); km.add("label",km.label("calc x+y")); km.add("textctrl",km.name("myexpr.z")); km.end(); km.end(); }; tb.on_done=function(model) { logger.log_message("wizard done"); model.show(false); return true; }; return tb;  wizard示例2，根据用户的选择来决定下一页内容。 #import toolbox; local tb=toolbox.new_wizard(); tb.do_evt_init=function(model) { local ec=model.evtmgr; ec.gp_beg("workmode.type", "OptionData"); ec.gp_add("workmode1", 0); ec.gp_add("workmdoe2", 1); ec.gp_end(); ec.wm_var("workmode.id","id",0); }; local endpage=tb.new_page("aa"); endpage.dlg_init=function(model) { local km=model.maker; km.win("container",km.page(this.name).nvalue(this.index)); km.win("row"); km.add("label",km.label("this is endpage")); km.end(); km.end(); }; local workmode1=tb.new_page("aa"); workmode1.next=endpage; workmode1.dlg_init=function(model) { local km=model.maker; km.win("container",km.page(this.name).nvalue(this.index)); km.win("row"); km.add("label",km.label("this is workmode1")); km.end(); km.end(); }; local workmode2=tb.new_page("bb"); workmode2.next=endpage; workmode2.dlg_init=function(model) { local km=model.maker; km.win("container",km.page(this.name).nvalue(this.index)); km.win("row"); km.add("label",km.label("this is workmode2")); km.end(); km.end(); }; local start_page=tb.new_page("bb"); start_page.children=[workmode1,workmode2]; start_page.dlg_init=function(model) { local km=model.maker; km.win("container",km.page(this.name).nvalue(this.index)); km.win("row"); km.add("combo" ,km.name("workmode.id").flags(km.IWND_READONLY|km.IWND_EXPAND).optdata("workmode.type")); km.end(); km.end(); }; start_page.on_next=function(model) { return this.children[model.data.id]; }; tb.fpage=start_page; tb.on_done=function(model) { logger.log_message("wizard done"); model.show(false); return true; }; return tb;  ',title : '窗口管理器',flags : 0,children : []},{file:'./data/help_internal_doc_base.htm',name : 'help_internal_doc_base',body : '1. 翻译词条 2. 属性内部名称 1. 翻译词条 词条，分为核心词汇和后缀，使用 # 分隔，可以带多个后缀。 比如 Name ，核心词汇为 Name ，不带后缀。 比如 Name#cube ，核心词汇为 Name ，后缀为 cube 。 核心词汇被翻译，但核心词汇一样但不带后缀的词条未被翻译的情况下，会直接使用核心词汇的翻译。 比如 Name 翻译为 名称 ，但 Name#cube 未被翻译，这情况下，会直接使用 名称 这个翻译。 词条命名规则  核心词汇，关键字母使用大写，多个关键字之间，使用 _ 连接。 后缀，全部使用小写字母 2. 属性内部名称 属性内部类型，目前可以有 boolean ， integer ， double ， string 和 array_variant 。 另外，还有复合类型，比如 三个string之类的。 属性内部名称命名规则 属性名称，采用 前缀+核心词汇+后缀的方式命名，后缀可以不使用。 前缀由类型决定 核心词汇命名规则。。。 后缀一般不使用，在属性名称被多个类共同使用又要区分的情况下，可考虑使用 ',title : '基础库说明',flags : 0,children : []},{file:'./data/help_internal_doc_nameconvention.htm',name : 'help_internal_doc_nameconvention',body : '1. EastWave文档参数命名规范 1.1. 前缀命名规范 1.2. 文档参数主体名称规范 1. EastWave文档参数命名规范 EastWave工程文件中定义各种元件使用规范的名称体系。该体系考虑以下几个因素： 使用标准英文单词 小写英文字母开头，其他合法字符为数字、下划线，此外，使用井号符号 # 限定名词的概念域 前缀表明属性的数据类型（并且基本上指明了空间类型） 前缀和主体名称之间用下划线区分 1.1. 前缀命名规范 简单参数的前缀规则如下： 说明：简单参数指的是一个参数对应一个控件的情况。 前缀  参数类型  C++类型  控件类型  英文助记  int  整型  32bit有符号整数  单行文本框  integer  opt  选项型  32bit有符号整数  下拉列表（不可编辑）  option  flg  标志型  Bit标志(32bit)  钩选框  flags  dbl  浮点型  双精度浮点  单行文本框  double  sld  浮点型  双精度浮点  滑动条  slide  str  字符串  字符串  单行文本框  string  sym  引用符号/元件  符号引用  下拉列表（可编辑）  symbol  exp  表达式  字符串  单行表达式控件  expression  fln  文件名  字符串  文件控件  filename  clr  颜色  DColor  颜色按钮  color  txt  多行文本  字符串  多行文本框  text  nfo  多行文本  字符串  多行文本框（只读）  infomation  举例如下： int_number 表示叫做 number 的文档参数，其类型为整型，控件对应为一个普通的单行文本框。 opt_type 表示叫做 type 的文档参数，类型为整型，并且作为选项（Option），因此控件为一个下拉框。 dbl_intensity 表示叫做 intensity 的文档参数，类型为浮点数（双精度），控件为一个下拉框。 sld_precision 表示叫做 precision 的文档参数，类型为浮点数（双精度），控件为一个滑动条，其上下限需要额外参数来定义。 复杂参数的前缀规则如下： 说明：复杂参数指的是一个参数对应多于一个控件的情况（多个控件之间可能存在关联） 前缀  参数类型  C++类型  控件类型  备注  a{n}n  整数向量  整数向量  n个单行文本框  后缀编号序列为：{a,b,c,...}  a{n}d  浮点向量  浮点向量  n个单行文本框  a{n}s  字符串向量  字符串向量  n个单行文本框  a{n}e  字符串向量  字符串向量  n个表达式控件  x{n}n  整数向量  整数向量  n个单行文本框  后缀编号序列为：{x,y,z,w}  x{n}d  浮点向量  浮点向量  n个单行文本框  x{n}s  字符串向量  字符串向量  n个单行文本框  x{n}e  字符串向量  字符串向量  n个表达式控件  u{n}n  整数向量  整数向量  n个单行文本框  后缀编号序列为：{u,v,n}  u{n}d  浮点向量  浮点向量  n个单行文本框  u{n}s  字符串向量  字符串向量  n个单行文本框  u{n}e  字符串向量  字符串向量  n个表达式控件  mvm  多变量矩阵  Variable的数组  $m times n$的矩阵形式  用户定义子项名称与类型  举例如下： x3e_position 表示叫做 position 的文档参数，其控件为三个表达式控件，标签（Label）名分别为： position.x 、 position.y 和 position.z 。 u3e_direction 表示叫做 direction 的文档参数，其控件为三个表达式控件，标签名分别为： direction.u 、 direction.v 和 direction.n 。 mvm_transform_list 表示叫做 transform_list 的文档参数，其控件为一个表格控件，标签由构造控件的其他参数控制。 mvm_children 表示叫做 children 的文档参数（子节点），其控件是个表格控件。 1.2. 文档参数主体名称规范 普通文档参数的主体名称（不考虑 # 扩充的引导翻译的部分），去掉前缀标识后一般按下列规则命名： 一般由小写字母和数字、下划线组成；除特殊缩写外均尽量使用小写字母； 字母开头； 数字表示编号时，用下划线和中心词分开； 过长的词语一般写成缩写（专业术语使用大写字母）； 一般使用名词中心语，而不要使用形容词作中心语（尽管英文是允许的，此时应指明对象集合）； 一般采用定语+中心词结构，下划线最后一个是中心词，不要使用of来倒装； 一般文档参数不推荐采用谓语+宾语结构，可以采用名词化形式的方式或者将动作谓语修改为形容词定义，而宾语改为中心语来命名； 允许动词谓语+状语结构，此时动词是中心词，如果参数的中心词动词相同，建议提升为一个控件组，将状语作为独立的参数命名，此时控件组的名称则为中心词（名词化或者显示表述为状态、策略等名词概念）； 例子： 一个物体长方体（Cuboid）的长宽高，一般可以命名为： exp_length#Cuboid#Shape 、 exp_width#Cuboid#Shape 、 exp_heigth#Cuboid#Shape 一个物体长方体（Cuboid）用对角线上的两个顶点坐标定义，可以命名为： u3e_corner_1#Cuboid#Shape 、 u3e_corner_2#Cuboid#Shape 一个记录器盒子，用长宽高定义，一般可以命名为： exp_length#Box#Monitor 、 exp_width#Box#Monitor 、 exp_height#Box#Monitor 文档参数常见英文名词和中文翻译对照 英文  中文  备注  几何建模  length  长度  一般为x/u方向  width  宽度  一般为y/v方向  height  高度  一般为z/n方向  depth  深度   radius  半径   diameter  直径   generatrix  母线  生成线的意思，也扩展到母点、母面  directrix  准线   focus  焦点   focal_length  焦距   eccentricity  偏心率   void_ratio  体空心比  适合于能将体空心率换算为建模参数的模型  hollow_rate  体空心率  仅适合于大量空隙存在时的空隙体积和总体积之比 length_ratio  线度比   convexity  凸起点   concavity  凹下点   arc  弧线   arc_length  弧长   control_point  控制点  用于样条参数方程中的参考点  key_point  关键点  用于定义物体时的参考点  area  面积   area_ratio  面积比   volume  体积   volume_ratio  体积比   start_point  起点   end_point  终点  注意区别于端点endpoint  tangent_line  切线   tangent_plane  切平面   slope  斜率   major_axis  主轴/长轴   minor_axis  短轴   asymptote  渐近线   thickness  厚度   curvature  曲率   curvature_radius 曲率半径   CL  特征长度  Character Length的简称  angle  角度  一般为角度制  center  中心   corner  角点   entity  实体  广义实体概念  solid  几何实体  等价于geometric entity  position  位置   point  点   triangle  三角形   quadrangle  四边形   rectangle  长方形   polygon  多边形   vertex  顶点  线段、多边形或者多面体的顶点  refpoint  参考点  reference point的简称  refvertex  参考顶点  reference vertex的简称  refcenter  参考中心  reference center的简称  line  线  可以理解为straight line的简称  segment  段（分段）   combined_line  组合线   edge  边缘/边线   boundary  边界   boundary_line  边界线   boundary_surface 边界面   endpoint  端点  注意区别于end_point  sweeping_line  扫描线   sweeping_surface 扫描面   sweeping_angle  扫描角   loop  回路   line_loop  线回路   surface_loop  面回路   extrusion  拉伸   lofting  放样   path  路径  特指构建折线段的多点路径  guide  导引  类似路径，但顶点处可以定义复杂行为  chamfer  倒角  AutoCAD习惯  fillet  圆角  shell  壳   scale  缩放   mirror  镜像   reflection  中心反射   translation  平移   rotation  旋转   deformation  形变   torsion  扭曲（扭转）  curve  曲线  可以理解为curved line的简称  spline  样条曲线   bspline  B样条   cubic_spline  三次样条   NURBS  NURBS  非均匀有理B样条曲面  interpolation  插值   plane  平面   surface  表面  可以作为curved surface的简称  combined_surface 组合面   regular_surface  正规曲面   cuboid  长方体   sphere  球体   spheroid  旋转椭球   paraboloid  抛物面   hyperboloid  双曲面   ellipsoid  椭球面   array  阵列   wcs  工作坐标系  Working Coordinate System的简称  lcs  局部坐标系  Local Coordinate System的简称  激励源、记录器等  farfield  远场   nearfield  近场   kdir  波矢方向  一般约定为方向单位向量  orientation  朝向  一般用于定义特征面法向  cartesian_cs  笛卡尔坐标系  cylindrical_cs  柱坐标   spherical_cs  球坐标   distance  距离   radial_dist  径向距离   azimuth  方位角   altitude  俯仰角   elevation  高度角   longitude  经度   latitude  纬度   zenith  天顶   zenith_point  天顶点   zenith_angle  天顶角   ISO_z  ISO柱坐标$z$  ISO_rho  ISO柱坐标$ rho$   ISO_radial  ISO球坐标$r$  ISO_theta  ISO球坐标$ theta$   ISO_phi  ISO球坐标、柱坐标$ phi$   MATH_rho  Math球坐标$ rho$   MATH_theta  Math球坐标$ theta$  Math的角度规则与ISO相反，Matlab采用此规则  MATH_phi  Math球坐标$ phi$  GCS_radial  GCS球坐标$r$  地理坐标系的径向距离  GCS_theta  GCS球坐标$ theta$  即高度角/纬度，[-90, +90]  GCS_phi  GCS球坐标$ phi$  即精度（方位角），[-180, +180] HCS_radial  同GCS_radial  地平坐标系，相对于观测者  HCS_theta  同GCS_theta  俯仰角  HCS_phi  同GCS_phi  方位角  signal  信号   intensity  强度   power  功率   energy  能量   energy_density  能量密度   magnitude  幅度  幅度、强度、量  amplitude  振动幅度   phase  相位  文档相位一般用角度制  phase_rad  弧度相位  弧度制的相位  region  区域   active_region  有源区   passive_region  无源区   wire  连接线   displacement  位移   current  电流   mag_current  磁流  magnetic current的简写  e_field  电场  $E$  h_field  磁场  $H$  d_field  电位移  $D$  b_field  磁感应强度  $B$  je_field  电流密度  $j_e$  jm_field  磁流密度  $j_m$  excitation  激励  建议用于analyzer定义  source  激励源/馈源   monitor  监视器  旧称记录器  probe  探针  即点监视器  source_array  馈源阵列   analyzer  分析器   transient  瞬态   modal  模态  modal analysis 即单频激励分析  driven  驱动   eigenmode  本征模式   cycle  循环   reference  引用   symbol  符号/元件   background  背景   setup  设置   policy  策略   spread  展宽  用于定义频谱、参数分布宽度  timespan  时间宽度  用于定义时域信号宽度  rising_edge  上升沿  t_rising 上升沿时间  falling_edge  下降沿  t_falling 下降沿时间  holding  持续  t_holding 持续时间  distribute_width 分布宽度  用于定义空间分布的宽度  aperture_width  口径宽度  用于定义口径形状，一般对应x/u  aperture_length  口径长度  用于定义口径形状，一般对应y/v  aperture_depth  口径深度  用于定义口径形状，一般对应z/n  line_width  线宽   aperture_field  口径场   field_source  场源   spacial_function 空间函数   time_function  时间函数   terminal  终端   port  端口   mode  模式  注意和modal区分  network  网络   程序功能  template  模板   workmode  计算模式  一般称计算模式，有时可称工作模式  script  脚本   program  程序   code  代码   compiler  编译器   solver  求解器   engine  引擎   block  分块   thread  线程   thread_num  线程数   param  参数  parameter的简写  config  配置  configuration的简写  hacc  硬件加速  hardware acceleration的简写  denorm  denormal  denormal功能  dt  $ delta t$  时间步  dt_ratio  $ delta t/ delta t_ text{ref}$ 实际时间步/参考时间步  dt_ref  $ delta t_ text{ref}$  参考时间步  dx  $ delta x$  空间网格大小  start  启动   remote_start  远程启动   local_start  本地启动   run_solver  运行求解器   settings  设置  区别于setup设置，一般settings针对求解器/界面 solver_settings  求解器设置   gui_settings  界面设置   web_server  WEB服务器   web_client  WEB客户端   help  帮助  广义的帮助，可用于针对功能的帮助信息  document  文档  特指工程文档文件  documentation  文档  区别于工程文档document  manual  手册   tutorial  入门   sample  案例   library  库   module  模块   address  地址  一般指网络地址  path  路径  包括相对路径和绝对路径、网络路径、虚拟路径  directory  文件夹   link  链接  指向文件或者文件夹的链接，默认符号链接  alias  别名   filter  过滤器   workspace  工作空间   folder  文件夹  特指workspace里的虚拟folder  project  工程   solution  解决方案   shell  系统命令行   processor  处理器   core  核心   后处理  result  计算结果   report  报告   log  日志   external_file  外部文件   internal_file  内部文件  将文件嵌入工程后形成内部文件  table  数据表   figure  绘图   atlas  图册  figure构成的集合  image  图像   curve  曲线   spline  样条   bspline  B样条   stepline  阶梯线   dataview  数据视图   datamgr  数据管理器   datasheet  数据表  参照Excel的sheet概念  legend  图例   axis  坐标轴   margin  画布边缘  很多时候指边距  title  标题   xlabel  X标签   ylabel  Y标签   zlabel  Z标签   colormap  颜色映射图   colorbar  颜色柱   contour  等值（线）  也可以是等值面  contour_line  等值线   contour_surface  等值面   column  列   row  行   location  定位位置  (x,y)或者(x,y,z)  datatip  数据提示   dataitem  数据项   plot  曲线图   plot3d  3D曲线图   surf  曲面图   polar  极坐标图   polar3d  球坐标图   subplot  子图   canvas  画布   series  序列   scatter_plot  散点图   scatter3d_plot  3D散点图   ARE  自回归外推  Auto-Regression extrapolation的简写  DFT  离散傅立叶变换   DCT  离散余弦变换   FFT  快速傅里叶变换  Fast-Fourier Transform的简写  FFT2D  2D快速傅里叶变换   FFT3D  3D快速傅里叶变换   IFFT  快速逆傅里叶变换   IFFT2D  2D快速逆傅里叶变换  TD_signal  时域信号  time-domain signal的简写  FD_signal  频域信号  frequency-domain signal的简写  ',title : '命名规范',flags : 0,children : []},{file:'./data/help_internal_doc_mathlib.htm',name : 'help_internal_doc_mathlib',body : '1. 新版软件函数使用说明 1.1. 数组求最大值：max() 1.2. 数组求最小值：min() 1.3. 数组求和：sum() 1.4. 数组求平均值：mean() 1.5. 数组元素查找函数：find_index( ) 1.6. 线性调频z变换：czt( ) 1.7. 生成均匀分布随机数randu() 1.8. 生成标准正态分布随机数randn() 1.9. 生成复数版本的标准正态分布随机数randn_cpx() 1.10. 生成单个随机数rand_int()和rand_double() 1.11. 快速傅立叶变换fft()、fft2()和fft3() 1.12. 逆傅立叶变换ifft()、ifft2()和ifft3() 1.13. 将零频分量平移到频谱中心：fftshift()及其逆变换：ifftshift() 1.14. 转置运算：transp() 1.15. 重排数组维度permute() 1.16. 卷积运算conv() 1.17. 计算两个序列的相关系数xcorr() 1.18. 基于高斯核函数的数据概率密度估计ksdensity() 1.19. 基于高斯核函数的曲线平滑处理ker_smooth() 1. 新版软件函数使用说明 1.1. 数组求最大值：max() 函数说明： max函数支持数组和动态数组求最大值，数组元素类型可以是整型和浮点型，但不能是复数类型。函数的返回值是数组中值最大的元素。用法：max(A)或math.max(A)。  用法举例： &gt;&gt; a = [1,2;3,4]; &gt;&gt; max(a) results: 4 1.2. 数组求最小值：min() 函数说明： min函数支持数组和动态数组求最小值，数组元素类型可以是整型和浮点型，但不能是复数类型。函数的返回值是数组中值最小的元素。用法：min(A)或math.min(A)。  用法举例： &gt;&gt; a = [1,2;3,4]; &gt;&gt; min(a) results: 1 1.3. 数组求和：sum() 函数说明： sum函数支持数组和动态数组求和，数组元素类型可以是整型、浮点型、复数类型。函数的返回值是数组中所有元素的和。用法：sum(A)或math.sum(A)。  用法举例： &gt;&gt; a = [2,2i;4,5i]; &gt;&gt; sum(a) results: 6+7i 1.4. 数组求平均值：mean() 函数说明： mean函数支持数组和动态数组求平均值，数组元素类型可以是整型、浮点型和复数类型。当数组有复数类型的元素时，返回值为复数类型，否则返回值类型为双精度浮点类型。 用法：  求数组A所有元素的均值： mean(A) 或 math.mean(A) ；  数组A按列求均值： mean(A,0) ;  数组A按行求均值： mean(A,1) 。  用法举例： &gt;&gt; A = [1,2;3+4i,5]; &gt;&gt; mean(A); &gt;&gt; mean(A,0); &gt;&gt; mean(A,1); 代码运行结果分别是： results: 2.75+1i results: 2+2i 3.5+0i results: 1.5+0i 4+2i  1.5. 数组元素查找函数：find_index( ) 函数说明： find_index（A,x）求解数组A中值为x的元素的索引值。该函数在求解索引值的过程中，若数组为多维数组，函数将其转换为一维数组，返回值为一维整型数组，数组的每个元素依次对应为值为x的元素的索引值（即一维数组的下标值）。用法： find_index(A,x) 或 math.find_index(A,x) 。  用法举例： &gt;&gt; A = [1,2;4,1]; &gt;&gt; find_index(A,1) results: 0 3  1.6. 线性调频z变换：czt( ) 函数说明： czt函数通过z变换计算特定频段信号的频谱，通常采用czt函数细化关心频段内的信号频谱。用法： czt（signal,num,freq_bet,freq_end） ，其中函数参数的物理意义： signal： 　待变换的信号 num: 　　　关心频段的细化点数 freq_beg: 　 关心频段的起始频率 freq_end: 　 关心频段的终止频率 用法举例： &gt;&gt; fs = 1000; &gt;&gt; f = linspace(-fs/2,fs/2,1000); &gt;&gt; x = sin(2*pi*f/fs); &gt;&gt; f1 = 100; &gt;&gt; f2 = 150; &gt;&gt; ff = czt(x,1024,f1,f2); &gt;&gt; fi = fig.new_figure(); &gt;&gt; xl = linspace(100,150,1024); &gt;&gt; fig.plot(xl,abs(ff)) 结果图： image 1: czt 频谱细化处理图 1.7. 生成均匀分布随机数randu() 函数说明： R = rand.randu(m,n,k) 返回 $m times n times k$ 维在(0,1)范围内满足均匀分布的随机数。用法： rand.randu(m,n,k) ，参数$m,n,k$都必须是值大于0的整数，其中$n$和$k$可省略。  用法举例： >> A = rand.randu(3) 代码运行结果： 0.718098 0.085263 0.771667 >> B = rand.randu(2,3) 代码运行结果： 0.670029 0.990824 0.752741 0.0496988 0.0274534 0.33829 1.8. 生成标准正态分布随机数randn() 函数说明： R = rand.randn(m,n,k) 返回 $m times n times k$ 维满足标准正态分布（均值为0，标准差为1）的随机数。用法： rand.randn(m,n,k) ，参数$m,n,k$都必须是值大于0的整数，其中$n$和$k$可省略。 用法举例： &gt;&gt; rand.randn(2,2) results: 0.764215 -2.20585 -0.495294 -1.48313 1.9. 生成复数版本的标准正态分布随机数randn_cpx() 函数说明： R = rand.randn_cpx(m,n,k) 返回 $m times n times k$ 维的随机复数，该复数的实部和虚部均满足标准正态分布。用法： rand.randn_cpx(m,n,k) ，参数$m,n,k$都必须是值大于0的整数，其中$n$和$k$可省略。  用法举例： &gt;&gt; rand.randn_cpx(2,2) results: 0.759837-1.01945i -0.928163+0.13555i 0.939386-0.298229i -1.37728+0.0870167i 1.10. 生成单个随机数rand_int()和rand_double() 函数说明： rand.rand_int() ： 生成随机整型数；  rand.rand_double() : 生成(0,1)区间内的随机浮点数；  用法举例： &gt;&gt; rand.rand_int() results: 3530171493 &gt;&gt; rand.rand_double() results: 0.461303 1.11. 快速傅立叶变换fft()、fft2()和fft3() 函数说明： fft(A) 用快速傅立叶变换计算序列A的离散傅立叶变换; fft2(A) 计算二维数组A的离散傅立叶变换； fft3(A) 计算三维数组A的离散傅立叶变换。用法： fft(A) 或 math.fft(A) ， fft2(A) 或 math.fft2(A) ， fft3(A) 或 math.fft3(A) 。  用法举例: &gt;&gt; N = 1000; &gt;&gt; t = linspace(0,40,N); &gt;&gt; fs = 1.0/(t[1]-t[0]); &gt;&gt; f = linspace(-fs/2,fs/2,N); &gt;&gt; y = zeros(1,N); &gt;&gt; A = 1.0; &gt;&gt; K = 0.2; &gt;&gt; f0 = 0.1; &gt;&gt; tt = math.mod(t,10); //调频周期：10s &gt;&gt; y = A*sin(2*pi*(f0+K*tt/2).*tt); &gt;&gt; fig1 = fig.new_figure(); &gt;&gt; fig.plot(t,y); &gt;&gt; fig.title("线性调频连续波信号"); &gt;&gt; fig.xlabel("Time[s]"); &gt;&gt; fig.ylabel("Amplitude[V]"); &gt;&gt; yy = fft(y)/N; &gt;&gt; yy = fftshift(yy); &gt;&gt; fig2 = fig.new_figure(); &gt;&gt; fig.plot(f,abs(yy)); &gt;&gt; fig.title("频域信号"); &gt;&gt; fig.xlabel("Frequency[Hz]"); &gt;&gt; fig.ylabel(Amplitude[V]); 结果图： 图2 线性调频连续波信号 图3 线性调频连续波信号频谱 二维傅立叶变换例子：  &gt;&gt; a = [1,2+1i,3.2;4i,3.0,5]; &gt;&gt; b = fft2(a); results: 14.2+5i -4.73397+6.27128i -6.46603+0.728719i -1.8-3i 3.26603-5.19282i 1.5 1.12. 逆傅立叶变换ifft()、ifft2()和ifft3() 函数说明： ifft(A) 用快速傅立叶变换计算序列A的离散逆傅立叶变换; ifft2(A) 计算二维数组A的离散逆傅立叶变换； ifft3(A) 计算三维数组A的离散逆傅立叶变换。用法： ifft(A) 或 math.ifft(A) ， ifft2(A) 或 math.ifft2(A) ， ifft3(A) 或 math.ifft3(A) 。  用法举例： &gt;&gt; a = [1,2+1i,3.2;4i,3.0,5]; &gt;&gt; ifft2(a) results: 2.36667+0.833333i -1.07767+0.121453i -0.788996+1.04521i -0.3-0.5i 0.255662-0.63453i 0.544338-0.86547i  1.13. 将零频分量平移到频谱中心：fftshift()及其逆变换：ifftshift() 函数说明： fftshift(A) 将零频分量平移到数组中心，重新排新数据A； ifftshift(A) 将进行过零频平移的数据A重新排列回原始变换输出的样子。  用法举例： &gt;&gt; a = [1,2,3,4,5]; &gt;&gt; b = fftshift(a) results: 4+0i 5+0i 1+0i 2+0i 3+0i &gt;&gt; ifftshift(b) results: 1+0i 2+0i 3+0i 4+0i 5+0i &gt;&gt; ifftshift(a) results: 3+0i 4+0i 5+0i 1+0i 2+0i &gt;&gt; c = [1,2,3;4,5,6;7,8,9] 1 2 3 4 5 6 7 8 9 &gt;&gt; fftshift(c) 9+0i 7+0i 8+0i 3+0i 1+0i 2+0i 6+0i 4+0i 5+0i &gt;&gt; ifftshift(c) 5+0i 6+0i 4+0i 8+0i 9+0i 7+0i 2+0i 3+0i 1+0i 1.14. 转置运算：transp() 函数说明： transp(A) 将矩阵A的行和列互换得到新的矩阵。用法： transp(A) 或 math.tranps(A) 。  用法举例： &gt;&gt; a = [1,2,3;4,5,6] results: 1 2 3 4 5 6 &gt;&gt; transp(a) results: 1 4 2 5 3 6 1.15. 重排数组维度permute() 函数说明： permute(A,[m,n,k,…]) 将数组A的第m+1维和第1维互换，第n+1维和第2维互换，第k+1维与第3维互换，依次最多互换6个维度，得到新的数组。注意这里m和n都要加1的原因是c++语言的数组下标是从0开始的。permute函数是transp函数在高维数组转置上的推广。用法： permute(A,[m,n,k,…]) 或 math.permute(A,[m,n,k,…]) ，转置参数向量 [m,n,k,…] 长度大于等于2。  用法举例： &gt;&gt; a = [1,2,3;4,5,6] results: 1 2 3 4 5 6 &gt;&gt; permute(a,[1,0]) results: 1 4 2 5 3 6 1.16. 卷积运算conv() 函数说明： 卷积是一种数学运算，它涉及到积分或级数运算，是数字信号处理中最基础、最重要的概念。两个时间信号$f(n)$和$g(n)$的卷积定义为： $$ f(n)* g(n) = int_{- infty}^ infty f( tau)g(n- tau)d tau $$ 其离散的定义为： $$ f(n) ast g(n)= sum_{ tau=- infty}^ infty f( tau)g(n- tau) $$ 时间序列的卷积的一个通俗的例子是多项式乘法，如 $a(x) = 1+2x+x^2, b(x) = x+3x^2$，两多项式的系数分别表示为  $a(n) = [1,2,1]$  $b(n) = [0,1,3]$  多项式的乘法:  $$ begin{aligned} c(x) &= a(x) cdot b(x) &= (x^2+2x+1) cdot (3x^2+x) &= x+5x^2+7x^3+3x^4 end{aligned} $$ $c[x]$的系数向量$c[n]=[0,1,5,7,3]$，而$a(n)$与$b(n)$的卷积： $$ begin{aligned} a(n)*b(n) &= [1,2,1]*[0,1,3] = [0,1,5,7,3] &=c(n) end{aligned} $$ 函数用法：  向量a与b的卷积： conv(a,b) 或 math.conv(a,b) ；二维数组a与b的卷积： conv2(a,b) 或 math.conv2(a,b) 。  用法举例： &gt;&gt; a = [1,2,1]; &gt;&gt; b = [0,1,3]; &gt;&gt; conv(a,b) results: 0 1 5 7 3 1.17. 计算两个序列的相关系数xcorr() 函数说明： 信号X和信号Y的相关系数公式： $$ rho = frac{Cov(X,Y)}{ sigma_X sigma_Y} $$ 即信号$X$和信号$Y$的协方差除以$X$的标准差和$Y$的标准差。它反映了两个信号变化时是同向还是反向，如果同向变化就为正，反向变化就为负，两信号的相关性（协同性）越强，相关系数的绝对值越大，反之越小，如果完全不相关，则相关系数的值为0。  函数用法： 向量X和向量Y的相关系数： math.xcorr(X,Y) 。  用法举例： &gt;&gt; a = [1,2,3]; &gt;&gt; b = [0,1,3]; &gt;&gt; math.xcorr(a,b); results: 3 7 11 3 0 1.18. 基于高斯核函数的数据概率密度估计ksdensity() 函数说明： 核密度估计（Kernel density estimation），是一种用于估计概率密度函数的非参数方法，$x_1,x_2, ldots,x_n$为独立同分布的$n$个样本点，设其概率密度函数为$f$，核密度估计公式为： $$ hat{f}_h(x)= frac{1}{n} sum_{i=1}^{n} K_h(x-x_i)= frac{1}{nh} sum_{i=1}^{n} K left( frac{x-x_i}{h} right) $$ $K(.)$为核函数，$h>0$为平滑参数，称为带宽或核宽。 ksdensity() 函数采用的核为高斯核。 函数用法： 一维信号A的概率密度为 math.ksdensity(A) 。  用法举例： &gt;&gt; s = rand.randn(1,1000); &gt;&gt; y = math.ksdensity(s); &gt;&gt; f = fig.new_figure(); &gt;&gt; fig.plot(1:100,y); 结果图： 图4 正态分布信号高斯核概率密度估计 1.19. 基于高斯核函数的曲线平滑处理ker_smooth() 函数说明： 核、窗、掩模滤波是数字图像空间滤波的基本方法，平滑滤波是空间滤波的应用之一，曲线平滑处理相当于“一维图像”的平滑滤波。 基于高斯核函数的曲线平滑的处理过程是固定原数据曲线，将高斯核函数的峰值位置对齐到第一个数据点并相乘，其它的数据点与对应的高斯核函数的点数据相乘，最后加和并除以高斯核的和得到第一个数据的处理后的新数据。依次处理第2个数据点、第3个数据点、……、最后一个数据点。数学表达式为： $$ hat{f}(x)= frac{ sum_{i=1}^n K(x_i-x;h)y_i}{ sum_{i=1}^n K(x_i-x;h)}$$ 函数用法： math.ker_smooth(x,y,h) ，其中x为待平滑曲线数据的x坐标，y为待平滑曲线数据的y坐标，h为高斯核核宽，根据平滑效果手动设置。  用法举例： &gt;&gt; local x = linspace(1,2*pi,200); &gt;&gt; local data = cos(x) + exp(1./x); &gt;&gt; f1 = fig.new_figure(); &gt;&gt; fig.plot(x,data); &gt;&gt; local y = data + rand.randu(200); &gt;&gt; f2 = fig.new_figure(); &gt;&gt; fig.plot(x,y); &gt;&gt; local h = 0.2; //可调参数 &gt;&gt; local xs = linspace(min(x)-3*h,max(x)+3*h,100); &gt;&gt; local s = math.ker_smooth(x,y,h); &gt;&gt; f3 = fig.new_figure(); &gt;&gt; fig.plot(xs,s);  结果图： 图5 平滑处理前的曲线 图6 平滑处理后的曲线 ',title : 'mathlib',flags : 0,children : []},{file:'./data/help_internal_doc_test.htm',name : 'help_internal_doc_test',body : 'EastWave V7 测试说明 本文档用于内部功能测试。 目录 用户界面 几何结构 激励源 监视器 端口 计算模式 导线 材料 共形 集总端口 其他 关于测试说明文档的说明 测试说明分成下列几部分： 测试内容简要说明和直接相关的帮助页面 测试要点和测试项，指出相关的测试案例（只需要页面内链接即可） 测试案例及案例的简要说明 其他补充内容，如引用有关的章节信息 测试说明的其他注意事项： 测试的项目覆盖功能的主要运行逻辑和分支 测试的预期结果需要写清楚 测试案例的原始文件，放在 ew7/web/help/files/internal_files 中，区别于普通帮助中携带的内部文件 测试案例中附带外部模型文件的，放在 ew7/web/help/files/internal_files/model 中，建模时使用相对路径 测试案例中附带的其他外部文件的，放在 ew7/web/help/files/internal_files/data 中，建模时使用相对路径  文件链接代码示例： [link]("javascript:ewdoc.open_editor("internal_files/test.ewp2")","测试文档") 效果：(使用 EastWave 7 内嵌浏览器打开) 测试文档 系统测试用例命名规范 系统测试用例命名规则为： 软件名-v版本号-功能模块名称-测试子项目名称-ID.后缀名 软件名、版本号、功能模块名、子项目名称等中间断词采用下划线 版本号参考： 7_0_0_build_20190114 这样的形式，现阶段不必区分 build 版本号，所以只需要写成 ...-v7_0_0-... 即可 文件夹组织形式：测试类型/软件名_版本号（仅大版本）/功能模块名/子项目名/ 内部测试案例放置文件夹： internal_files/test/ 系统测试 internal_files/test/systest/ 单元测试（部分工程文件） internal_files/test/unittest/ 集成测试 internal_files/test/inttest/ 每个子项目增加一个changelog.txt文件，主要用来在测试周期结束前后编写案例内容的变化情况，简要说明案例的变化情况（只需要说明增加、修改案例的主要原因，如果是来自测试系统，应填写有关的测试报告链接），该文件采用简单文本格式和追加方式编写，不得对过去内容进行修改。如果需要归档，则备份并且用备份时间重命名changelog-20190101.txt，保留在原路径下。 本文档不定期对说明内容进行修订 命名名称参考下表： 测试类型 类型  说明  备注  systest  系统测试   unittest  单元测试   inttest  集成测试  （暂无）  系统测试案例命名规范 功能模块 说明 备注 workmode 计算模式 source  馈源  monitor  监视器  geometry 几何结构 gui  图形界面 port  端口  wire  导线  注意： 大部分单元测试放在代码其他地方，但是要求运行整体工程文件的单元测试项目参考案例也放在这里方便管理 结果文件原则上不上传，但是非常重要的参考数据在剪裁不必要的信息后可以以 .ewd 文件形式保存上传，一般是经过严格确认后的充分精确的结果，用于对比 internal_files/model 文件夹保存的是公共模型，局部的模型放在子项目文件夹下的 model 文件下， data 文件夹同理 ',title : '测试说明',flags : 0,children : [{file:'./data/help_internal_doc_test_UI.htm',name : 'help_internal_doc_test_UI',body : '用户界面（测试说明） 用户界面测试主要包括： 各功能的有效性与正确性。 不同窗口（界面）切换操作时的正确性。 界面遇到极端输入的情况下，是否具有恢复性，不至于崩溃。 测试目标 菜单栏 功能的正确性。 工具栏 功能的正确性。 模型树窗口 各节点右键菜单功能的完善性以及正确性。 新建元件 属性窗口的正确性。 界面布局 的合理性。 测试方法 基本测试 运行 菜单栏 、 工具栏 各个功能，测试功能有效性。 运行 模型树窗口 各节点右键菜单功能，测试功能有效性。 界面布局 合理性，界面布局是否符合行业标准。 功能点测试 尝试各种复杂性界面交互操作，测试正确性。  例： 材料库 中打开 拟合材料界面 拟合生成新材料，再通过 材料库 导入 当前工程文档 。 尝试在 新建元件 界面输入各种 合理与不合理 的数值，测试界面会作出何种逻辑判断。 多工程文档 同时操作情况，界面逻辑的正确性。 相关文档 用户界面 案例 测试 菜单栏 &gt; 模型编辑器 &gt; 检测所有物体封闭性 功能 测试 工具栏 &gt; 导出所有模型 功能 测试 模型树窗口 右键菜单 复制 功能 ',title : '用户界面（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Geometry.htm',name : 'help_internal_doc_test_Geometry',body : '几何结构（测试说明） 几何结构测试主要包括： 几何结构的正确性； 复杂建模工具的正确性与运行效率。 测试目标 几何体构造方式的 合理性 。 几何体构造的 正确性 。 几何体是否存在 自交 问题。 几何体的 封闭性 。 几何体在界面与求解器的行为是否具有 一致性 。 测试方法 基本测试 观察 几何体构造界面 ，检测构造方式合理性。 尝试各种 合理与不合理数值 作为输入，测试几何体的正确性。 测试观察几何体是否存在 自交 问题。 仿真测试几何体在界面的行为是否与求解器一致。 功能点测试 测试几何体 封闭性检测 功能，检测几何体的封闭性。 测试 导出 功能，检测几何体能否正确导出 STL 格式。 测试 导入 功能，检测工程文档能否正确导入 STL 格式模型。 重点测试 天线罩 阵列 垂直拉伸体 多层物体 旋转体 强制网格面 相关文档 几何元件 基础几何元件 元件分类 元件名称 元件说明 基础几何元件 长方体 长方体可用于生成最简单的基本几何体。包括长方体面板、立方体小块等。 圆柱体 圆柱体可用于生成截面为正圆或椭圆的实心或空心的柱形几何体。 球体 球体可用于生成具有厚度的完整球体或椭圆体。 几何球体 几何球体可用于生成基于正二十多面体制作的球体。 圆锥体 圆锥体可用于生成圆形圆锥体。 环体 圆环体可用于生成一个具有圆形截面的环。 扩展几何元件 元件分类 元件名称 元件说明 扩展几何元件 实心旋转体 实心旋转体可用于生成基于外形线旋转一周形成的对称几何体。 空心旋转体 空心旋转体可用于生成基于给定表面旋转一定角度形成的几何体。 参数扫描体 参数扫描体可用于生成基于给定平面和变换矩阵参数构造的几何体。 垂直拉伸体 垂直拉伸体支持对给定的平面进行垂直拉伸建模。可用于构造棱柱等几何体。 导入CAD模型 导入CAD模型支持从外部导入常见CAD格式模型。 强制网格面 强制网格可在所指定的关键网格位置强制生成网格体或网格面或网格线，并加密周围网格。 多层物体 多层物体支持对给定的表面按照特定方向生长多层材料的建模。 天线罩 EastWave V7 根据常用天线罩形线预定义了内置天线罩模型，用户使用时只需输入模型所对应的外形线参数。 阵列 阵列用于设计基于某种元件，按照指定的空间排布生成的阵列结构或阵列激励源。 案例 普通球体案例 阵列案例  注： 阵列功能构建细导线网 ',title : '几何结构（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Source.htm',name : 'help_internal_doc_test_Source',body : '激励源（测试说明） 激励源的测试内容包括： 测试用户参数设置的有效性 设定后对仿真的影响是否符合预期 设置位置、大小超出边界的测试 测试输出结果输出的符合性 界面显示 指示信息与用户设置、计算是否吻合 信息缺失问题 测试各种计算条件下的健壮性 单线程测试 并行测试 其他求解器参数设置下的运行情况 微引擎参数 网格参数的影响 测试激励源如下： 激励源元件 名称  说明  偶极子   场源  参数较多，注意测试完整性  平面波  注意杂项参数的测试，平面波的后向初射与数值色散修正有关  重点测试： 场源的朝向、坐标系、辐射角的相关性问题 补充说明： 测试激励源时注意信号问题，一般考虑3种典型信号 余弦波（直接激发时建议相位设为 90 或者 270 使得打出的是正弦信号 上升沿信号，会减少由于初始信号跃变导致的高频噪声 高斯脉冲（按时间设置和按频率设置两种） 测试案例： 偶极子辐射远场案例 自定义RCS测试文档（平面波+远场监视器） 场源薄介质板透射案例 ',title : '激励源（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Monitor.htm',name : 'help_internal_doc_test_Monitor',body : '监视器（测试说明） 监视器的测试内容包括： 测试用户参数设置的有效性 设定后对仿真的影响是否符合预期 设置位置、大小超出边界的测试 测试输出结果输出的符合性 是否需要改进输出结果 是否需要改进输出形式 测试智能数据 智能数据的参数意义正确性（与绘图是否对应） 切换智能数据参数再重新生成结果时是否有存在问题 界面显示 指示信息与用户设置、计算是否吻合 信息缺失问题 测试各种计算条件下的健壮性 单线程测试 并行测试 其他求解器参数设置下的运行情况 微引擎参数 网格参数的影响 测试监视器如下： 名称  说明  远场监视器（频域）  智能数据  远场监视器（时域）  智能数据  场点监视器（时域）   区域场监视器（频域）   重点测试： 监视器结果的一致性 如远场不同参数设置，方向相同情况下对应分量基本相等 结果项的缺失 智能数据 并行测试 测试案例： 远场监视器（频域） 远场监视器（频域） ',title : '监视器（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Port.htm',name : 'help_internal_doc_test_Port',body : '监视器（测试说明） ',title : '端口（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Workmode.htm',name : 'help_internal_doc_test_Workmode',body : '计算模式（测试说明） 目录 透反率计算模式 RCS计算模式 天线计算模式 成像计算模式 天线罩计算模式 ',title : '计算模式（测试说明）',flags : 0,children : [{file:'./data/help_internal_doc_test_Workmode_Transmission.htm',name : 'help_internal_doc_test_Workmode_Transmission',body : '自动透反率计算模式（测试说明） 自动透反率计算模式介绍参考此 链接 。 测试目标 测试自动透反率的计算精度 测试方法 运行标准案例，改变变量表中 deltaY 值，计算其为0、0.2e-3、0.5e-3、 1e-3时的反射率R； 计算不同 deltaY 下反射率R的 变化值 是否与 deltaY 满足线性关系； 标准案例 测试文档 ',title : '透反率计算模式（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Workmode_RCS.htm',name : 'help_internal_doc_test_Workmode_RCS',body : 'RCS 计算模式（测试说明） 测试目标： 单站 RCS （扫频扫角） 用户参数相应的正确性 计算逻辑正确性 结果正确性 双站 RCS （扫频扫角） 用户参数相应的正确性 计算逻辑正确性 结果正确性 测试方法： 基本测试 运行标准案例 （单站 RCS 及 双站 RCS） 修改标准案例中关键用户参数后另存为新的案例 功能点测试 用户界面相关 尝试输入各种合理与不合理数值 页面切换测试 文档修改后保存再载入的测试 运行测试（计算逻辑正确性） 计算结果的原则性分析 计算结果与旧版本的对比（注意配置的一致性） 结果智能数据的测试 智能数据控件参数的输入方式是否合理 绘图结果显示是否有问题 测试注意： 界面方面 设置 页面 频率设置模式：四种模式的输入参数不同，详细说明见 RCS 计算模式详细说明。 发射角 扫角模式 ：可以进行测试，“$ theta$-$ phi$ 扫描” 模式暂时无效。 接受角 开启双站模式 ：勾选此选项后进行双站 RCS 测试。下面三个勾选框（ 启用频域远场监视器 、 延迟计算远场结果 、 启用时域远场监视器 ）暂时无效，无需测试。 双站角度设置：可以添加多个记录条目，其中 扫描模式 也是仅支持 “$ theta$ 扫描” 及 “$ phi$ 扫描” 模式，“$ theta$-$ phi$ 扫描” 模式暂时无效。 杂项 页面 激励源设置 及 监视器设置 功能均可测试， 高级设置 （ 精度 、 延拓空间 ）暂时无效，无需测试。 注意 所有涉及选择 角度扫描模式 的，设置的扫描模式和具体设置的角度要一致，（$ theta$ 角度和 $ phi$ 角度均为单值时，扫描模式不限） 单站RCS案例： 单站RCS 双站RCS案例： 双站RCS ',title : 'RCS计算模式（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Workmode_Antenna.htm',name : 'help_internal_doc_test_Workmode_Antenna',body : '天线计算模式（测试说明） 测试目标： 远场参数（方向性、增益、辐射强度） 用户参数相应的正确性 计算逻辑正确性 结果正确性 端口参数（S参数、端口阻抗） 用户参数相应的正确性 计算逻辑正确性 结果正确性 测试方法： 基本测试 运行标准案例 修改标准案例中关键用户参数后另存为新的案例 功能点测试 用户界面相关 尝试输入各种合理与不合理数值 页面切换测试 文档修改后保存再载入的测试 运行测试（计算逻辑正确性） 计算结果的原则性分析 计算结果与旧版本的对比（注意配置的一致性） 结果智能数据的测试 智能数据控件参数的输入方式是否合理 绘图结果显示是否有问题 测试注意： 界面方面 设置 页面 频率设置模式 ：四种模式的输入参数不同，详细说明见天线计算模式详细说明。 天线端口 ： 引用 设置用来添加用户已经创建的 馈源 元件。 功率 、 强度 、 相位 、 延迟 这四个参数用于修改激励源的相对应参数，目前暂时无效，无需测试。 天线远场 ：用于设置多项记录条目，内部创建的监视器为频域远场记录器。扫描模式中 $ theta$-$ phi$ 扫描暂时无效，仅支持 $ theta$ 扫描及 $ phi$ 扫描。 启用 ：目前默认仅计算S11参数， 计算S11 参数及 计算S12 参数暂时无效。 杂项 页面 信号设置 及 监视器区域 功能均可测试， 功率记录框模式 设置中， 自动 参数为默认Bbox大小； 用户自定义 用于自定义修改功率记录框区域，目前无效。 预计算3D方向图 ：勾选后内部创建三维$ theta$-$ phi$监视器条目，用于查看三维方向图。 智能数据方面（分为两个智能数据结果（1、方向图及场图；2、端口特性（S参数、端口阻抗、端口信息））） 方向图智能数据： category 选项为选择计算参数（方向性、增益、辐射强度、辐射功率）。 ffar 选项为选择记录条目。 频率 可以添加频率点（和之前设置的频率点必须一致） 距离 可以修改远场的距离。 分量 选项用于选择分量（etotal、etheta、ephi） 量化方式 选项中 Linear 为原值， dB 为 10log10()。 绘图类型 选项中 plot 为绘制直角坐标图， polar 为绘制极坐标图， 3D 选项用与绘制三维方向图，目前仅能绘制计算模式内部创建的那个监视器的记录条目的3D方向图。 Theta 及 Phi 起说明作用，不能修改，是跟随用于选择的 记录项 变化的。 端口智能数据 power : 频域远场记录下的不同定义方式下的频率参数。 Impendence :端口阻抗。 S parameter : S 参数 port signal ：馈源端口的原始信息（时域及频域） 另外测试端口特性参数（S参数、端口阻抗）时，端口网格的剖分应该作为测试条件。 案例： 偶极子天线 ',title : '天线计算模式（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Workmode_Imaging.htm',name : 'help_internal_doc_test_Workmode_Imaging',body : '成像计算模式（测试说明） 概述 主要测试内容为： 子模式包括HRRP（目标一维距离成像）和ISAR(目标二维雷达成像) 前处理界面功能测试 后处理数据挂载完整性和合理性测试 后处理图像显示正确性测试  前处理界面功能测试 前处理界面测试主要测试界面按钮、可选框、参数设置是否起作用。 HRRP子模式界面功能测试 HRRP子模式界面如下：   图1 HRRP模式界面  重点测试：成像模式可选框（HRRP,ISAR），频率，角度（$ theta$,$ phi$），极化，距离分辨率，距离像范围参数设置和窗函数可选框设置是否起作用。  通过仿真结果可查看以上设置是否起作用。HRRP仿真结果数据结构如下：   图2 HRRP仿真结果数据结构  basicData.frequency_center为界面上设置的频率；  basicData.theta 为界面上设置的$ theta$角；  basicData.phi 为界面上设置的$ phi$角；  imageData.rangeResolution为界面上设置的距离分辨率；  imageData.rangeSize为界面上设置的距离像范围；  radarImage.ThetaPolar为回波垂直极化雷达图像；  radarImage.ThetaPolar为回波水平极化雷达图像；  详细的仿真参数请查看dparam节点数据。   注： 雷达信号类型目前仅实现了高斯信号 球坐标系模式目前仅支持ISO HRRP仿真时界面上的方位分辨率和方位像方位不起作用 杂项参数设置暂不测试 ISAR子模式界面功能测试 ISAR子模式界面如下：   图3 ISAR模式界面  重点测试：成像模式可选框（HRRP,ISAR），频率，角度（$ theta$,$ phi$），极化，距离分辨率，方位分辨率，距离像范围，方位像范围参数设置和窗函数可选框设置是否起作用。  测试参考仿真结果数据。HRRP仿真结果数据结构如下：   图4 HRRP仿真结果数据结构  basicData.frequency_center为界面上设置的频率；  basicData.theta 为界面上设置的$ theta$角；  basicData.phi_center 为界面上设置的$ phi$角；  imageData.rangeResolution为界面上设置的距离分辨率；  imageData.rangeSize为界面上设置的距离像范围； imageData.crangeResolution为界面上设置的距离分辨率；  imageData.crangeSize为界面上设置的距离像范围； radarImage.ThetaPolar为回波垂直极化雷达图像；  radarImage.ThetaPolar为回波水平极化雷达图像； 详细的仿真参数请查看dparam节点数据。   注： 雷达信号类型目前仅实现了高斯信号 球坐标系模式目前仅支持ISO 杂项参数设置暂不测试 后处理数据挂载完整性和合理性测试 如图2和图4所示，仿真数据种类繁多，dparam节点下的数据为仿真文档参数，eparam节点下的数据为仿真引擎参数。与雷达成像模式直接相关的数据挂载在basicData和imageData节点下，basicData记录了与雷达参数相关的频率（中心频率、扫描频率、频率带宽）、频点个数、角度（$ theta$角、中心方位角、扫描方位角、方位角带宽）、角点个数；  imageData记录了与图像参数相关的雷达图像数据（垂直极化电场和水平极化电场）、图像分辨率（距离分辨率和方位分辨率）、图像尺寸（距离像范围和方位像范围）。  后处理测试需要从工程上和逻辑上判断后处理basicData和imageData数据的完整性和合理性，并提出建议和方案。  radarImage节点下的数据为仿真结果图： radarImage.ThetaPolar为回波垂直极化雷达图像；  radarImage.ThetaPolar为回波水平极化雷达图像；  后处理图像显示正确性测试 根据仿真的雷达图像以及仿真物理模型判断仿真结果的正确性，依据如下：  测试物体的位置正确性 距离向上物体的绝对位置 距离向上物体的相对位置 方位向上物体的绝对位置 方位向上物体的相对位置 测试图像上散射强度的物理意义正确性  测试仿真图像与界面设置参数的对应性 标准案例 测试文档 ',title : '成像计算模式（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Workmode_Radome.htm',name : 'help_internal_doc_test_Workmode_Radome',body : '天线罩计算模式（测试说明） 测试目标： 透波率 用户参数相应的正确性 计算逻辑正确性 结果正确性 瞄准线误差 用户参数相应的正确性 计算逻辑正确性 结果正确性 测试方法： 基本测试 运行标准案例 修改标准案例中关键用户参数后另存为新的案例 功能点测试 用户界面相关 尝试输入各种合理与不合理数值 页面切换测试 文档修改后保存再载入的测试 运行测试（计算逻辑正确性） 计算结果的原则性分析 计算结果与旧版本的对比（注意配置的一致性） 结果智能数据的测试 智能数据控件参数的输入方式是否合理 绘图结果显示是否有问题 案例： 测试文档 ',title : '天线罩计算模式（测试说明）',flags : 0,children : []}]},{file:'./data/help_internal_doc_test_Wire.htm',name : 'help_internal_doc_test_Wire',body : '导线（测试说明） 导线介绍参考此 链接 。 条件控制 测试案例必须保证集总端口方向为xyz之一，即使模型经历了复杂旋转操作。 测试目标 测试导线离散化模型是否合理 对比导线与细PEC圆柱的计算精度差别； 测试方法 运行标准案例 细导线模型 ，改变变量表中旋转角度 jd 、平移距离 len ,观察细导线 离散化结果是否合理、计算时场值是否为0； 在旋转角度 jd=0 时，比较标准案例 细PEC圆柱 和 细导线模型 计算结果 差异是否随细PEC圆柱半径r_w减小而接近； 测试案例 细PEC圆柱 细导线模型 ',title : '导线（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Material.htm',name : 'help_internal_doc_test_Material',body : '材料（测试说明） ',title : '材料（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Conformal.htm',name : 'help_internal_doc_test_Conformal',body : '共形（测试说明） 共形技术较为复杂，会修改FDTD的迭代形式，错误的实现极易出现计算的稳定性问题，导致计算结果发散; 即使计算结果未发散，也会出现计算结果精度不高的问题。因此共形测试的主要目的是检测新版共形在各种模型和设置下 的 稳定性 、 准确性 。共形策略介绍参考此 链接 。 条件控制 进行精度对比时，可选用FEM、MoM、快速多级子算法软件结果作为标准解（前提是保证以达到网格收敛）， 而在同FDTD算法类软件进行结果精度对比时除了计算模型相同以外必须保证： 网格尺寸、网格数目相同 计算物理时间相同 网格为非均匀网格时： 尽可能保证网格尺寸和数目接近 计算物理时间严格相同  测试目标 普通材料、PEC材料共形稳定性、准确性 SC策略（结构必须含PEC或PMC） 模型在开启SC后时间步长的增加情况 SC策略开启前后的精度对比 测试方法 基本测试 分别运行标准案例，测试计算过程的稳定性、计算结果的精度 改变标准案例中的网格设置（如设置为非均匀网格）进行测试 高精度测试 标准案例为自动透反率模式，需要与至少一款同类FDTD软件进行精度对比，推荐FDTD Solutions；需要一款FEM类软件结果作为标准对比，推荐CST 更高精度的测试可采用RCS模式的结果与其它非结构网格算法软件（如FEKO、HFSS）结果进行对比  极端测试  测试用户在极端或异常输入下的稳定性，减小标准案例中各方向网格（传播方向必须大于8），测试求解器是否能运行 标准案例 普通材料共形 测试文档 PEC共形 测试文档 普通材料、PEC混合共形 测试文档 SC策略 纯PEC共形SC策略 测试文档1 普通材料、PEC混合共形SC策略 测试文档2  ',title : '共形（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_LumpedPort.htm',name : 'help_internal_doc_test_LumpedPort',body : '集总端口（测试说明） 集总端口介绍参考此 链接 。 条件控制 测试案例必须保证集总端口方向为xyz之一，即使模型经历了复杂旋转操作； 集总端口（偶极子天线）测试案例中必须保持偶极子天线的半径不大于1个网格 ； 测试目标 定性测试集总端口在方向被旋转到非坐标轴方向时的基本逻辑是否正确； 定量测试集总端口方向为坐标轴方向时的输出精度； 测试方法 基本测试 分别运行标准案例，改变标准案例参数中平移长度 len 变量，测试在各种情况下  集总端口是否能正常馈出； 改变标准案例中的网格设置（如设置为非均匀网格）进行测试 高精度测试 保证各种坐标变换后，集总端口方向为xyz方向之一，结果需要与其它软件进行对比； 用集总端口（偶极子天线）案例测试集总端口的输出精度； 利用集总端口RCL测试案例测试RCL电路在CL非零情况时各种馈电方式下的输出结果精度； 标准案例 集总端口元件测试案例 测试文档 集总端口（偶极子天线）测试案例 测试文档 集总端口RCL测试案例 测试文档  ',title : '集总端口（测试说明）',flags : 0,children : []},{file:'./data/help_internal_doc_test_Others.htm',name : 'help_internal_doc_test_Others',body : 'empty page ',title : '其他',flags : 0,children : []}]}]}]};