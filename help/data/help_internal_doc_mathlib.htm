<div class="markdown-body"><p>
	<ul>
		<li>
			<a href="#help_internal_doc_mathlib.header_1">1. 新版软件函数使用说明
			</a>
			<ul>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_1">1.1. 数组求最大值：max()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_2">1.2. 数组求最小值：min()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_3">1.3. 数组求和：sum()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_4">1.4. 数组求平均值：mean()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_5">1.5. 数组元素查找函数：find_index( )
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_6">1.6. 线性调频z变换：czt( )
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_7">1.7. 生成均匀分布随机数randu()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_8">1.8. 生成标准正态分布随机数randn()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_9">1.9. 生成复数版本的标准正态分布随机数randn_cpx()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_10">1.10. 生成单个随机数rand_int()和rand_double()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_11">1.11. 快速傅立叶变换fft()、fft2()和fft3()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_12">1.12. 逆傅立叶变换ifft()、ifft2()和ifft3()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_13">1.13. 将零频分量平移到频谱中心：fftshift()及其逆变换：ifftshift()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_14">1.14. 转置运算：transp()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_15">1.15. 重排数组维度permute()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_16">1.16. 卷积运算conv()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_17">1.17. 计算两个序列的相关系数xcorr()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_18">1.18. 基于高斯核函数的数据概率密度估计ksdensity()
					</a>
				</li>
				<li>
					<a href="#help_internal_doc_mathlib.header_1_19">1.19. 基于高斯核函数的曲线平滑处理ker_smooth()
					</a>
				</li>
			</ul>
		</li>
	</ul></p><a name="help_internal_doc_mathlib.header_1">
	<h1>1. 新版软件函数使用说明
	</h1></a><a name="help_internal_doc_mathlib.header_1_1">
	<h2>1.1. 数组求最大值：max()
	</h2></a><strong>函数说明：</strong> max函数支持数组和动态数组求最大值，数组元素类型可以是整型和浮点型，但不能是复数类型。函数的返回值是数组中值最大的元素。用法：max(A)或math.max(A)。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; a = [1,2;3,4];<br />&gt;&gt; max(a)<br />results:  4</code></pre><a name="help_internal_doc_mathlib.header_1_2">
	<h2>1.2. 数组求最小值：min()
	</h2></a><strong>函数说明：</strong> min函数支持数组和动态数组求最小值，数组元素类型可以是整型和浮点型，但不能是复数类型。函数的返回值是数组中值最小的元素。用法：min(A)或math.min(A)。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; a = [1,2;3,4];<br />&gt;&gt; min(a)<br />results:  1</code></pre><a name="help_internal_doc_mathlib.header_1_3">
	<h2>1.3. 数组求和：sum()
	</h2></a><strong>函数说明：</strong> sum函数支持数组和动态数组求和，数组元素类型可以是整型、浮点型、复数类型。函数的返回值是数组中所有元素的和。用法：sum(A)或math.sum(A)。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; a = [2,2i;4,5i];<br />&gt;&gt; sum(a)<br />results:  6+7i</code></pre><a name="help_internal_doc_mathlib.header_1_4">
	<h2>1.4. 数组求平均值：mean()
	</h2></a><strong>函数说明：</strong> mean函数支持数组和动态数组求平均值，数组元素类型可以是整型、浮点型和复数类型。当数组有复数类型的元素时，返回值为复数类型，否则返回值类型为双精度浮点类型。用法：<br />
求数组A所有元素的均值：<code>mean(A)</code>或<code>math.mean(A)</code>；<br />
数组A按列求均值：<code>mean(A,0)</code>;<br />
数组A按行求均值：<code>mean(A,1)</code>。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; A = [1,2;3+4i,5];<br />&gt;&gt; mean(A);<br />&gt;&gt; mean(A,0);<br />&gt;&gt; mean(A,1);</code></pre>代码运行结果分别是：<pre><code code-language=" ">results: 2.75+1i<br />results: 2+2i  3.5+0i<br />results:<br />    1.5+0i<br />    4+2i</code></pre><hr /><a name="help_internal_doc_mathlib.header_1_5">
	<h2>1.5. 数组元素查找函数：find_index( )
	</h2></a><strong>函数说明：</strong> find_index（A,x）求解数组A中值为x的元素的索引值。该函数在求解索引值的过程中，若数组为多维数组，函数将其转换为一维数组，返回值为一维整型数组，数组的每个元素依次对应为值为x的元素的索引值（即一维数组的下标值）。用法：<code>find_index(A,x)</code>或<code>math.find_index(A,x)</code>。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; A = [1,2;4,1];<br />&gt;&gt; find_index(A,1)<br />results:<br />    0<br />    3</code></pre><hr /><a name="help_internal_doc_mathlib.header_1_6">
	<h2>1.6. 线性调频z变换：czt( )
	</h2></a><strong>函数说明：</strong> czt函数通过z变换计算特定频段信号的频谱，通常采用czt函数细化关心频段内的信号频谱。用法：<code>czt（signal,num,freq_bet,freq_end）</code>，其中函数参数的物理意义：<ul>
	<li>signal： 　待变换的信号
	</li>
	<li>num:    　　　关心频段的细化点数
	</li>
	<li>freq_beg: 　 关心频段的起始频率
	</li>
	<li>freq_end: 　 关心频段的终止频率
	</li></ul><p>
	<strong>用法举例：
	</strong></p><pre><code code-language="lua">&gt;&gt; fs = 1000;<br />&gt;&gt; f = linspace(-fs/2,fs/2,1000);<br />&gt;&gt; x = sin(2*pi*f/fs);<br />&gt;&gt; f1 = 100;<br />&gt;&gt; f2 = 150;<br />&gt;&gt; ff = czt(x,1024,f1,f2);<br />&gt;&gt; fi = fig.new_figure();<br />&gt;&gt; xl = linspace(100,150,1024);<br />&gt;&gt; fig.plot(xl,abs(ff))</code></pre><p>结果图： 
	<div class="markdown-block">
		<table width="100%" style="border:0px">
			<tr style="border:0px">
				<td style="border:0px">
					<a name="help_internal_doc_mathlib.czt"><img src="image/Math_image/czt.jpg" alt="image 1: czt 频谱细化处理图" />
					</a>
				</td>
			</tr>
			<tr style="border:0px">
				<td style="border:0px" align="center">image 1: czt 频谱细化处理图
				</td>
			</tr>
		</table>
	</div></p><a name="help_internal_doc_mathlib.header_1_7">
	<h2>1.7. 生成均匀分布随机数randu()
	</h2></a><strong>函数说明：</strong> <code>R = rand.randu(m,n,k)</code>返回 $m\times n\times k$ 维在(0,1)范围内满足均匀分布的随机数。用法：<code>rand.randu(m,n,k)</code>，参数$m,n,k$都必须是值大于0的整数，其中$n$和$k$可省略。<br />
<strong>用法举例：</strong> >> A = rand.randu(3)代码运行结果：<pre><code>0.718098<br />0.085263<br />0.771667</code></pre>>> B = rand.randu(2,3)代码运行结果：<pre><code>0.670029   0.990824   0.752741<br />0.0496988  0.0274534  0.33829</code></pre><a name="help_internal_doc_mathlib.header_1_8">
	<h2>1.8. 生成标准正态分布随机数randn()
	</h2></a><strong>函数说明：</strong> <code>R = rand.randn(m,n,k)</code>返回 $m\times n\times k$ 维满足标准正态分布（均值为0，标准差为1）的随机数。用法：<code>rand.randn(m,n,k)</code>，参数$m,n,k$都必须是值大于0的整数，其中$n$和$k$可省略。<p>
	<strong>用法举例：
	</strong> </p><pre><code>&gt;&gt; rand.randn(2,2)<br />results: <br />    0.764215   -2.20585<br />    -0.495294  -1.48313</code></pre><a name="help_internal_doc_mathlib.header_1_9">
	<h2>1.9. 生成复数版本的标准正态分布随机数randn_cpx()
	</h2></a><strong>函数说明：</strong> <code>R = rand.randn_cpx(m,n,k)</code>返回 $m\times n\times k$ 维的随机复数，该复数的实部和虚部均满足标准正态分布。用法：<code>rand.randn_cpx(m,n,k)</code>，参数$m,n,k$都必须是值大于0的整数，其中$n$和$k$可省略。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; rand.randn_cpx(2,2)<br />results:<br />    0.759837-1.01945i  -0.928163+0.13555i<br />    0.939386-0.298229i  -1.37728+0.0870167i</code></pre><a name="help_internal_doc_mathlib.header_1_10">
	<h2>1.10. 生成单个随机数rand_int()和rand_double()
	</h2></a><strong>函数说明：</strong><code>rand.rand_int()</code>： 生成随机整型数；<br />
<code>rand.rand_double()</code>:  生成(0,1)区间内的随机浮点数；<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; rand.rand_int()<br />results: 3530171493<br />&gt;&gt; rand.rand_double()<br />results: 0.461303</code></pre><a name="help_internal_doc_mathlib.header_1_11">
	<h2>1.11. 快速傅立叶变换fft()、fft2()和fft3()
	</h2></a><strong>函数说明：</strong><code>fft(A)</code>用快速傅立叶变换计算序列A的离散傅立叶变换;<code>fft2(A)</code>计算二维数组A的离散傅立叶变换；<code>fft3(A)</code>计算三维数组A的离散傅立叶变换。用法：<code>fft(A)</code>或<code>math.fft(A)</code>，<code>fft2(A)</code>或<code>math.fft2(A)</code>，<code>fft3(A)</code>或<code>math.fft3(A)</code>。<br /><strong>用法举例:</strong><pre><code code-language="lua">&gt;&gt; N = 1000;<br />&gt;&gt; t = linspace(0,40,N);<br />&gt;&gt; fs = 1.0/(t[1]-t[0]);<br />&gt;&gt; f = linspace(-fs/2,fs/2,N);<br />&gt;&gt; y = zeros(1,N);<br />&gt;&gt; A = 1.0;<br />&gt;&gt; K = 0.2;<br />&gt;&gt; f0 = 0.1;<br />&gt;&gt; tt = math.mod(t,10);   //调频周期：10s<br />&gt;&gt; y = A*sin(2*pi*(f0+K*tt/2).*tt);<br />&gt;&gt; fig1 = fig.new_figure();<br />&gt;&gt; fig.plot(t,y);<br />&gt;&gt; fig.title('线性调频连续波信号');<br />&gt;&gt; fig.xlabel('Time[s]');<br />&gt;&gt; fig.ylabel('Amplitude[V]');<br />&gt;&gt; yy = fft(y)/N;<br />&gt;&gt; yy = fftshift(yy);<br />&gt;&gt; fig2 = fig.new_figure();<br />&gt;&gt; fig.plot(f,abs(yy));<br />&gt;&gt; fig.title('频域信号');<br />&gt;&gt; fig.xlabel('Frequency[Hz]');<br />&gt;&gt; fig.ylabel(Amplitude[V]);</code></pre>结果图：<center>
	<p>
		<img src="image/Math_image/线性调频信号.JPG " alt="线性调频信号" />
	</p>图2 线性调频连续波信号
	<p>
		<img src="image/Math_image/线性调频信号的频谱.JPG " alt="线性调频信号频谱" />
	</p>
	<p>图3 线性调频连续波信号频谱
	</p></center><p>二维傅立叶变换例子：<br />
</p><pre><code>&gt;&gt; a = [1,2+1i,3.2;4i,3.0,5];<br />&gt;&gt; b = fft2(a);<br />results:<br />    14.2+5i  -4.73397+6.27128i  -6.46603+0.728719i<br />    -1.8-3i  3.26603-5.19282i  1.5</code></pre><a name="help_internal_doc_mathlib.header_1_12">
	<h2>1.12. 逆傅立叶变换ifft()、ifft2()和ifft3()
	</h2></a><strong>函数说明：</strong><code>ifft(A)</code>用快速傅立叶变换计算序列A的离散逆傅立叶变换;<code>ifft2(A)</code>计算二维数组A的离散逆傅立叶变换；<code>ifft3(A)</code>计算三维数组A的离散逆傅立叶变换。用法：<code>ifft(A)</code>或<code>math.ifft(A)</code>，<code>ifft2(A)</code>或<code>math.ifft2(A)</code>，<code>ifft3(A)</code>或<code>math.ifft3(A)</code>。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; a = [1,2+1i,3.2;4i,3.0,5];<br />&gt;&gt; ifft2(a)<br />results:<br />    2.36667+0.833333i -1.07767+0.121453i -0.788996+1.04521i<br />    -0.3-0.5i         0.255662-0.63453i   0.544338-0.86547i </code></pre><a name="help_internal_doc_mathlib.header_1_13">
	<h2>1.13. 将零频分量平移到频谱中心：fftshift()及其逆变换：ifftshift()
	</h2></a><strong>函数说明：</strong><code>fftshift(A)</code>将零频分量平移到数组中心，重新排新数据A；<code>ifftshift(A)</code>将进行过零频平移的数据A重新排列回原始变换输出的样子。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; a = [1,2,3,4,5];<br />&gt;&gt; b = fftshift(a)<br />results:<br />    4+0i 5+0i 1+0i 2+0i 3+0i<br />&gt;&gt; ifftshift(b)<br />results:<br />    1+0i 2+0i 3+0i 4+0i 5+0i<br />&gt;&gt; ifftshift(a)<br />results:<br />    3+0i 4+0i 5+0i 1+0i 2+0i<br />&gt;&gt; c = [1,2,3;4,5,6;7,8,9]<br />    1 2 3<br />    4 5 6<br />    7 8 9<br />&gt;&gt; fftshift(c)<br />    9+0i 7+0i 8+0i<br />    3+0i 1+0i 2+0i<br />    6+0i 4+0i 5+0i<br />&gt;&gt; ifftshift(c)<br />    5+0i 6+0i 4+0i<br />    8+0i 9+0i 7+0i<br />    2+0i 3+0i 1+0i</code></pre><a name="help_internal_doc_mathlib.header_1_14">
	<h2>1.14. 转置运算：transp()
	</h2></a><strong>函数说明：</strong> <code>transp(A)</code>将矩阵A的行和列互换得到新的矩阵。用法：<code>transp(A)</code>或<code>math.tranps(A)</code>。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; a = [1,2,3;4,5,6]<br />results:<br />    1  2  3<br />    4  5  6<br />&gt;&gt; transp(a)<br />results:<br />    1  4<br />    2  5<br />    3  6</code></pre><a name="help_internal_doc_mathlib.header_1_15">
	<h2>1.15. 重排数组维度permute()
	</h2></a><strong>函数说明：</strong><code>permute(A,[m,n,k,…])</code>将数组A的第m+1维和第1维互换，第n+1维和第2维互换，第k+1维与第3维互换，依次最多互换6个维度，得到新的数组。注意这里m和n都要加1的原因是c++语言的数组下标是从0开始的。permute函数是transp函数在高维数组转置上的推广。用法：<code>permute(A,[m,n,k,…])</code>或<code>math.permute(A,[m,n,k,…])</code>，转置参数向量<code>[m,n,k,…]</code>长度大于等于2。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; a = [1,2,3;4,5,6]<br />results:<br />    1  2  3<br />    4  5  6<br />&gt;&gt; permute(a,[1,0])<br />results:<br />    1  4<br />    2  5<br />    3  6</code></pre><a name="help_internal_doc_mathlib.header_1_16">
	<h2>1.16. 卷积运算conv()
	</h2></a><strong>函数说明：</strong>卷积是一种数学运算，它涉及到积分或级数运算，是数字信号处理中最基础、最重要的概念。两个时间信号$f(n)$和$g(n)$的卷积定义为：<p>$$
f(n)* g(n) = \int_{-\infty}^\infty f(\tau)g(n-\tau)d\tau
$$</p>其离散的定义为：<p>$$
f(n)\ast g(n)=\sum_{\tau=-\infty}^\infty f(\tau)g(n-\tau)
$$</p>时间序列的卷积的一个通俗的例子是多项式乘法，如<p>$a(x) = 1+2x+x^2, b(x) = x+3x^2$，两多项式的系数分别表示为<br />
$a(n) = [1,2,1]$<br />
$b(n) = [0,1,3]$<br />
</p>多项式的乘法:<br />
$$
\begin{aligned}
 c(x) &= a(x)\cdot b(x) \\
      &= (x^2+2x+1)\cdot (3x^2+x)\\
      &= x+5x^2+7x^3+3x^4
\end{aligned}
$$$c[x]$的系数向量$c[n]=[0,1,5,7,3]$，而$a(n)$与$b(n)$的卷积：$$
\begin{aligned} 
  a(n)*b(n) &= [1,2,1]*[0,1,3] = [0,1,5,7,3] \\
       &=c(n)
\end{aligned}
$$<strong>函数用法：</strong><br />
向量a与b的卷积：<code>conv(a,b)</code>或<code>math.conv(a,b)</code>；二维数组a与b的卷积：<code>conv2(a,b)</code>或<code>math.conv2(a,b)</code>。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; a = [1,2,1];<br />&gt;&gt; b = [0,1,3];<br />&gt;&gt; conv(a,b)<br />results:<br />    0 1 5 7 3</code></pre><a name="help_internal_doc_mathlib.header_1_17">
	<h2>1.17. 计算两个序列的相关系数xcorr()
	</h2></a><strong>函数说明：</strong>信号X和信号Y的相关系数公式：$$
\rho = \frac{Cov(X,Y)}{\sigma_X \sigma_Y}
$$即信号$X$和信号$Y$的协方差除以$X$的标准差和$Y$的标准差。它反映了两个信号变化时是同向还是反向，如果同向变化就为正，反向变化就为负，两信号的相关性（协同性）越强，相关系数的绝对值越大，反之越小，如果完全不相关，则相关系数的值为0。<br />
<strong>函数用法：</strong>向量X和向量Y的相关系数：<code>math.xcorr(X,Y)</code>。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; a = [1,2,3];<br />&gt;&gt; b = [0,1,3];<br />&gt;&gt; math.xcorr(a,b);<br />results:<br />    3 7 11 3 0</code></pre><a name="help_internal_doc_mathlib.header_1_18">
	<h2>1.18. 基于高斯核函数的数据概率密度估计ksdensity()
	</h2></a><strong>函数说明：</strong>核密度估计（Kernel density estimation），是一种用于估计概率密度函数的非参数方法，$x_1,x_2,\ldots,x_n$为独立同分布的$n$个样本点，设其概率密度函数为$f$，核密度估计公式为：$$
\hat{f}_h(x)=\frac{1}{n}\sum_{i=1}^{n} K_h(x-x_i)=\frac{1}{nh}\sum_{i=1}^{n} K\left(\frac{x-x_i}{h}\right)
$$<p>$K(.)$为核函数，$h>0$为平滑参数，称为带宽或核宽。<code>ksdensity()</code>函数采用的核为高斯核。</p><strong>函数用法：</strong> 一维信号A的概率密度为<code>math.ksdensity(A)</code>。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; s = rand.randn(1,1000);<br />&gt;&gt; y = math.ksdensity(s);<br />&gt;&gt; f = fig.new_figure();<br />&gt;&gt; fig.plot(1:100,y);</code></pre>结果图：<center>
	<p>
		<img src="image/Math_image/高斯核概率密度图.JPG" alt="高斯核概率密度估计" />
	</p></center><center>图4 正态分布信号高斯核概率密度估计 </center><a name="help_internal_doc_mathlib.header_1_19">
	<h2>1.19. 基于高斯核函数的曲线平滑处理ker_smooth()
	</h2></a><p>
	<strong>函数说明：
	</strong>核、窗、掩模滤波是数字图像空间滤波的基本方法，平滑滤波是空间滤波的应用之一，曲线平滑处理相当于“一维图像”的平滑滤波。 基于高斯核函数的曲线平滑的处理过程是固定原数据曲线，将高斯核函数的峰值位置对齐到第一个数据点并相乘，其它的数据点与对应的高斯核函数的点数据相乘，最后加和并除以高斯核的和得到第一个数据的处理后的新数据。依次处理第2个数据点、第3个数据点、……、最后一个数据点。数学表达式为：</p><p>$$\hat{f}(x)=\frac{\sum_{i=1}^n K(x_i-x;h)y_i}{\sum_{i=1}^n K(x_i-x;h)}$$</p><strong>函数用法：</strong> <code>math.ker_smooth(x,y,h)</code>，其中x为待平滑曲线数据的x坐标，y为待平滑曲线数据的y坐标，h为高斯核核宽，根据平滑效果手动设置。<br />
<strong>用法举例：</strong><pre><code>&gt;&gt; local x = linspace(1,2*pi,200);<br />&gt;&gt; local data = cos(x) + exp(1./x);<br />&gt;&gt; f1 = fig.new_figure();<br />&gt;&gt; fig.plot(x,data);<br />&gt;&gt; local y = data + rand.randu(200);<br />&gt;&gt; f2 = fig.new_figure();<br />&gt;&gt; fig.plot(x,y);<br />&gt;&gt; local h = 0.2;                                     //可调参数<br />&gt;&gt; local xs = linspace(min(x)-3*h,max(x)+3*h,100);<br />&gt;&gt; local s = math.ker_smooth(x,y,h);<br />&gt;&gt; f3 = fig.new_figure();<br />&gt;&gt; fig.plot(xs,s);<br /></code></pre>结果图：<center>
	<p>
		<img src="image/Math_image/平滑前的曲线.JPG" alt="原曲线" />
	</p>图5 平滑处理前的曲线
	<p>
		<img src="image/Math_image/平滑后的曲线.JPG" alt="平滑后的曲线" />
	</p>图6 平滑处理后的曲线</center></div>